<!--
╔═══════════════════════════════════════════════════════════════════════════════╗
║                        WORD SURVIVOR - TABLE OF CONTENTS                       ║
╠═══════════════════════════════════════════════════════════════════════════════╣
║ This file is ~9000 lines. Use [SEC:*] markers to navigate.                    ║
║ Search for any marker below to jump to that section.                          ║
╠═══════════════════════════════════════════════════════════════════════════════╣
║                                                                               ║
║ CSS (lines ~33-2468)                                                          ║
║ ├─ Design System Variables        │ :root { --paper                           ║
║ ├─ Typography & Layout            │ body, .container                          ║
║ ├─ Game UI Components             │ .health-bar, .word-display                ║
║ └─ Modals & Menus                 │ .modal, .item-select                      ║
║                                                                               ║
║ HTML (lines ~2469-2719)                                                       ║
║ └─ Game Canvas & UI Elements      │ <canvas>, <div id="ui">                   ║
║                                                                               ║
║ JAVASCRIPT (lines ~2720-9100)                                                 ║
║ ├─ Configuration & Colors         │ [SEC:CONFIG]                              ║
║ ├─ Canvas Setup                   │ [SEC:CANVAS]                              ║
║ ├─ Game State                     │ [SEC:STATE]                               ║
║ │   ├─ Pause State                │ [SEC:STATE:PAUSE]                         ║
║ │   ├─ Practice Mode              │ [SEC:STATE:PRACTICE]                      ║
║ │   ├─ White Space                │ [SEC:STATE:WHITESPACE]                    ║
║ │   ├─ Player                     │ [SEC:STATE:PLAYER]                        ║
║ │   ├─ Modifiers                  │ [SEC:STATE:MODIFIERS]                     ║
║ │   └─ Stats                      │ [SEC:STATE:STATS]                         ║
║ ├─ Object Pools                   │ [SEC:POOLS]                               ║
║ ├─ Word System                    │ [SEC:WORDS]                               ║
║ ├─ Enemy System                   │ [SEC:ENEMIES]                             ║
║ │   ├─ Type Definitions           │ [SEC:ENEMIES:TYPES]                       ║
║ │   ├─ AI Behaviors               │ [SEC:ENEMIES:BEHAVIORS]                   ║
║ │   ├─ Elite Modifiers            │ [SEC:ENEMIES:ELITE]                       ║
║ │   └─ Spawning Logic             │ [SEC:ENEMIES:SPAWN]                       ║
║ ├─ Item System                    │ [SEC:ITEMS]                               ║
║ │   ├─ White Tier                 │ [SEC:ITEMS:WHITE]                         ║
║ │   ├─ Green Tier                 │ [SEC:ITEMS:GREEN]                         ║
║ │   ├─ Red Tier                   │ [SEC:ITEMS:RED]                           ║
║ │   ├─ Legendary Tier             │ [SEC:ITEMS:LEGENDARY]                     ║
║ │   ├─ Synergies                  │ [SEC:ITEMS:SYNERGIES]                     ║
║ │   ├─ Drops & Probability        │ [SEC:ITEMS:DROPS]                         ║
║ │   ├─ Choice UI                  │ [SEC:ITEMS:CHOICE]                        ║
║ │   └─ Notifications              │ [SEC:ITEMS:NOTIFY]                        ║
║ ├─ Upgrades                       │ [SEC:UPGRADES]                            ║
║ ├─ Audio System                   │ [SEC:AUDIO]                               ║
║ ├─ White Space System             │ [SEC:WHITESPACE]                          ║
║ ├─ Combat System                  │ [SEC:COMBAT]                              ║
║ ├─ Item Effect Helpers            │ [SEC:ITEMS:HELPERS]                       ║
║ ├─ Damage Numbers                 │ [SEC:DAMAGE]                              ║
║ ├─ Input Handling                 │ [SEC:INPUT]                               ║
║ │   ├─ Keyboard                   │ [SEC:INPUT:KEYBOARD]                      ║
║ │   ├─ Mouse                      │ [SEC:INPUT:MOUSE]                         ║
║ │   └─ Touch/Mobile               │ [SEC:INPUT:TOUCH]                         ║
║ ├─ Update Loop                    │ [SEC:UPDATE]                              ║
║ │   ├─ Player                     │ [SEC:UPDATE:PLAYER]                       ║
║ │   ├─ Enemies                    │ [SEC:UPDATE:ENEMIES]                      ║
║ │   ├─ Projectiles                │ [SEC:UPDATE:PROJECTILES]                  ║
║ │   └─ Gems/XP                    │ [SEC:UPDATE:GEMS]                         ║
║ ├─ Render Loop                    │ [SEC:RENDER]                              ║
║ ├─ Game Loop                      │ [SEC:GAMELOOP]                            ║
║ ├─ Game Management                │ [SEC:MANAGEMENT]                          ║
║ ├─ Sharing                        │ [SEC:SHARING]                             ║
║ ├─ Persistence (Save/Load)        │ [SEC:PERSISTENCE]                         ║
║ ├─ UI & Modals                    │ [SEC:UI]                                  ║
║ ├─ Practice/Debug Mode            │ [SEC:DEBUG]                               ║
║ ├─ Tips System                    │ [SEC:TIPS]                                ║
║ └─ Mob Tips                       │ [SEC:MOBTIPS]                             ║
║                                                                               ║
╚═══════════════════════════════════════════════════════════════════════════════╝
-->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover">
  <meta name="theme-color" content="#f4f1e8">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

  <!-- Open Graph for viral sharing -->
  <meta property="og:title" content="Word Survivor - Type to Survive!">
  <meta property="og:description" content="The viral typing survival game. How long can YOU survive?">
  <meta property="og:type" content="website">
  <meta property="og:image" content="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 1200 630'%3E%3Crect fill='%23f4f1e8' width='1200' height='630'/%3E%3Crect fill='%231a1714' x='50' y='50' width='1100' height='530' rx='20'/%3E%3Ctext x='600' y='280' text-anchor='middle' font-family='Courier New, monospace' font-size='120' font-weight='bold' fill='%23f4f1e8'%3EWORD%3C/text%3E%3Ctext x='600' y='420' text-anchor='middle' font-family='Courier New, monospace' font-size='120' font-weight='bold' fill='%23c41e3a'%3ESURVIVOR%3C/text%3E%3C/svg%3E">

  <!-- Twitter Card -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="Word Survivor">
  <meta name="twitter:description" content="Type words. Kill enemies. Survive.">

  <title>Word Survivor</title>
  <link rel="manifest" href="manifest.json">

  <!-- Google Fonts: Courier Prime -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Courier+Prime:wght@400;700&display=swap" rel="stylesheet">

  <!-- Lucide Icons -->
  <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.min.js"></script>

  <style>
    /* ============================================================
       THE UNDERWOOD DESIGN SYSTEM
       Documentary aesthetic: typed manuscript with editorial confidence
       ============================================================ */
    :root {
      /* ============================================================
         PRIMITIVE COLORS
         Raw color values. Prefer semantic tokens in components.
         ============================================================ */
      --primitive-paper: #f4f1e8;
      --primitive-paper-warm: #e8dcc8;

      --primitive-ink: #1a1714;
      --primitive-ink-medium: #3d3830;
      --primitive-ink-light: #5f574e;
      --primitive-ink-muted: #8a8279;

      --primitive-blue: #2d4a6f;
      --primitive-blue-light: #3d5a7f;
      --primitive-yellow: #d4a84b;
      --primitive-yellow-light: #e8c060;
      --primitive-red: #c41e3a;
      --primitive-red-light: #e63950;
      --primitive-green: #4a7c59;
      --primitive-green-light: #5a9c6a;

      /* ============================================================
         SEMANTIC COLORS
         Use these in components. Names describe purpose.
         ============================================================ */

      /* Surfaces */
      --paper: var(--primitive-paper);
      --paper-dark: var(--primitive-paper-warm);

      /* Text */
      --ink: var(--primitive-ink);
      --ink-light: var(--primitive-ink-medium);
      --muted-dark: var(--primitive-ink-light);
      --muted: var(--primitive-ink-muted);

      /* Interactive (buttons, links, selected states) */
      --carbon-blue: var(--primitive-blue);
      --carbon-blue-hover: var(--primitive-blue-light);

      /* Status */
      --aged-yellow: var(--primitive-yellow);
      --aged-yellow-light: var(--primitive-yellow-light);
      --ribbon-red: var(--primitive-red);
      --ribbon-red-light: var(--primitive-red-light);
      --aged-yellow-dark: #b08a30; /* Darker gold for text on paper — WCAG AA compliant */

      /* ============================================================
         TIER COLORS
         For item/upgrade rarity indication
         ============================================================ */
      --tier-common: var(--primitive-ink-light);
      --tier-common-border: var(--primitive-ink-muted);
      --tier-uncommon: var(--primitive-green);
      --tier-uncommon-border: var(--primitive-green-light);
      --tier-rare: var(--primitive-red);
      --tier-rare-border: var(--primitive-red-light);
      --tier-legendary: var(--primitive-yellow);
      --tier-legendary-border: var(--primitive-yellow-light);

      /* ============================================================
         TYPOGRAPHY
         ============================================================ */

      /* Font families */
      --font-mono: 'Courier Prime', 'Courier New', Courier, monospace;

      /* Type scale (Major Third — 1.25 ratio) */
      --text-xs: 9px;      /* Micro labels, tier tags */
      --text-sm: 11px;     /* Secondary labels */
      --text-base: 13px;   /* Body text, descriptions */
      --text-md: 15px;     /* Card titles, section headers */
      --text-lg: 18px;     /* Section titles */
      --text-xl: 24px;     /* Modal titles */
      --text-2xl: 32px;    /* Page titles */
      --text-display: clamp(28px, 6vw, 56px); /* Word display */

      /* ============================================================
         SPACING
         Based on 4px increments. Use for padding, margins, gaps.
         ============================================================ */
      --space-1: 4px;
      --space-2: 8px;
      --space-3: 12px;
      --space-4: 16px;
      --space-5: 24px;
      --space-6: 32px;
      --space-7: 48px;
      --space-8: 64px;

      /* ============================================================
         BORDERS
         ============================================================ */
      --radius-sm: 2px;   /* Bars, tags, small elements */
      --radius-md: 4px;   /* Buttons, modals, cards */
      --radius-lg: 6px;   /* Icons, avatar-like elements */

      /* Border shorthand tokens */
      --border-thin: 1px solid var(--muted);
      --border-medium: 2px solid var(--ink);
      --border-thick: 3px solid var(--ink);

      /* ============================================================
         SHADOWS
         Flat paper-offset style, no blur
         ============================================================ */
      --shadow-sm: 2px 2px 0 rgba(0,0,0,0.1);  /* Small elements, hover */
      --shadow-md: 4px 4px 0 rgba(0,0,0,0.1);  /* Cards, panels */
      --shadow-lg: 6px 6px 0 rgba(0,0,0,0.1);  /* Modals, primary focus */

      /* ============================================================
         ANIMATION
         ============================================================ */
      --duration-fast: 0.1s;
      --duration-medium: 0.15s;
      --duration-slow: 0.25s;

      --ease-default: ease;
      --ease-out: cubic-bezier(0.16, 1, 0.3, 1);
      --ease-bounce: cubic-bezier(0.34, 1.56, 0.64, 1);

      /* Transition shorthand tokens */
      --transition-fast: var(--duration-fast) var(--ease-default);
      --transition-medium: var(--duration-medium) var(--ease-out);
      --transition-slow: var(--duration-slow) var(--ease-default);

      /* ============================================================
         Z-INDEX SCALE
         For predictable stacking in canvas + HTML hybrid
         ============================================================ */
      --z-canvas: 1;
      --z-hud: 10;
      --z-word-display: 50;
      --z-target-info: 50;
      --z-modal-overlay: 100;
      --z-modal: 101;
      --z-mob-tip: 120;
      --z-tip-overlay: 149;
      --z-tip-modal: 150;
      --z-debug-panel: 200;
      --z-tooltip: 300;
      --z-noise-overlay: 9998;
      --z-vignette: 9999;

      /* ============================================================
         OPACITY SCALE
         For consistent transparency across components
         ============================================================ */
      --opacity-subtle: 0.1;
      --opacity-light: 0.3;
      --opacity-medium: 0.5;
      --opacity-heavy: 0.7;
      --opacity-solid: 0.9;

      /* ============================================================
         ADDITIONAL TYPOGRAPHY
         ============================================================ */
      /* Serif font for enemy types */
      --font-serif: Georgia, 'Times New Roman', serif;

      /* Letter spacing scale */
      --tracking-tight: 0.02em;
      --tracking-normal: 0.05em;
      --tracking-wide: 0.1em;
      --tracking-wider: 0.15em;
      --tracking-widest: 0.2em;

      /* ============================================================
         COMPONENT SIZES
         Standardized sizing for UI components
         ============================================================ */
      --icon-button-size: 50px;
      --item-slot-size: 44px;
      --modal-max-width: 700px;
      --modal-max-width-sm: 420px;
    }

    /* ============================================================
       TIER UTILITY CLASSES
       For JS integration with design system colors
       ============================================================ */
    .tier-white { color: var(--tier-common); border-color: var(--tier-common-border); }
    .tier-green { color: var(--tier-uncommon); border-color: var(--tier-uncommon-border); }
    .tier-red { color: var(--tier-rare); border-color: var(--tier-rare-border); }
    .tier-legendary { color: var(--tier-legendary); border-color: var(--tier-legendary-border); }

    .tier-bg-white { background: rgba(168, 159, 145, var(--opacity-light)); }
    .tier-bg-green { background: rgba(90, 156, 106, var(--opacity-light)); }
    .tier-bg-red { background: rgba(196, 30, 58, var(--opacity-light)); }
    .tier-bg-legendary { background: rgba(212, 168, 75, 0.4); }

    * { margin: 0; padding: 0; box-sizing: border-box; }

    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: var(--paper);
      font-family: var(--font-mono);
      touch-action: none;
      user-select: none;
      -webkit-user-select: none;
      -webkit-tap-highlight-color: transparent;
      color: var(--ink);
    }

    /* Paper noise texture overlay */
    body::before {
      content: '';
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: var(--z-vignette);
      opacity: 0.03;
      background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.65' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)'/%3E%3C/svg%3E");
    }

    /* Vignette overlay */
    body::after {
      content: '';
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: var(--z-noise-overlay);
      background: radial-gradient(ellipse at center, transparent 50%, rgba(26, 23, 20, 0.15) 100%);
    }

    /* ============================================================
       REDUCED MOTION
       Respect user preferences for accessibility
       ============================================================ */
    @media (prefers-reduced-motion: reduce) {
      *,
      *::before,
      *::after {
        animation-duration: 0.01ms !important;
        animation-iteration-count: 1 !important;
        transition-duration: 0.01ms !important;
      }
    }

    /* ============================================================
       FOCUS STATES
       Accessible focus indicators
       ============================================================ */
    :focus-visible {
      outline: 2px solid var(--carbon-blue);
      outline-offset: 2px;
    }

    button:focus-visible,
    .btn:focus-visible {
      outline: 2px solid var(--carbon-blue);
      outline-offset: 2px;
    }

    canvas:focus-visible { outline: none; }
    .tab-btn:focus-visible,
    .tier-btn:focus-visible,
    .debug-tab:focus-visible,
    .debug-spawn-btn:focus-visible,
    .debug-btn:focus-visible,
    .choice-option:focus-visible {
      outline: 2px solid var(--carbon-blue);
      outline-offset: 2px;
    }
    .tips-toggle input[type="checkbox"]:focus-visible {
      outline: 2px solid var(--carbon-blue);
      outline-offset: 2px;
    }

    canvas {
      display: block;
      position: absolute;
      top: 0;
      left: 0;
    }

    /* Hidden input for mobile keyboard - invisible but focusable for iOS.
       Positioned at top-left of viewport (not offscreen) to prevent iOS
       from scrolling to bring a -100px offscreen input into view. */
    #mobileInput {
      position: fixed;
      left: 0;
      top: 0;
      width: 1px;
      height: 1px;
      opacity: 0;
      font-size: 16px; /* Prevents iOS zoom on focus */
      border: none;
      outline: none;
      background: transparent;
      color: transparent;
      caret-color: transparent;
      z-index: -1;
      -webkit-appearance: none;
      -moz-appearance: none;
      appearance: none;
    }

    /* Mobile: When keyboard is open during gameplay, shrink #ui to the
       visible area above the keyboard. All %-based bottom positions
       (word display, health bar, XP bar) automatically reflow.
       45% is a safe estimate for iOS/Android keyboard height. */
    body.keyboard-open #ui {
      height: 55%;
    }
    body.keyboard-open .word-display {
      font-size: clamp(20px, 5vw, 36px) !important;
    }

    #ui {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: var(--z-hud);
    }

    #ui > * {
      pointer-events: auto;
    }

    .word-display {
      position: absolute;
      bottom: 18%;
      left: 50%;
      transform: translateX(-50%);
      font-size: var(--text-display);
      font-family: var(--font-mono);
      font-weight: 700;
      color: var(--muted-dark);
      opacity: 0.45;
      text-shadow: none;
      letter-spacing: var(--tracking-wide);
      text-transform: uppercase;
      transition: opacity var(--transition-medium), filter var(--transition-medium);
      z-index: var(--z-word-display);
    }

    .word-display.white-space-dim {
      opacity: 0.3;
      filter: grayscale(0.3);
      transition: opacity var(--transition-fast), filter var(--transition-fast);
    }

    .typed {
      color: var(--ink);
      opacity: 1;
      text-shadow: 1px 1px 0 var(--ribbon-red); /* Ribbon bleed effect */
    }

    /* Typing cursor - DOM element positioned between typed and untyped letters */
    .cursor {
      display: inline-block;
      width: 3px;
      height: 0.9em;
      background: var(--ink);
      margin: 0 2px;
      vertical-align: baseline;
      position: relative;
      top: 0.1em;
      animation: cursor-blink 0.8s step-end infinite;
    }

    @keyframes cursor-blink {
      0%, 100% { opacity: 1; }
      50% { opacity: 0; }
    }

    /* Enemy type text styles - Underwood themed */
    .word-display.enemy-mumble { }
    .word-display.enemy-stutter {
      letter-spacing: 0.3em;
      animation: stutter-shake 0.1s infinite;
    }
    @keyframes stutter-shake {
      0%, 100% { transform: translateX(-50%); }
      25% { transform: translateX(calc(-50% - 2px)); }
      75% { transform: translateX(calc(-50% + 2px)); }
    }
    .word-display.enemy-whisper {
      opacity: 0.15;
      font-weight: 400;
      letter-spacing: var(--tracking-widest);
      filter: blur(1px);
      transition: opacity var(--transition-slow), filter var(--transition-slow);
      color: var(--muted);
    }
    .word-display.enemy-whisper:hover {
      opacity: 0.4;
      filter: blur(0.5px);
    }
    .word-display.enemy-shout {
      font-size: clamp(48px, 12vw, 96px);
      font-weight: 900;
      color: var(--ribbon-red);
      text-shadow: 2px 2px 0 var(--ink), 4px 4px 0 rgba(196, 30, 58, 0.3);
      letter-spacing: var(--tracking-wider);
      animation: shout-pulse 0.12s infinite alternate;
    }
    @keyframes shout-pulse {
      from { transform: translateX(-50%) scale(1); }
      to { transform: translateX(-50%) scale(1.05); }
    }
    .word-display.enemy-footnote {
      font-size: clamp(24px, 5vw, 44px);
      opacity: 1;
      color: var(--tier-uncommon);
      font-weight: 500;
      font-style: italic;
      letter-spacing: var(--tracking-normal);
    }
    .word-display.enemy-footnote .footnote-prefix {
      color: var(--tier-uncommon-border);
      font-style: normal;
      font-size: 0.6em;
      margin-right: 4px;
      vertical-align: super;
    }
    .word-display.enemy-slur {
      filter: blur(1.5px);
      opacity: 0.7;
      letter-spacing: var(--tracking-wider);
      color: var(--muted-dark);
      text-shadow: 2px 0 0 var(--muted), -2px 0 0 var(--muted);
    }
    .word-display.enemy-jargon {
      font-family: var(--font-serif);
      font-size: clamp(20px, 4vw, 36px);
      color: var(--muted-dark);
      letter-spacing: var(--tracking-tight);
      font-weight: 400;
    }
    .word-display.enemy-jargon::before {
      content: "« ";
      color: var(--muted);
    }
    .word-display.enemy-jargon::after {
      content: " »";
      color: var(--muted);
    }
    .word-display.enemy-palindrome {
      color: var(--carbon-blue);
      animation: palindrome-flip 2s ease-in-out infinite;
    }
    @keyframes palindrome-flip {
      0%, 100% { transform: translateX(-50%) scaleX(1); }
      50% { transform: translateX(-50%) scaleX(-1); }
    }
    .word-display.enemy-echo {
      color: var(--carbon-blue);
      text-shadow:
        3px 3px 0 rgba(45, 74, 111, 0.5),
        6px 6px 0 rgba(45, 74, 111, 0.3),
        9px 9px 0 rgba(45, 74, 111, 0.1);
      letter-spacing: var(--tracking-wide);
    }
    .word-display.enemy-typo {
      color: var(--aged-yellow);
      animation: typo-glitch 0.3s infinite;
    }
    @keyframes typo-glitch {
      0%, 100% { transform: translateX(-50%); }
      20% { transform: translateX(calc(-50% + 3px)) skewX(2deg); }
      40% { transform: translateX(calc(-50% - 2px)) skewX(-1deg); }
      60% { transform: translateX(calc(-50% + 1px)); }
      80% { transform: translateX(calc(-50% - 3px)) skewX(1deg); }
    }
    .word-display.enemy-censor {
      background: var(--ink);
      color: var(--paper);
      padding: var(--space-1) var(--space-5);
      border-radius: var(--radius-sm);
      transition: color var(--transition-fast);
    }
    .word-display.enemy-censor .typed {
      color: var(--tier-uncommon-border);
      text-shadow: 1px 1px 0 var(--ribbon-red);
    }
    .word-display.enemy-censor .censored-letter {
      color: var(--ink-light);
      background: var(--ink-light);
      padding: 0 2px;
    }
    .crit-letter {
      color: #c41e3a;
      text-shadow: 0 0 10px #ff0000, 0 0 20px #ff6600;
      animation: pulse 0.5s infinite alternate;
    }
    .word-display.enemy-quote {
      font-family: var(--font-serif);
      font-style: italic;
      color: var(--aged-yellow);
    }
    .word-display.enemy-quote::before {
      content: "" ";
      font-size: 1.5em;
      color: var(--muted);
    }
    .word-display.enemy-quote::after {
      content: " "";
      font-size: 1.5em;
      color: var(--muted);
    }
    .word-display.enemy-thesis {
      font-size: clamp(20px, 4vw, 36px);
      font-family: var(--font-serif);
      font-weight: 700;
      color: var(--ribbon-red);
      letter-spacing: var(--tracking-normal);
      text-transform: uppercase;
    }
    .word-display.enemy-citation_needed {
      color: var(--carbon-blue);
    }
    .word-display.enemy-citation_needed::after {
      content: " [citation needed]";
      font-size: 0.6em;
      color: var(--muted-dark);
      vertical-align: super;
    }
    .word-display.enemy-misspelling {
      color: var(--ribbon-red);
      text-decoration: wavy underline var(--ribbon-red);
      text-underline-offset: 6px;
    }

    /* Elite modifier text styles - Underwood themed */
    .word-display.elite-bold {
      font-weight: 900;
      font-size: clamp(48px, 12vw, 96px);
      -webkit-text-stroke: 2px var(--paper);
      text-shadow: 3px 3px 0 var(--ink), 6px 6px 0 rgba(26, 23, 20, 0.3);
      letter-spacing: var(--tracking-wide);
      color: var(--ink);
      opacity: 1;
    }
    .word-display.elite-italic {
      font-style: italic;
      transform: translateX(-50%) skewX(-15deg);
      letter-spacing: var(--tracking-wider);
      color: var(--carbon-blue);
    }
    .word-display.elite-underlined {
      text-decoration: underline;
      text-decoration-color: var(--aged-yellow);
      text-decoration-thickness: 4px;
      text-underline-offset: 10px;
    }
    .word-display.elite-strikethrough {
      text-decoration: line-through;
      text-decoration-color: var(--ribbon-red);
      text-decoration-thickness: 4px;
      opacity: 0.5;
      color: var(--muted);
    }
    .word-display.elite-superscript {
      font-size: clamp(14px, 2.5vw, 24px);
      bottom: 28%;
      color: var(--tier-uncommon);
      animation: float-up 1s ease-in-out infinite alternate;
    }
    @keyframes float-up {
      from { transform: translateX(-50%) translateY(0); }
      to { transform: translateX(-50%) translateY(-8px); }
    }
    .word-display.elite-subscript {
      font-size: clamp(14px, 2.5vw, 24px);
      bottom: 5%;
      color: var(--muted-dark);
      animation: float-down 1s ease-in-out infinite alternate;
    }
    @keyframes float-down {
      from { transform: translateX(-50%) translateY(0); }
      to { transform: translateX(-50%) translateY(8px); }
    }
    .word-display.elite-highlighted {
      background: linear-gradient(180deg, rgba(212, 168, 75, 0.6) 0%, rgba(212, 168, 75, 0.4) 100%);
      padding: var(--space-3) var(--space-5);
      border-radius: var(--radius-sm);
      color: var(--ink);
      font-weight: 700;
      opacity: 1;
    }
    .word-display.elite-hyperlinked {
      color: var(--carbon-blue);
      text-decoration: underline;
      text-decoration-color: var(--carbon-blue);
      text-decoration-thickness: 3px;
      text-underline-offset: 6px;
      animation: hyperlink-glow 0.8s ease-in-out infinite alternate;
    }
    @keyframes hyperlink-glow {
      from { text-shadow: 0 0 10px var(--carbon-blue); }
      to { text-shadow: 0 0 20px var(--carbon-blue), 0 0 30px var(--carbon-blue); }
    }

    /* Debug/Practice Mode Panel */
    .debug-panel {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 90%;
      max-width: 500px;
      max-height: 85vh;
      overflow-y: auto;
      background: var(--paper);
      border: 2px solid var(--ink);
      border-radius: var(--radius-md);
      padding: var(--space-5);
      z-index: var(--z-debug-panel);
      font-size: var(--text-sm);
      box-shadow: var(--shadow-lg);
      color: var(--ink);
    }
    .debug-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: var(--space-3);
    }
    .debug-title {
      color: var(--ink);
      font-size: var(--text-lg);
      font-weight: bold;
      text-transform: uppercase;
      letter-spacing: var(--tracking-normal);
    }
    .debug-close {
      background: none;
      border: 2px solid var(--ink);
      border-radius: var(--radius-md);
      color: var(--ink);
      font-size: var(--text-xl);
      cursor: pointer;
      min-width: 44px;
      min-height: 44px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .debug-close:hover {
      background: var(--ribbon-red);
      border-color: var(--ribbon-red);
      color: var(--paper);
    }
    .debug-info {
      color: var(--muted-dark);
      margin-bottom: var(--space-4);
      text-align: center;
    }
    .debug-tabs {
      display: flex;
      gap: var(--space-1);
      margin-bottom: var(--space-4);
      border-bottom: 1px solid var(--muted);
      padding-bottom: var(--space-3);
    }
    .debug-tab {
      flex: 1;
      background: var(--paper);
      border: 1px solid var(--muted);
      color: var(--muted-dark);
      padding: var(--space-3);
      border-radius: var(--radius-md);
      cursor: pointer;
      font-size: var(--text-base);
      font-family: var(--font-mono);
      transition: all var(--transition-medium);
      min-height: 44px;
    }
    .debug-tab:hover {
      border-color: var(--ink);
      color: var(--ink);
    }
    .debug-tab.active {
      background: var(--paper-dark);
      border-color: var(--ink);
      color: var(--ink);
    }
    .debug-tab-content { display: none; }
    .debug-tab-content.active { display: block; }
    .debug-category {
      margin-bottom: var(--space-4);
    }
    .debug-category-title {
      color: var(--carbon-blue);
      font-size: var(--text-sm);
      text-transform: uppercase;
      letter-spacing: var(--tracking-normal);
      margin-bottom: var(--space-2);
      padding-bottom: var(--space-1);
      border-bottom: 1px solid var(--muted);
    }
    .debug-buttons {
      display: flex;
      flex-wrap: wrap;
      gap: var(--space-2);
    }
    .debug-spawn-btn {
      background: var(--paper);
      border: 1px solid var(--carbon-blue);
      color: var(--ink);
      padding: var(--space-2) var(--space-3);
      border-radius: var(--radius-md);
      cursor: pointer;
      font-size: var(--text-sm);
      font-family: var(--font-mono);
      transition: all var(--transition-medium);
      min-height: 44px;
    }
    .debug-spawn-btn:hover {
      background: var(--paper-dark);
      border-color: var(--ink);
    }
    .debug-spawn-btn.active {
      background: var(--carbon-blue);
      color: var(--paper);
      border-color: var(--carbon-blue);
    }
    .debug-actions-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: var(--space-3);
    }
    .debug-btn {
      background: var(--paper);
      border: 1px solid var(--ink);
      color: var(--ink);
      padding: var(--space-3);
      border-radius: var(--radius-md);
      cursor: pointer;
      font-size: var(--text-sm);
      font-family: var(--font-mono);
      transition: background var(--transition-fast), color var(--transition-fast);
      min-height: 44px;
    }
    .debug-btn:hover {
      background: var(--ink);
      color: var(--paper);
    }
    .debug-btn:active {
      background: var(--ink-light);
      color: var(--paper);
    }
    .debug-status {
      margin-top: var(--space-4);
      padding: var(--space-3);
      background: var(--paper-dark);
      border: 1px solid var(--muted);
      border-radius: var(--radius-md);
      color: var(--carbon-blue);
      text-align: center;
      min-height: var(--space-5);
    }
    .debug-footer {
      display: flex;
      gap: var(--space-3);
      margin-top: var(--space-5);
      padding-top: var(--space-4);
      border-top: 1px solid var(--muted);
    }
    .debug-footer .debug-btn {
      flex: 1;
      padding: var(--space-4);
      font-size: var(--text-md);
    }
    .debug-resume {
      background: var(--paper);
      border-color: var(--tier-uncommon);
      color: var(--tier-uncommon);
    }
    .debug-resume:hover {
      background: var(--tier-uncommon);
      color: var(--paper);
    }
    .debug-exit {
      background: var(--paper);
      border-color: var(--ribbon-red);
      color: var(--ribbon-red);
    }
    .debug-exit:hover {
      background: var(--ribbon-red);
      color: var(--paper);
    }

    /* Target enemy health bar */
    .target-info {
      position: fixed;
      top: var(--space-3);
      left: 50%;
      transform: translateX(-50%);
      background: var(--paper);
      border: 2px solid var(--ink);
      border-radius: var(--radius-md);
      padding: var(--space-3) var(--space-5);
      min-width: 280px;
      z-index: var(--z-target-info);
      display: none;
      box-shadow: var(--shadow-md);
      color: var(--ink);
    }
    .target-info.visible { display: block; }
    .target-header {
      display: flex;
      align-items: center;
      gap: var(--space-3);
      margin-bottom: var(--space-2);
    }
    .target-type {
      font-size: var(--text-md);
      font-weight: bold;
      color: var(--ink);
    }
    .target-modifiers {
      display: flex;
      gap: var(--space-1);
      flex-wrap: wrap;
    }
    .target-modifier {
      font-size: var(--text-xs);
      padding: var(--space-1) var(--space-2);
      border-radius: var(--radius-sm);
      font-weight: bold;
      text-transform: uppercase;
      letter-spacing: var(--tracking-tight);
    }
    .target-modifier.bold { background: var(--ink); color: var(--paper); }
    .target-modifier.italic { background: var(--carbon-blue); color: var(--paper); font-style: italic; }
    .target-modifier.underlined { background: var(--aged-yellow); color: var(--ink); text-decoration: underline; }
    .target-modifier.strikethrough { background: var(--ribbon-red); color: var(--paper); text-decoration: line-through; }
    .target-modifier.superscript { background: var(--tier-uncommon); color: var(--paper); font-size: 8px; vertical-align: super; }
    .target-modifier.subscript { background: var(--muted-dark); color: var(--paper); font-size: 8px; vertical-align: sub; }
    .target-modifier.highlighted { background: var(--aged-yellow); color: var(--ink); }
    .target-modifier.hyperlinked { background: var(--carbon-blue); color: var(--paper); text-decoration: underline; }
    .target-health-bar {
      height: 16px;
      background: var(--paper-dark);
      border-radius: var(--radius-sm);
      overflow: hidden;
      border: 1px solid var(--muted);
    }
    .target-health-fill {
      height: 100%;
      background: var(--ribbon-red);
      border-radius: var(--radius-sm);
      transition: width var(--transition-fast);
    }
    .target-health-text {
      position: absolute;
      width: 100%;
      text-align: center;
      font-size: var(--text-sm);
      color: var(--ink);
      text-shadow: 0 0 2px var(--paper);
      line-height: var(--space-4);
      top: 0;
      left: 0;
    }
    .target-health-container {
      position: relative;
    }

    /* Hover tooltip for practice mode */
    .debug-tooltip {
      position: fixed;
      background: var(--paper);
      border: 2px solid var(--ink);
      border-radius: var(--radius-md);
      padding: var(--space-3) var(--space-4);
      max-width: 280px;
      z-index: var(--z-tooltip);
      pointer-events: none;
      box-shadow: var(--shadow-md);
      opacity: 0;
      transition: opacity var(--transition-medium);
      color: var(--ink);
    }
    .debug-tooltip.visible {
      opacity: 1;
    }
    .debug-tooltip-title {
      color: var(--ink);
      font-weight: bold;
      font-size: var(--text-md);
      margin-bottom: var(--space-2);
    }
    .debug-tooltip-desc {
      color: var(--muted-dark);
      font-size: var(--text-sm);
      line-height: 1.4;
    }
    .debug-tooltip-meta {
      color: var(--muted);
      font-size: var(--text-sm);
      margin-top: var(--space-2);
      padding-top: var(--space-2);
      border-top: 1px solid var(--muted);
    }

    .menu {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      color: var(--ink);
      padding: var(--space-7);
      background: var(--paper);
      border: 2px solid var(--ink);
      border-radius: var(--radius-md);
      box-shadow: var(--shadow-md);
      min-width: 300px;
    }

    .menu h1 {
      font-size: clamp(32px, 8vw, 64px);
      font-family: var(--font-mono);
      font-weight: 700;
      margin-bottom: var(--space-3);
      color: var(--ink);
      text-transform: uppercase;
      letter-spacing: var(--tracking-wide);
    }

    .menu h2 {
      font-size: clamp(24px, 5vw, 36px);
      font-family: var(--font-mono);
      font-weight: 700;
      margin-bottom: var(--space-5);
      color: var(--ink);
      text-transform: uppercase;
      letter-spacing: var(--tracking-wide);
    }

    .menu p {
      font-size: var(--text-lg);
      margin-bottom: var(--space-6);
      color: var(--muted-dark);
    }

    .btn {
      background: var(--paper);
      border: 2px solid var(--ink);
      padding: var(--space-4) var(--space-7);
      font-size: var(--text-xl);
      font-family: var(--font-mono);
      font-weight: 700;
      color: var(--ink);
      cursor: pointer;
      margin: var(--space-3);
      border-radius: var(--radius-md);
      text-transform: uppercase;
      letter-spacing: var(--tracking-wide);
      transition: background var(--transition-fast), color var(--transition-fast);
    }

    .btn:hover {
      background: var(--ink);
      color: var(--paper);
    }

    .btn:active {
      background: var(--ink-light);
      color: var(--paper);
    }

    .btn-secondary {
      background: var(--paper);
      border: 2px solid var(--ink);
      color: var(--ink);
    }

    .btn-secondary:hover {
      background: var(--paper-dark);
    }

    .btn-secondary:active {
      background: var(--muted);
    }

    /* === LANDING PAGE STYLES === */
    .tagline {
      font-size: var(--text-lg);
      color: var(--muted-dark);
      margin-bottom: var(--space-6);
      letter-spacing: var(--tracking-widest);
      text-transform: uppercase;
    }

    .btn-play {
      font-size: var(--text-xl);
      padding: var(--space-5) var(--space-8);
      margin-bottom: var(--space-5);
    }

    .menu-secondary {
      display: flex;
      justify-content: center;
      gap: var(--space-5);
      margin-bottom: var(--space-5);
    }

    .btn-icon-circle {
      width: var(--icon-button-size);
      height: var(--icon-button-size);
      border-radius: var(--radius-md);
      background: var(--paper);
      border: 2px solid var(--ink);
      color: var(--ink);
      font-size: var(--text-xl);
      cursor: pointer;
      transition: background var(--transition-fast), color var(--transition-fast);
      display: flex;
      align-items: center;
      justify-content: center;
      font-family: var(--font-mono);
    }

    .btn-icon-circle:hover {
      background: var(--ink);
      color: var(--paper);
    }

    .btn-icon-circle:active {
      background: var(--ink-light);
      color: var(--paper);
    }

    .menu-hint {
      font-size: var(--text-md);
      color: var(--muted-dark);
      margin-top: var(--space-3);
    }

    .hint-icon {
      display: inline-block;
      width: var(--space-5);
      height: var(--space-5);
      line-height: var(--space-5);
      text-align: center;
      border: 1px solid var(--muted-dark);
      border-radius: var(--radius-md);
      font-size: var(--text-sm);
    }

    .mobile-notice {
      background: rgba(45, 74, 111, 0.1);
      border: 1px solid rgba(45, 74, 111, 0.3);
      border-radius: var(--radius-md);
      padding: var(--space-4) var(--space-5);
      margin: var(--space-3) 0;
    }

    .mobile-notice p {
      margin: 0;
      color: var(--carbon-blue);
      font-size: var(--text-md);
    }

    .mobile-notice-sub {
      margin-top: var(--space-2) !important;
      font-size: var(--text-base) !important;
      color: var(--muted-dark) !important;
    }

    .tips-toggle {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: var(--space-2);
      margin: var(--space-4) 0;
      cursor: pointer;
      user-select: none;
      min-height: 44px;
    }

    .tips-toggle input[type="checkbox"] {
      width: 24px;
      height: 24px;
      accent-color: var(--ink);
      cursor: pointer;
    }

    .tips-toggle-label {
      color: var(--muted-dark);
      font-size: var(--text-md);
    }

    .tips-toggle:hover .tips-toggle-label {
      color: var(--ink);
    }

    /* Modal Styles */
    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(26, 23, 20, 0.7);
      z-index: var(--z-modal-overlay);
      pointer-events: auto;
    }

    .modal {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: var(--paper);
      border: 2px solid var(--ink);
      border-radius: var(--radius-md);
      padding: var(--space-6);
      max-width: 90vw;
      max-height: 85vh;
      overflow-y: auto;
      z-index: var(--z-modal);
      color: var(--ink);
      box-shadow: var(--shadow-lg);
      pointer-events: auto;
    }

    .modal-large {
      width: var(--modal-max-width);
    }

    .modal h2 {
      text-align: center;
      font-size: var(--text-xl);
      font-family: var(--font-mono);
      font-weight: 700;
      margin-bottom: var(--space-5);
      color: var(--ink);
      text-transform: uppercase;
      letter-spacing: var(--tracking-wide);
    }

    .modal-close {
      position: absolute;
      top: var(--space-4);
      right: var(--space-4);
      width: 44px;
      height: 44px;
      min-width: 44px;
      min-height: 44px;
      border: 2px solid var(--ink);
      background: var(--paper);
      color: var(--ink);
      font-size: var(--text-xl);
      cursor: pointer;
      border-radius: var(--radius-md);
      transition: all var(--transition-medium);
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .modal-close:hover {
      background: var(--ribbon-red);
      border-color: var(--ribbon-red);
      color: var(--paper);
    }

    /* Mechanics Grid */
    .mechanics-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: var(--space-4);
    }

    .mechanic-card {
      background: var(--paper-dark);
      border: 1px solid var(--muted);
      border-radius: var(--radius-md);
      padding: var(--space-5) var(--space-4);
      text-align: center;
      transition: all var(--transition-slow);
    }

    .mechanic-card:hover {
      border-color: var(--ink);
      background: rgba(232, 220, 200, 0.5);
    }

    .mechanic-highlight {
      background: rgba(212, 168, 75, 0.15);
      border-color: var(--aged-yellow);
      box-shadow: 0 0 0 1px var(--aged-yellow);
    }

    .mechanic-highlight:hover {
      background: rgba(212, 168, 75, 0.25);
    }

    .mechanic-icon {
      font-size: var(--text-2xl);
      margin-bottom: var(--space-3);
    }

    .mechanic-card h3 {
      font-size: var(--text-md);
      color: var(--ink);
      margin-bottom: var(--space-2);
      text-transform: uppercase;
      letter-spacing: var(--tracking-normal);
    }

    .mechanic-highlight h3 {
      color: var(--ink);
    }

    .mechanic-card p {
      font-size: var(--text-sm);
      color: var(--muted-dark);
      line-height: 1.4;
      margin: 0;
    }

    /* Tab Navigation */
    .tab-nav {
      display: flex;
      justify-content: center;
      gap: var(--space-3);
      margin-bottom: var(--space-5);
    }

    .tab-btn {
      background: transparent;
      border: 1px solid var(--muted);
      color: var(--muted-dark);
      padding: var(--space-2) var(--space-5);
      font-size: var(--text-md);
      font-family: var(--font-mono);
      cursor: pointer;
      border-radius: var(--radius-sm);
      transition: background var(--transition-fast), color var(--transition-fast), border-color var(--transition-fast);
      text-transform: uppercase;
      letter-spacing: var(--tracking-wide);
      min-height: 44px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }

    .tab-btn:hover {
      color: var(--ink);
      border-color: var(--ink);
    }

    .tab-btn.active {
      background: var(--ink);
      border-color: var(--ink);
      color: var(--paper);
    }

    .tab-content {
      display: none;
    }

    .tab-content.active {
      display: block;
    }

    /* Tier Filter */
    .tier-filter {
      display: flex;
      justify-content: center;
      gap: var(--space-2);
      margin-bottom: var(--space-5);
      flex-wrap: wrap;
    }

    .tier-btn {
      background: var(--paper);
      border: 1px solid var(--muted);
      color: var(--muted-dark);
      padding: var(--space-2) var(--space-4);
      font-size: var(--text-sm);
      font-family: var(--font-mono);
      cursor: pointer;
      border-radius: var(--radius-md);
      min-height: 44px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      transition: all var(--transition-slow);
      text-transform: uppercase;
      letter-spacing: var(--tracking-normal);
    }

    .tier-btn:hover {
      border-color: var(--ink);
      color: var(--ink);
    }

    .tier-btn.active {
      border-color: var(--ink);
      color: var(--ink);
      background: var(--paper-dark);
    }

    .tier-btn[data-tier="WHITE"].active { border-color: var(--tier-common-border); color: var(--tier-common); }
    .tier-btn[data-tier="GREEN"].active { border-color: var(--tier-uncommon-border); color: var(--tier-uncommon); }
    .tier-btn[data-tier="RED"].active { border-color: var(--tier-rare-border); color: var(--tier-rare); }
    .tier-btn[data-tier="LEGENDARY"].active { border-color: var(--tier-legendary-border); color: var(--tier-legendary); }

    /* Items List */
    .items-list, .upgrades-list {
      display: grid;
      gap: var(--space-3);
      max-height: 400px;
      overflow-y: auto;
      padding-right: var(--space-3);
    }

    .item-entry, .upgrade-entry {
      display: flex;
      align-items: center;
      gap: var(--space-4);
      background: var(--paper-dark);
      border: 1px solid var(--muted);
      border-radius: var(--radius-md);
      padding: var(--space-3) var(--space-4);
      transition: all var(--transition-slow);
    }

    .item-entry:hover, .upgrade-entry:hover {
      border-color: var(--ink);
      background: rgba(232, 220, 200, 0.5);
    }

    .item-entry .item-icon-wrap {
      width: var(--item-slot-size);
      height: var(--item-slot-size);
      border-radius: var(--radius-lg);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: var(--text-xl);
      flex-shrink: 0;
      border: 2px solid;
      background: var(--paper);
    }

    .item-entry[data-tier="WHITE"] .item-icon-wrap { border-color: var(--tier-common-border); color: var(--tier-common); }
    .item-entry[data-tier="GREEN"] .item-icon-wrap { border-color: var(--tier-uncommon-border); color: var(--tier-uncommon); }
    .item-entry[data-tier="RED"] .item-icon-wrap { border-color: var(--tier-rare-border); color: var(--tier-rare); }
    .item-entry[data-tier="LEGENDARY"] .item-icon-wrap { border-color: var(--tier-legendary-border); color: var(--tier-legendary); }

    .item-entry .item-info {
      flex: 1;
      min-width: 0;
    }

    .item-entry .item-name {
      font-size: var(--text-md);
      font-weight: bold;
      margin-bottom: var(--space-1);
    }

    .item-entry[data-tier="WHITE"] .item-name { color: var(--tier-common); }
    .item-entry[data-tier="GREEN"] .item-name { color: var(--tier-uncommon); }
    .item-entry[data-tier="RED"] .item-name { color: var(--tier-rare); }
    .item-entry[data-tier="LEGENDARY"] .item-name { color: var(--tier-legendary); }

    .item-entry .item-desc {
      font-size: var(--text-sm);
      color: var(--muted-dark);
      line-height: 1.3;
    }

    .upgrade-entry .upgrade-icon {
      width: var(--item-slot-size);
      height: var(--item-slot-size);
      border-radius: var(--radius-lg);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: var(--text-lg);
      flex-shrink: 0;
      background: var(--paper);
      border: 2px solid var(--carbon-blue);
      color: var(--carbon-blue);
    }

    .upgrade-entry .upgrade-info {
      flex: 1;
    }

    .upgrade-entry .upgrade-name {
      font-size: var(--text-md);
      font-weight: bold;
      color: var(--carbon-blue);
      margin-bottom: var(--space-1);
    }

    .upgrade-entry .upgrade-desc {
      font-size: var(--text-sm);
      color: var(--muted-dark);
    }

    /* Mobile Responsive */
    @media (max-width: 700px) {
      .modal-large {
        width: 95vw;
      }

      .mechanics-grid {
        grid-template-columns: repeat(2, 1fr);
        gap: var(--space-3);
      }

      .mechanic-card {
        padding: var(--space-4) var(--space-3);
      }

      .mechanic-icon {
        font-size: var(--text-xl);
      }

      .mechanic-card h3 {
        font-size: var(--text-sm);
      }

      .mechanic-card p {
        font-size: var(--text-sm);
      }

      .tier-filter {
        gap: var(--space-1);
      }

      .tier-btn {
        padding: var(--space-1) var(--space-3);
        font-size: var(--text-sm);
      }

      .items-list, .upgrades-list {
        max-height: 300px;
      }

      .item-entry .item-icon-wrap,
      .upgrade-entry .upgrade-icon {
        width: 36px;
        height: 36px;
        font-size: var(--text-lg);
      }

      .item-entry .item-name,
      .upgrade-entry .upgrade-name {
        font-size: var(--text-base);
      }

      .item-entry .item-desc,
      .upgrade-entry .upgrade-desc {
        font-size: var(--text-sm);
      }
    }

    @media (max-width: 480px) {
      .mechanics-grid {
        grid-template-columns: 1fr;
      }

      .menu-secondary {
        gap: var(--space-4);
      }

      .btn-icon-circle {
        width: var(--item-slot-size);
        height: var(--item-slot-size);
        font-size: var(--text-xl);
      }

      .tagline {
        font-size: var(--text-md);
        letter-spacing: var(--tracking-tight);
      }

      .btn-play {
        font-size: var(--text-xl);
        padding: var(--space-4) var(--space-7);
      }

      .tab-btn {
        padding: var(--space-2) var(--space-4);
        font-size: var(--text-md);
      }
    }

    /* Scrollbar styling for modals - Underwood themed */
    .items-list::-webkit-scrollbar,
    .upgrades-list::-webkit-scrollbar,
    .enemies-list::-webkit-scrollbar,
    .modal::-webkit-scrollbar,
    .debug-panel::-webkit-scrollbar {
      width: var(--space-2);
    }

    .items-list::-webkit-scrollbar-track,
    .upgrades-list::-webkit-scrollbar-track,
    .enemies-list::-webkit-scrollbar-track,
    .modal::-webkit-scrollbar-track,
    .debug-panel::-webkit-scrollbar-track {
      background: var(--paper-dark);
      border-radius: var(--radius-sm);
    }

    .items-list::-webkit-scrollbar-thumb,
    .upgrades-list::-webkit-scrollbar-thumb,
    .enemies-list::-webkit-scrollbar-thumb,
    .modal::-webkit-scrollbar-thumb,
    .debug-panel::-webkit-scrollbar-thumb {
      background: var(--muted);
      border-radius: var(--radius-sm);
      border: 1px solid var(--paper-dark);
    }

    .items-list::-webkit-scrollbar-thumb:hover,
    .upgrades-list::-webkit-scrollbar-thumb:hover,
    .enemies-list::-webkit-scrollbar-thumb:hover,
    .modal::-webkit-scrollbar-thumb:hover,
    .debug-panel::-webkit-scrollbar-thumb:hover {
      background: var(--ink-light);
    }

    /* Letter stamp animation for typed characters */
    @keyframes letter-stamp {
      0% {
        opacity: 0;
        transform: translateY(-8px);
        filter: blur(2px);
      }
      100% {
        opacity: 1;
        transform: translateY(0);
        filter: blur(0);
      }
    }

    .letter-stamp {
      animation: letter-stamp 0.08s ease-out forwards;
    }

    /* Key press animation */
    @keyframes key-press {
      0% { transform: translateY(0); }
      50% { transform: translateY(3px); }
      100% { transform: translateY(0); }
    }

    .key-press {
      animation: key-press 0.15s ease-out;
    }

    /* === TIP MODAL STYLES === */
    .tip-modal {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: var(--paper);
      border: 2px solid var(--ink);
      border-radius: var(--radius-md);
      padding: var(--space-6);
      max-width: var(--modal-max-width-sm);
      width: 90vw;
      z-index: var(--z-tip-modal);
      color: var(--ink);
      box-shadow: var(--shadow-lg);
      animation: tipFadeIn var(--duration-slow) ease-out;
    }

    @keyframes tipFadeIn {
      0% { opacity: 0; transform: translate(-50%, -50%) scale(0.95); }
      100% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
    }

    .tip-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(26, 23, 20, 0.8);
      z-index: var(--z-tip-overlay);
    }

    .tip-narrator {
      text-align: center;
      margin-bottom: var(--space-5);
      padding-bottom: var(--space-5);
      border-bottom: 1px solid var(--muted);
    }

    .tip-narrator-icon {
      font-size: var(--text-2xl);
      margin-bottom: var(--space-3);
    }

    .tip-narrator-quote {
      font-style: italic;
      color: var(--muted-dark);
      font-size: var(--text-md);
      line-height: 1.5;
    }

    .tip-practical {
      background: var(--paper-dark);
      border: 1px solid var(--muted);
      border-radius: var(--radius-md);
      padding: var(--space-4) var(--space-5);
    }

    .tip-practical-title {
      color: var(--carbon-blue);
      font-size: var(--text-lg);
      font-weight: bold;
      margin-bottom: var(--space-2);
    }

    .tip-practical-text {
      color: var(--ink);
      font-size: var(--text-md);
      line-height: 1.5;
    }

    .tip-item-showcase {
      display: flex;
      align-items: center;
      gap: var(--space-4);
      background: var(--paper-dark);
      border: 1px solid var(--muted);
      border-radius: var(--radius-md);
      padding: var(--space-4);
      margin-bottom: var(--space-4);
    }

    .tip-item-icon {
      width: var(--space-7);
      height: var(--space-7);
      border-radius: var(--radius-lg);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: var(--text-xl);
      flex-shrink: 0;
      border: 2px solid;
      background: var(--paper);
    }

    .tip-item-info {
      flex: 1;
    }

    .tip-item-tier {
      font-size: var(--text-xs);
      text-transform: uppercase;
      letter-spacing: var(--tracking-wide);
      margin-bottom: var(--space-1);
    }

    .tip-item-name {
      font-size: var(--text-lg);
      font-weight: bold;
      margin-bottom: var(--space-1);
    }

    .tip-item-desc {
      font-size: var(--text-sm);
      color: var(--muted-dark);
      line-height: 1.3;
    }

    .tip-dismiss {
      display: block;
      width: 100%;
      margin-top: var(--space-5);
      padding: var(--space-3);
      background: var(--paper);
      border: 2px solid var(--ink);
      border-radius: var(--radius-md);
      color: var(--ink);
      font-family: var(--font-mono);
      font-size: var(--text-md);
      font-weight: 700;
      cursor: pointer;
      transition: background var(--transition-fast), color var(--transition-fast);
      text-transform: uppercase;
      letter-spacing: var(--tracking-wide);
    }

    .tip-dismiss:hover {
      background: var(--ink);
      color: var(--paper);
    }

    .tip-dismiss:active {
      background: var(--ink-light);
      color: var(--paper);
    }

    @media (max-width: 480px) {
      .tip-modal {
        padding: var(--space-5);
        max-width: 95vw;
      }

      .tip-narrator-quote {
        font-size: var(--text-md);
      }

      .tip-practical-title {
        font-size: var(--text-md);
      }

      .tip-practical-text {
        font-size: var(--text-base);
      }

      .tip-item-icon {
        width: var(--space-7);
        height: var(--space-7);
        font-size: var(--text-xl);
      }

      .tip-item-name {
        font-size: var(--text-md);
      }
    }

    /* Mob Tips - Non-blocking mini tips in corner */
    .mob-tip {
      position: fixed;
      top: var(--space-5);
      right: var(--space-5);
      width: 280px;
      background: var(--paper);
      border: 2px solid var(--ink);
      border-radius: var(--radius-md);
      padding: var(--space-4);
      z-index: var(--z-mob-tip);
      animation: mobTipSlideIn var(--duration-slow) ease-out;
      box-shadow: var(--shadow-md);
      color: var(--ink);
    }

    @keyframes mobTipSlideIn {
      from { opacity: 0; transform: translateX(100px); }
      to { opacity: 1; transform: translateX(0); }
    }

    .mob-tip.fading {
      animation: mobTipSlideOut var(--duration-slow) ease-in forwards;
    }

    @keyframes mobTipSlideOut {
      from { opacity: 1; transform: translateX(0); }
      to { opacity: 0; transform: translateX(100px); }
    }

    .mob-tip-header {
      display: flex;
      align-items: center;
      gap: var(--space-3);
      margin-bottom: var(--space-3);
    }

    .mob-tip-icon {
      width: var(--space-6);
      height: var(--space-6);
      border-radius: var(--radius-lg);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: var(--text-md);
      font-weight: bold;
      border: 2px solid;
      flex-shrink: 0;
      background: var(--paper-dark);
    }

    .mob-tip-name {
      font-size: var(--text-md);
      font-weight: bold;
      color: var(--ink);
    }

    .mob-tip-dismiss {
      position: absolute;
      top: var(--space-2);
      right: var(--space-2);
      background: none;
      border: none;
      color: var(--muted);
      font-size: var(--text-md);
      cursor: pointer;
      min-width: 44px;
      min-height: 44px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .mob-tip-dismiss:hover {
      color: var(--ink);
    }

    .mob-tip-description {
      color: var(--muted-dark);
      font-size: var(--text-base);
      line-height: 1.4;
    }

    @media (max-width: 480px) {
      .mob-tip {
        width: 240px;
        top: var(--space-3);
        right: var(--space-3);
        padding: var(--space-3);
      }
    }

    /* Enemies List in Collection */
    .enemies-list {
      display: grid;
      gap: var(--space-3);
      max-height: 400px;
      overflow-y: auto;
      padding-right: var(--space-3);
    }

    .enemy-entry {
      display: flex;
      align-items: center;
      gap: var(--space-4);
      background: var(--paper-dark);
      border: 1px solid var(--muted);
      border-radius: var(--radius-md);
      padding: var(--space-3) var(--space-4);
      transition: all var(--transition-slow);
    }

    .enemy-entry:hover {
      border-color: var(--ink);
      background: rgba(232, 220, 200, 0.5);
    }

    .enemy-icon-wrap {
      width: 40px;
      height: 40px;
      border-radius: var(--radius-lg);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: var(--text-lg);
      font-weight: bold;
      flex-shrink: 0;
      border: 2px solid;
      background: var(--paper);
    }

    .enemy-info {
      flex: 1;
      min-width: 0;
    }

    .enemy-name {
      font-size: var(--text-md);
      font-weight: bold;
      color: var(--ink);
      margin-bottom: var(--space-1);
    }

    .enemy-desc {
      font-size: var(--text-sm);
      color: var(--muted-dark);
      line-height: 1.3;
    }

    .enemy-meta {
      display: flex;
      gap: var(--space-2);
      margin-top: var(--space-2);
      flex-wrap: wrap;
    }

    .enemy-stat {
      font-size: var(--text-xs);
      padding: var(--space-1) var(--space-2);
      background: var(--paper);
      border: 1px solid var(--carbon-blue);
      border-radius: var(--radius-sm);
      color: var(--carbon-blue);
    }

    .wave-category-header {
      font-size: var(--text-sm);
      text-transform: uppercase;
      letter-spacing: var(--tracking-wide);
      color: var(--muted-dark);
      margin: var(--space-4) 0 var(--space-3) 0;
      padding-bottom: var(--space-1);
      border-bottom: 1px solid var(--muted);
    }

    .wave-category-header:first-child {
      margin-top: 0;
    }

    .stats {
      position: absolute;
      top: env(safe-area-inset-top, 10px);
      left: var(--space-3);
      color: var(--ink);
      font-size: clamp(14px, 3vw, 18px);
      font-family: var(--font-mono);
      text-shadow: 1px 1px 0 var(--paper);
      line-height: 1.6;
      text-transform: uppercase;
      letter-spacing: var(--tracking-normal);
    }

    .combo {
      position: absolute;
      top: calc(env(safe-area-inset-top, 10px) + 50px);
      right: var(--space-3);
      color: var(--ribbon-red);
      font-size: clamp(18px, 4vw, 28px);
      font-family: var(--font-mono);
      font-weight: 700;
      text-shadow: 1px 1px 0 var(--paper), -1px -1px 0 var(--paper);
      transform: rotate(-2deg);
      z-index: 10;
    }

    /* Health Bar - Ink Ribbon Style */
    .health-bar {
      position: absolute;
      bottom: 5%;
      left: 50%;
      transform: translateX(-50%);
      width: 200px;
      height: 12px;
      background: var(--ink-light);
      border: 2px solid var(--ink);
      border-radius: var(--radius-sm);
      overflow: hidden;
    }

    .health-bar-fill {
      height: 100%;
      background: linear-gradient(90deg, var(--ribbon-red), var(--ribbon-red-light));
      background-image: repeating-linear-gradient(
        90deg,
        transparent,
        transparent 2px,
        rgba(0,0,0,0.15) 2px,
        rgba(0,0,0,0.15) 4px
      );
      transition: width var(--transition-slow);
    }

    /* XP Bar - Paper Roll Style */
    .xp-bar {
      position: absolute;
      bottom: 2%;
      left: 50%;
      transform: translateX(-50%);
      width: 200px;
      height: 12px;
      background: var(--paper-dark);
      border: 1px solid var(--muted);
      border-radius: var(--radius-sm);
      overflow: hidden;
    }

    .xp-bar-fill {
      height: 100%;
      background: var(--carbon-blue);
      transition: width var(--transition-slow);
    }

    .active-items, .passive-items {
      position: absolute;
      bottom: 3%;
      display: flex;
      gap: var(--space-2);
      z-index: var(--z-hud);
    }

    .active-items {
      right: calc(50% + 120px);
      pointer-events: auto;
    }

    .passive-items {
      left: calc(50% + 120px);
      pointer-events: auto;
    }

    .item-slot {
      width: var(--item-slot-size);
      height: var(--item-slot-size);
      background: var(--paper);
      border: 2px solid var(--ink);
      border-radius: var(--radius-md);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      position: relative;
      font-size: var(--text-lg);
      color: var(--ink);
      transition: background var(--transition-fast);
    }

    .item-slot.active-slot {
      cursor: pointer;
      pointer-events: auto;
    }

    .item-slot.active-slot:hover {
      background: var(--paper-dark);
    }

    .item-slot.active-slot:active {
      background: var(--muted);
    }

    .item-slot.passive-slot {
      /* Border color set dynamically by tier */
    }

    .item-slot.ready {
      border-color: var(--aged-yellow);
    }

    .item-slot.on-cooldown {
      opacity: 0.6;
      filter: grayscale(40%);
    }

    /* Tier-specific border colors */
    .item-slot[data-tier="WHITE"] { border-color: var(--muted); }
    .item-slot[data-tier="GREEN"] { border-color: var(--tier-uncommon-border); }
    .item-slot[data-tier="RED"] { border-color: var(--ribbon-red); }
    .item-slot[data-tier="LEGENDARY"] {
      border-color: var(--aged-yellow);
      border-width: 3px;
    }

    .item-slot .key-hint {
      position: absolute;
      bottom: -2px;
      font-size: var(--text-xs);
      color: var(--muted);
      background: var(--ink);
      padding: 1px 3px;
      border-radius: var(--radius-sm);
    }

    .item-slot .cooldown-overlay {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(26, 23, 20, 0.8);
      color: var(--paper);
      font-size: var(--text-xs);
      text-align: center;
      border-radius: 0 0 var(--radius-md) var(--radius-md);
    }

    .item-slot .uses-left {
      position: absolute;
      top: var(--space-1);
      right: var(--space-1);
      font-size: var(--text-xs);
      color: var(--aged-yellow-dark);
    }

    .item-slot.counter-slot {
      overflow: hidden;
    }

    .item-slot.counter-slot.almost-ready {
      border-color: var(--aged-yellow);
    }

    .item-slot .counter-display {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(26, 23, 20, 0.9);
      color: var(--carbon-blue);
      font-size: var(--text-xs);
      text-align: center;
      border-radius: 0 0 var(--radius-md) var(--radius-md);
      font-weight: bold;
    }

    .item-slot .counter-progress {
      position: absolute;
      bottom: 0;
      left: 0;
      height: 3px;
      background: var(--carbon-blue);
      border-radius: 0 0 0 var(--radius-sm);
      transition: width var(--transition-medium);
    }

    /* Cooldown progress ring */
    .item-slot .cooldown-ring {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
    }

    .item-slot .cooldown-ring svg {
      width: 100%;
      height: 100%;
      transform: rotate(-90deg);
    }

    .item-slot .cooldown-ring circle {
      fill: none;
      stroke: var(--aged-yellow);
      stroke-width: 3;
      stroke-dasharray: 126;
      stroke-dashoffset: 126;
      transition: stroke-dashoffset 0.1s linear;
    }

    .item-slot .cooldown-text {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(26, 23, 20, 0.85);
      color: var(--paper);
      font-size: var(--text-xs);
      text-align: center;
      border-radius: 0 0 var(--radius-md) var(--radius-md);
      font-weight: bold;
      font-family: var(--font-mono);
    }

    /* Stack badge on HUD item slots */
    .item-slot .stack-badge {
      position: absolute;
      top: -4px;
      right: -4px;
      background: var(--ink);
      color: var(--paper);
      font-size: var(--text-xs);
      font-weight: bold;
      font-family: var(--font-mono);
      min-width: 16px;
      height: 16px;
      line-height: 16px;
      text-align: center;
      border-radius: 8px;
      padding: 0 3px;
      z-index: 1;
    }

    /* White Space time-stop indicator */
    .white-space-indicator {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: clamp(20px, 4vw, 36px);
      font-family: var(--font-mono);
      font-weight: 700;
      color: var(--aged-yellow);
      text-transform: uppercase;
      letter-spacing: var(--tracking-widest);
      opacity: 0.4;
      pointer-events: none;
      z-index: var(--z-word-display);
      text-shadow: 2px 2px 0 rgba(26, 23, 20, 0.1);
      transition: opacity 0.15s ease;
    }

    /* Item Hover Tooltip */
    .item-hover-tooltip {
      position: fixed;
      background: var(--paper);
      border: 2px solid var(--ink);
      border-radius: var(--radius-md);
      padding: var(--space-3) var(--space-4);
      max-width: 240px;
      z-index: var(--z-debug-panel);
      pointer-events: none;
      opacity: 0;
      transition: opacity var(--transition-medium);
      box-shadow: var(--shadow-md);
      color: var(--ink);
    }

    .item-hover-tooltip.visible {
      opacity: 1;
    }

    .item-hover-tooltip-name {
      font-weight: bold;
      font-size: var(--text-md);
      margin-bottom: var(--space-2);
    }

    .item-hover-tooltip-desc {
      color: var(--muted-dark);
      font-size: var(--text-sm);
      line-height: 1.4;
    }

    .item-hover-tooltip-meta {
      color: var(--muted);
      font-size: var(--text-sm);
      margin-top: var(--space-2);
      font-style: italic;
    }

    .upgrade-container {
      display: flex;
      flex-direction: column;
      gap: var(--space-4);
      margin-top: var(--space-5);
    }

    .upgrade-btn {
      background: var(--paper-dark);
      border: 2px solid var(--carbon-blue);
      padding: var(--space-5);
      border-radius: var(--radius-md);
      cursor: pointer;
      transition: background var(--transition-fast), border-color var(--transition-fast);
      text-align: left;
    }

    .upgrade-btn:hover {
      border-color: var(--ink);
      background: var(--paper);
    }

    .upgrade-btn:active {
      background: var(--muted);
    }

    .upgrade-btn h3 {
      color: var(--carbon-blue);
      font-size: var(--text-lg);
      margin-bottom: var(--space-1);
    }

    .upgrade-btn p {
      color: var(--ink);
      font-size: var(--text-md);
      margin: 0;
      opacity: 0.8;
    }

    /* Item Selection Menu */
    .item-select-container {
      display: flex;
      flex-direction: column;
      gap: var(--space-4);
      margin-top: var(--space-5);
    }

    .item-select-btn {
      background: var(--paper-dark);
      border: 2px solid var(--muted);
      padding: var(--space-5);
      border-radius: var(--radius-md);
      cursor: pointer;
      transition: background var(--transition-fast), border-color var(--transition-fast);
      text-align: left;
      display: flex;
      align-items: center;
      gap: var(--space-4);
    }

    .item-select-btn:hover {
      background: var(--paper);
      border-color: var(--ink);
    }

    .item-select-btn:active {
      background: var(--muted);
    }

    .item-select-btn.tier-white { border-color: var(--tier-common-border); }
    .item-select-btn.tier-green { border-color: var(--tier-uncommon-border); }
    .item-select-btn.tier-red { border-color: var(--tier-rare-border); }
    .item-select-btn.tier-legendary { border-color: var(--tier-legendary-border); }

    .item-select-btn.tier-white:hover { border-color: var(--tier-common); }
    .item-select-btn.tier-green:hover { border-color: var(--tier-uncommon); }
    .item-select-btn.tier-red:hover { border-color: var(--tier-rare); }
    .item-select-btn.tier-legendary:hover { border-color: var(--tier-legendary); }

    .item-select-icon {
      font-size: var(--text-2xl);
      width: var(--space-8);
      height: var(--space-8);
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: var(--radius-lg);
      background: var(--paper);
      flex-shrink: 0;
      border: 2px solid var(--muted);
    }

    .item-select-info {
      flex: 1;
    }

    .item-select-header {
      display: flex;
      align-items: center;
      gap: var(--space-3);
      margin-bottom: var(--space-2);
    }

    .item-select-info h3 {
      font-size: var(--text-lg);
      margin: 0;
    }

    .item-select-btn.tier-white .item-select-info h3 { color: var(--tier-common); }
    .item-select-btn.tier-green .item-select-info h3 { color: var(--tier-uncommon); }
    .item-select-btn.tier-red .item-select-info h3 { color: var(--tier-rare); }
    .item-select-btn.tier-legendary .item-select-info h3 { color: var(--tier-legendary); }

    .item-select-tier-badge {
      font-size: var(--text-xs);
      text-transform: uppercase;
      padding: var(--space-1) var(--space-2);
      border-radius: var(--radius-sm);
      font-weight: bold;
      letter-spacing: var(--tracking-normal);
    }

    .item-select-btn.tier-white .item-select-tier-badge { background: var(--tier-common-border); color: var(--paper); }
    .item-select-btn.tier-green .item-select-tier-badge { background: var(--tier-uncommon-border); color: var(--paper); }
    .item-select-btn.tier-red .item-select-tier-badge { background: var(--tier-rare-border); color: var(--paper); }
    .item-select-btn.tier-legendary .item-select-tier-badge { background: var(--tier-legendary-border); color: var(--ink); }

    .item-select-description {
      color: var(--ink);
      font-size: var(--text-base);
      margin: 0 0 var(--space-2) 0;
      line-height: 1.4;
    }

    .item-select-stack-effect {
      color: var(--tier-uncommon);
      font-size: var(--text-sm);
      margin: 0;
      font-style: italic;
    }

    .item-select-stack-count {
      color: var(--aged-yellow-dark);
      font-size: var(--text-sm);
      margin-top: var(--space-1);
    }

    .final-stats {
      text-align: left;
      margin: var(--space-5) 0;
      padding: var(--space-5);
      background: var(--paper-dark);
      border: 1px solid var(--muted);
      border-radius: var(--radius-md);
    }

    .final-stats div {
      display: flex;
      justify-content: space-between;
      margin: var(--space-3) 0;
      font-size: var(--text-lg);
    }

    .final-stats .label {
      color: var(--muted-dark);
    }

    .final-stats .value {
      color: var(--carbon-blue);
      font-weight: bold;
    }

    .share-result {
      font-family: var(--font-mono);
      white-space: pre-line;
      background: var(--paper-dark);
      border: 1px solid var(--muted);
      padding: var(--space-4);
      border-radius: var(--radius-md);
      margin: var(--space-4) 0;
      font-size: var(--text-md);
      line-height: 1.4;
      color: var(--ink);
    }

    .hidden {
      display: none !important;
    }

    /* Item System Styles */
    .item-notification {
      position: fixed;
      top: 18%;
      left: 50%;
      transform: translateX(-50%) scale(0);
      padding: var(--space-5) var(--space-7) var(--space-5);
      background: var(--paper);
      border: 2px solid var(--ink);
      border-radius: var(--radius-md);
      text-align: center;
      z-index: var(--z-modal-overlay);
      animation: itemPopIn var(--duration-slow) ease-out forwards;
      pointer-events: none;
      min-width: 280px;
      box-shadow: var(--shadow-lg);
      color: var(--ink);
    }

    .item-notification.fade-out {
      animation: itemPopOut var(--duration-slow) ease-in forwards;
    }

    .item-notification .item-icon {
      font-size: var(--space-7);
      margin-bottom: var(--space-2);
    }

    .item-notification .tier-badge {
      display: inline-block;
      font-size: var(--text-xs);
      text-transform: uppercase;
      letter-spacing: var(--tracking-wider);
      padding: var(--space-1) var(--space-3);
      border-radius: var(--radius-sm);
      margin-bottom: var(--space-2);
      font-weight: bold;
    }

    .item-notification h3 {
      font-size: var(--text-xl);
      margin-bottom: var(--space-3);
      text-transform: uppercase;
      letter-spacing: var(--tracking-wide);
      color: var(--ink);
    }

    .item-notification .description {
      font-size: var(--text-md);
      color: var(--ink);
      opacity: 0.85;
      margin: 0 0 var(--space-2) 0;
      line-height: 1.4;
    }

    .item-notification .stack-effect {
      font-size: var(--text-base);
      color: var(--carbon-blue);
      margin: var(--space-2) 0 0 0;
      padding-top: var(--space-2);
      border-top: 1px solid var(--muted);
    }

    .item-notification .stack-count {
      font-size: var(--text-md);
      margin-top: var(--space-3);
      color: var(--carbon-blue);
      font-weight: bold;
    }

    .item-notification .key-hint-text {
      font-size: var(--text-sm);
      margin-top: var(--space-4);
      color: var(--muted-dark);
      font-style: italic;
      animation: pulse 1.5s ease-in-out infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 0.5; }
      50% { opacity: 1; }
    }

    .synergy-notification {
      position: fixed;
      top: 35%;
      left: 50%;
      transform: translateX(-50%) scale(0);
      padding: var(--space-5) var(--space-7);
      background: var(--paper);
      border: 3px solid var(--aged-yellow);
      border-radius: var(--radius-md);
      text-align: center;
      z-index: var(--z-modal);
      animation: synergyPopIn 0.5s ease-out forwards;
      pointer-events: none;
      box-shadow: var(--shadow-lg);
    }

    .synergy-notification h2 {
      font-size: var(--text-2xl);
      color: var(--aged-yellow);
      margin-bottom: var(--space-3);
      text-transform: uppercase;
      letter-spacing: var(--tracking-wide);
    }

    .synergy-notification p {
      font-size: var(--text-lg);
      color: var(--ink);
    }

    .inventory-display {
      position: absolute;
      top: env(safe-area-inset-top, 10px);
      right: var(--space-3);
      display: flex;
      flex-wrap: wrap;
      gap: var(--space-1);
      max-width: 200px;
      justify-content: flex-end;
    }

    .inventory-item {
      width: 36px;
      height: 36px;
      border-radius: var(--radius-lg);
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
      font-size: var(--text-md);
      position: relative;
      border: 2px solid;
      cursor: default;
      background: var(--paper);
    }

    .inventory-item .stack {
      position: absolute;
      bottom: -2px;
      right: -2px;
      background: var(--ink);
      color: var(--paper);
      font-size: var(--text-xs);
      padding: 1px var(--space-1);
      border-radius: var(--radius-sm);
      min-width: 14px;
      text-align: center;
    }

    .inventory-item:hover .tooltip {
      display: block;
    }

    .inventory-item .tooltip {
      display: none;
      position: absolute;
      right: 100%;
      top: 50%;
      transform: translateY(-50%);
      background: var(--paper);
      border: 2px solid var(--ink);
      padding: var(--space-2) var(--space-3);
      border-radius: var(--radius-md);
      white-space: nowrap;
      margin-right: var(--space-3);
      z-index: var(--z-word-display);
      pointer-events: none;
      box-shadow: var(--shadow-md);
      color: var(--ink);
    }

    .inventory-item .tooltip h4 {
      margin: 0 0 var(--space-1) 0;
      font-size: var(--text-md);
    }

    .inventory-item .tooltip p {
      margin: 0;
      font-size: var(--text-sm);
      color: var(--muted-dark);
    }

    @keyframes itemPopIn {
      0% { transform: translateX(-50%) scale(0); opacity: 0; }
      50% { transform: translateX(-50%) scale(1.1); }
      100% { transform: translateX(-50%) scale(1); opacity: 1; }
    }

    @keyframes itemPopOut {
      0% { transform: translateX(-50%) scale(1); opacity: 1; }
      100% { transform: translateX(-50%) scale(0); opacity: 0; }
    }

    @keyframes synergyPopIn {
      0% { transform: translateX(-50%) scale(0) rotate(-10deg); opacity: 0; }
      50% { transform: translateX(-50%) scale(1.2) rotate(5deg); }
      100% { transform: translateX(-50%) scale(1) rotate(0deg); opacity: 1; }
    }

    /* === PENDING ITEMS WIDGET === */
    .pending-items-widget {
      position: absolute;
      top: calc(env(safe-area-inset-top, 10px) + 100px);
      left: var(--space-3);
      background: var(--paper);
      border: 2px solid var(--aged-yellow);
      border-radius: var(--radius-md);
      padding: var(--space-2) var(--space-3);
      display: flex;
      align-items: center;
      gap: var(--space-2);
      cursor: pointer;
      z-index: var(--z-hud);
      box-shadow: var(--shadow-md);
      transition: box-shadow var(--transition-medium), border-color var(--transition-medium);
      min-height: 44px;
    }

    .pending-items-widget:hover {
      border-color: var(--ink);
    }

    .pending-items-widget.has-items {
      animation: widget-pulse 2s infinite;
    }

    @keyframes widget-pulse {
      0%, 100% { box-shadow: var(--shadow-md); }
      50% { box-shadow: 0 0 15px var(--aged-yellow); }
    }

    .pending-items-icon {
      font-size: var(--text-lg);
    }

    .pending-items-count {
      font-weight: bold;
      font-size: var(--text-base);
      color: var(--aged-yellow-dark);
    }

    .pending-items-hint {
      font-size: var(--text-xs);
      color: var(--muted);
    }

    /* === COLLECTION MENU === */
    #collectionMenu {
      max-width: 90vw;
      width: 650px;
      max-height: 80vh;
      overflow-y: auto;
    }

    @media (max-width: 700px) {
      #collectionMenu {
        width: 95vw;
        padding: var(--space-4);
      }
    }

    .collection-list {
      max-height: 400px;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: var(--space-3);
      margin: var(--space-4) 0;
      padding: var(--space-2);
    }

    .collection-item {
      display: flex;
      align-items: center;
      gap: var(--space-3);
      padding: var(--space-3);
      background: var(--paper);
      border: 2px solid;
      border-radius: var(--radius-md);
      text-align: left;
    }

    .collection-item-icon {
      width: 48px;
      height: 48px;
      min-width: 48px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: var(--radius-md);
      font-size: 24px;
    }

    .collection-item-icon [data-lucide] {
      width: 28px;
      height: 28px;
    }

    .collection-item-info {
      flex: 1;
      min-width: 0;
    }

    .collection-item-name {
      font-weight: bold;
      margin-bottom: var(--space-1);
      font-size: var(--text-md);
    }

    .collection-item-desc {
      font-size: var(--text-sm);
      color: var(--muted-dark);
      line-height: 1.3;
    }

    .collection-item-tier {
      font-size: var(--text-xs);
      margin-top: var(--space-1);
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: var(--tracking-normal);
    }

    .synergy-badge {
      display: inline-block;
      background: var(--aged-yellow);
      color: var(--ink);
      padding: 2px 6px;
      border-radius: var(--radius-sm);
      font-size: var(--text-xs);
      margin-left: var(--space-2);
      font-weight: bold;
    }

    .new-badge {
      color: var(--aged-yellow-dark);
      font-weight: bold;
      margin-left: var(--space-1);
    }

    .collection-actions {
      display: flex;
      gap: var(--space-3);
      justify-content: center;
      flex-wrap: wrap;
    }

    .btn-sm {
      padding: var(--space-2) var(--space-3);
      font-size: var(--text-sm);
    }

    /* === ITEM CHOICE UI === */
    .choice-container {
      margin-bottom: var(--space-5);
      padding-bottom: var(--space-4);
      border-bottom: 1px solid var(--muted);
    }

    .choice-container:last-child {
      margin-bottom: 0;
      padding-bottom: 0;
      border-bottom: none;
    }

    .choice-header {
      font-size: var(--text-sm);
      color: var(--muted-dark);
      text-transform: uppercase;
      letter-spacing: var(--tracking-normal);
      margin-bottom: var(--space-3);
      text-align: center;
    }

    .choice-options {
      display: flex;
      flex-direction: column;
      gap: var(--space-2);
    }

    .choice-option {
      display: flex;
      align-items: center;
      gap: var(--space-3);
      padding: var(--space-3);
      background: var(--paper);
      border: 2px solid;
      border-radius: var(--radius-md);
      cursor: pointer;
      transition: all var(--transition-fast);
    }

    .choice-option:hover {
      background: var(--paper-dark);
      transform: translateX(4px);
    }

    .choice-option.disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .choice-option.disabled:hover {
      background: var(--paper);
      transform: none;
    }

    .choice-option-icon {
      width: 40px;
      height: 40px;
      min-width: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: var(--radius-md);
    }

    .choice-option-icon [data-lucide] {
      width: 24px;
      height: 24px;
    }

    .choice-option-info {
      flex: 1;
      min-width: 0;
    }

    .choice-option-name {
      font-weight: bold;
      font-size: var(--text-base);
      margin-bottom: var(--space-1);
      display: flex;
      align-items: center;
      gap: var(--space-2);
      flex-wrap: wrap;
    }

    .choice-option-desc {
      font-size: var(--text-sm);
      color: var(--muted-dark);
      line-height: 1.3;
      margin-bottom: var(--space-1);
    }

    .choice-option-meta {
      display: flex;
      align-items: center;
      gap: var(--space-2);
      flex-wrap: wrap;
      font-size: var(--text-xs);
    }

    .choice-tier {
      text-transform: uppercase;
      letter-spacing: var(--tracking-normal);
      font-weight: bold;
    }

    .choice-stacks {
      color: var(--carbon-blue);
      font-weight: bold;
    }

    .upgrade-badge {
      display: inline-block;
      background: var(--carbon-blue);
      color: var(--paper);
      padding: 2px 6px;
      border-radius: var(--radius-sm);
      font-size: var(--text-xs);
      font-weight: bold;
      text-transform: uppercase;
    }

    .upgrade-badge.maxed {
      background: var(--muted);
      color: var(--ink);
    }

    @media (min-width: 500px) {
      .choice-options {
        flex-direction: row;
        gap: var(--space-3);
      }

      .choice-option {
        flex: 1;
        flex-direction: column;
        text-align: center;
        padding: var(--space-3);
      }

      .choice-option:hover {
        transform: translateY(-4px);
      }

      .choice-option-icon {
        width: 48px;
        height: 48px;
        margin-bottom: var(--space-2);
      }

      .choice-option-name {
        justify-content: center;
      }

      .choice-option-meta {
        justify-content: center;
      }
    }

    .instructions {
      position: absolute;
      bottom: 25%;
      left: 50%;
      transform: translateX(-50%);
      color: var(--muted);
      font-size: var(--text-base);
      text-align: center;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    .pulse {
      animation: pulse 1s ease-in-out infinite;
    }

    @keyframes shake {
      0%, 100% { transform: translateX(-50%); }
      25% { transform: translateX(calc(-50% - 5px)); }
      75% { transform: translateX(calc(-50% + 5px)); }
    }

    .shake {
      animation: shake 0.1s ease-in-out;
    }

    /* === LUCIDE ICON STYLES === */
    [data-lucide] {
      width: 1em;
      height: 1em;
      stroke: currentColor;
      stroke-width: 2;
      fill: none;
      display: inline-block;
      vertical-align: middle;
    }

    .item-slot [data-lucide] {
      width: 20px;
      height: 20px;
    }

    .item-icon-wrap [data-lucide] {
      width: 24px;
      height: 24px;
    }

    .item-select-icon [data-lucide] {
      width: 28px;
      height: 28px;
    }

    .tip-item-icon [data-lucide] {
      width: 32px;
      height: 32px;
    }

    .item-notification .item-icon [data-lucide] {
      width: 48px;
      height: 48px;
    }

    .mechanic-icon [data-lucide] {
      width: 36px;
      height: 36px;
    }

    .btn-icon-circle [data-lucide] {
      width: 24px;
      height: 24px;
    }

    /* ============================================================
       NARROW SCREEN FIXES (320-380px)
       ============================================================ */
    @media (max-width: 380px) {
      .menu {
        min-width: auto;
        padding: var(--space-5);
        width: calc(100vw - var(--space-4));
      }

      .menu h1 {
        font-size: clamp(24px, 8vw, 48px);
      }

      .btn-play {
        font-size: var(--text-lg);
        padding: var(--space-3) var(--space-6);
      }

      #collectionMenu {
        padding: var(--space-3);
      }

      .tab-nav {
        gap: var(--space-1);
      }

      .tab-btn {
        padding: var(--space-2) var(--space-3);
        font-size: var(--text-sm);
      }
    }

    /* Safe area insets for notched phones */
    @supports (padding-bottom: env(safe-area-inset-bottom)) {
      .health-bar {
        bottom: calc(5% + env(safe-area-inset-bottom, 0px));
      }
      .xp-bar {
        bottom: calc(2% + env(safe-area-inset-bottom, 0px));
      }
      .active-items, .passive-items {
        bottom: calc(3% + env(safe-area-inset-bottom, 0px));
      }
    }
  </style>
</head>
<body>
  <canvas id="game"></canvas>

  <!-- Hidden input for mobile keyboard capture -->
  <input type="text" id="mobileInput" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" inputmode="text" enterkeyhint="done" aria-hidden="true" tabindex="-1" />

  <div id="ui">
    <div class="stats hidden" id="stats"></div>
    <div class="combo hidden" id="combo"></div>
    <div class="inventory-display hidden" id="inventoryDisplay"></div>

    <!-- Pending Items Widget (non-blocking item queue indicator) -->
    <div class="pending-items-widget hidden" id="pendingItemsWidget">
      <span class="pending-items-icon"><i data-lucide="package"></i></span>
      <span class="pending-items-count" id="pendingItemsCount">0 NEW</span>
      <span class="pending-items-hint">[ESC]</span>
    </div>

    <div class="word-display" id="wordDisplay"></div>
    <div class="white-space-indicator hidden" id="whiteSpaceIndicator">BETWEEN THE LINES</div>
    <div class="instructions hidden" id="instructions">Type the word to attack!</div>

    <!-- Active items (left of bars) -->
    <div class="active-items hidden" id="activeItems"></div>

    <div class="health-bar hidden" id="healthBar">
      <div class="health-bar-fill" id="healthFill"></div>
    </div>
    <div class="xp-bar hidden" id="xpBar">
      <div class="xp-bar-fill" id="xpFill"></div>
    </div>

    <!-- Target Enemy Info -->
    <div class="target-info" id="targetInfo">
      <div class="target-header">
        <span class="target-type" id="targetType">Enemy</span>
        <div class="target-modifiers" id="targetModifiers"></div>
      </div>
      <div class="target-health-container">
        <div class="target-health-bar">
          <div class="target-health-fill" id="targetHealthFill"></div>
        </div>
        <div class="target-health-text" id="targetHealthText">100 / 100</div>
      </div>
    </div>

    <!-- Passive items with cooldowns (right of bars) -->
    <div class="passive-items hidden" id="passiveItems"></div>

    <div class="menu" id="menu">
      <h1>WORD SURVIVOR</h1>
      <p class="tagline">Type words. Survive.</p>

      <button class="btn btn-play" id="startBtn">PLAY</button>

      <label class="tips-toggle" id="tipsToggle">
        <input type="checkbox" id="tipsCheckbox" checked>
        <span class="tips-toggle-label">Show tutorial tips</span>
      </label>

      <div class="mobile-notice hidden" id="mobileNotice">
        <p>Best with a physical keyboard</p>
        <p class="mobile-notice-sub">Tap PLAY to try on mobile!</p>
      </div>

      <div class="menu-secondary">
        <button class="btn-icon-circle" id="howToPlayBtn" aria-label="How to Play"><i data-lucide="help-circle"></i></button>
        <button class="btn-icon-circle" id="collectionBtn" aria-label="Items &amp; Upgrades"><i data-lucide="book-open"></i></button>
        <button class="btn-icon-circle" id="practiceBtn" aria-label="Practice Mode"><i data-lucide="wrench"></i></button>
      </div>

      <p class="menu-hint">First time? Tap <span class="hint-icon">?</span> to learn</p>
    </div>

    <!-- Practice Mode Debug Panel (shows when paused in practice mode) -->
    <div class="debug-panel hidden" id="debugPanel">
      <div class="debug-header">
        <div class="debug-title"><i data-lucide="wrench"></i> PRACTICE MODE</div>
        <button class="debug-close" id="closePracticePanel">&times;</button>
      </div>
      <div class="debug-info">Invincible • Click canvas to spawn selected enemy</div>

      <div class="debug-tabs">
        <button class="debug-tab active" data-tab="enemies">Enemies</button>
        <button class="debug-tab" data-tab="items">Items</button>
        <button class="debug-tab" data-tab="actions">Actions</button>
      </div>

      <div class="debug-tab-content active" id="enemiesTab">
        <div class="debug-category">
          <div class="debug-category-title">Early (Wave 1-2)</div>
          <div class="debug-buttons" id="enemiesEarly"></div>
        </div>
        <div class="debug-category">
          <div class="debug-category-title">Mid (Wave 3-6)</div>
          <div class="debug-buttons" id="enemiesMid"></div>
        </div>
        <div class="debug-category">
          <div class="debug-category-title">Late (Wave 7+)</div>
          <div class="debug-buttons" id="enemiesLate"></div>
        </div>
        <div class="debug-category">
          <div class="debug-category-title">Elite Modifiers</div>
          <div class="debug-buttons" id="eliteModifiers"></div>
        </div>
      </div>

      <div class="debug-tab-content" id="itemsTab">
        <div class="debug-category">
          <div class="debug-category-title" style="color:var(--tier-common)">Common (White)</div>
          <div class="debug-buttons" id="itemsWhite"></div>
        </div>
        <div class="debug-category">
          <div class="debug-category-title" style="color:var(--tier-uncommon)">Uncommon (Green)</div>
          <div class="debug-buttons" id="itemsGreen"></div>
        </div>
        <div class="debug-category">
          <div class="debug-category-title" style="color:var(--tier-rare)">Rare (Red)</div>
          <div class="debug-buttons" id="itemsRed"></div>
        </div>
        <div class="debug-category">
          <div class="debug-category-title" style="color:var(--tier-legendary)">Legendary</div>
          <div class="debug-buttons" id="itemsLegendary"></div>
        </div>
      </div>

      <div class="debug-tab-content" id="actionsTab">
        <div class="debug-actions-grid">
          <button class="debug-btn" id="clearEnemies">Clear Enemies</button>
          <button class="debug-btn" id="clearItems">Clear Items</button>
          <button class="debug-btn" id="levelUp">+1 Level</button>
          <button class="debug-btn" id="addWave">+1 Wave</button>
          <button class="debug-btn" id="healFull">Full Heal</button>
          <button class="debug-btn" id="spawnWave">Spawn Wave</button>
        </div>
        <div class="debug-status" id="debugStatus"></div>
      </div>

      <div class="debug-footer">
        <button class="debug-btn debug-resume" id="resumeFromPractice">Resume Game</button>
        <button class="debug-btn debug-exit" id="exitPractice">Exit Practice</button>
      </div>
    </div>

    <!-- Debug Tooltip (for practice mode hover descriptions) -->
    <div class="debug-tooltip" id="debugTooltip">
      <div class="debug-tooltip-title" id="tooltipTitle"></div>
      <div class="debug-tooltip-desc" id="tooltipDesc"></div>
      <div class="debug-tooltip-meta" id="tooltipMeta"></div>
    </div>

    <!-- Modal Overlay -->
    <div class="modal-overlay hidden" id="modalOverlay"></div>

    <!-- How to Play Modal -->
    <div class="modal hidden" id="howToPlayModal">
      <button class="modal-close" id="closeHowToPlay">&times;</button>
      <h2>How to Play</h2>
      <div class="mechanics-grid">
        <div class="mechanic-card">
          <div class="mechanic-icon"><i data-lucide="keyboard"></i></div>
          <h3>Type to Attack</h3>
          <p>Type enemy words to fire projectiles and destroy them</p>
        </div>
        <div class="mechanic-card mechanic-highlight">
          <div class="mechanic-icon"><i data-lucide="pause"></i></div>
          <h3>Between the Lines</h3>
          <p>Moving pauses time - reposition and collect XP/items, but you can't type while moving</p>
        </div>
        <div class="mechanic-card">
          <div class="mechanic-icon"><i data-lucide="flame"></i></div>
          <h3>Combo System</h3>
          <p>Chain words quickly for damage multipliers</p>
        </div>
        <div class="mechanic-card">
          <div class="mechanic-icon"><i data-lucide="arrow-up"></i></div>
          <h3>Level Up</h3>
          <p>Collect XP gems to level up and choose upgrades</p>
        </div>
        <div class="mechanic-card">
          <div class="mechanic-icon"><i data-lucide="package"></i></div>
          <h3>Collect Items</h3>
          <p>Enemies drop items with powerful effects that stack</p>
        </div>
        <div class="mechanic-card">
          <div class="mechanic-icon"><i data-lucide="skull"></i></div>
          <h3>Survive Waves</h3>
          <p>Enemies get stronger over time - survive as long as you can</p>
        </div>
      </div>
    </div>

    <!-- Collection Modal -->
    <div class="modal modal-large hidden" id="collectionModal">
      <button class="modal-close" id="closeCollection">&times;</button>
      <h2>Collection</h2>
      <div class="tab-nav">
        <button class="tab-btn active" data-tab="items">Items (35)</button>
        <button class="tab-btn" data-tab="upgrades">Upgrades (10)</button>
        <button class="tab-btn" data-tab="enemies">Enemies (15)</button>
      </div>
      <div class="tab-content active" id="itemsTab">
        <div class="tier-filter">
          <button class="tier-btn active" data-tier="all">All</button>
          <button class="tier-btn" data-tier="WHITE">Common</button>
          <button class="tier-btn" data-tier="GREEN">Uncommon</button>
          <button class="tier-btn" data-tier="RED">Rare</button>
          <button class="tier-btn" data-tier="LEGENDARY">Legendary</button>
        </div>
        <div class="items-list" id="itemsList"></div>
      </div>
      <div class="tab-content" id="upgradesTab">
        <div class="upgrades-list" id="upgradesList"></div>
      </div>
      <div class="tab-content" id="enemiesTab">
        <div class="enemies-list" id="enemiesList"></div>
      </div>
    </div>

    <!-- Tip Modal (contextual first-time tips) -->
    <div class="tip-overlay hidden" id="tipOverlay"></div>
    <div class="tip-modal hidden" id="tipModal"></div>

    <!-- Mob Tip (non-blocking corner tips) -->
    <div class="mob-tip hidden" id="mobTip"></div>

    <!-- Item Hover Tooltip -->
    <div class="item-hover-tooltip" id="itemHoverTooltip"></div>

    <div class="menu hidden" id="upgradeMenu">
      <h2>LEVEL UP!</h2>
      <p>Choose an upgrade:</p>
      <div class="upgrade-container" id="upgradeContainer"></div>
    </div>

    <div class="menu hidden" id="itemSelectMenu">
      <h2>ITEM DROP!</h2>
      <p>Choose an item:</p>
      <div class="item-select-container" id="itemSelectContainer"></div>
    </div>

    <div class="menu hidden" id="gameOver">
      <h2>GAME OVER</h2>
      <div class="final-stats" id="finalStats"></div>
      <pre class="share-result" id="shareResult"></pre>
      <button class="btn" id="restartBtn">PLAY AGAIN</button>
      <button class="btn btn-secondary" id="shareBtn">SHARE</button>
    </div>

    <div class="menu hidden" id="pauseMenu">
      <h2>PAUSED</h2>
      <button class="btn" id="resumeBtn">RESUME</button>
      <button class="btn btn-secondary" id="practiceToggleBtn" style="display:none">SPAWN TOOLS</button>
      <button class="btn btn-secondary" id="quitBtn">QUIT</button>
    </div>

    <!-- Collection Menu (for reviewing pending items) -->
    <div class="menu hidden" id="collectionMenu">
      <h2>PENDING ITEMS</h2>
      <p>Items waiting to be collected:</p>
      <div class="collection-list" id="collectionList"></div>
      <div class="collection-actions">
        <button class="btn" id="collectAllBtn">COLLECT ALL</button>
        <button class="btn btn-secondary" id="closeCollectionBtn">KEEP PLAYING</button>
      </div>
    </div>
  </div>

  <script>
  // ============================================================
  // WORD SURVIVOR - A Viral Typing Roguelike
  // ============================================================
  // Single-file browser game. No dependencies.
  // NOTE: This game uses innerHTML with ONLY internally-generated
  // content (game state, hardcoded strings). No user input is
  // rendered as HTML. All user keyboard input is processed as
  // single characters for gameplay, not rendered as markup.
  // ============================================================

  'use strict';

  // Design token bridge - reads CSS variables into JS
  const DESIGN_TOKENS = {
    _cache: {},
    getColor: function(name) {
      if (!this._cache[name]) {
        this._cache[name] = getComputedStyle(document.documentElement)
          .getPropertyValue('--' + name).trim();
      }
      return this._cache[name];
    },
    clearCache: function() {
      this._cache = {};
    }
  };

  // === [SEC:CONFIG] CONFIGURATION ===
  const CONFIG = {
    FIXED_DT: 1/60,
    PLAYER_RADIUS: 20,
    PLAYER_SPEED: 150,
    ENEMY_BASE_SPEED: 40,
    PROJECTILE_SPEED: 600,
    GEM_MAGNET_RANGE: 150,
    GEM_MAGNET_SPEED: 400,
    GEM_COLLECT_RANGE: 35,
    SPAWN_INITIAL_DELAY: 1.0,
    SPAWN_MIN_DELAY: 0.3,
    XP_BASE: 10,
    XP_SCALE: 1.5,
    COMBO_TIMEOUT: 3000,
    MAX_ENEMIES: 100,
    MAX_PROJECTILES: 50,
    MAX_GEMS: 200,
    COLORS: {
      // Underwood palette - read from CSS variables
      get BACKGROUND() { return DESIGN_TOKENS.getColor('paper') || '#f4f1e8'; },
      get BACKGROUND_DARK() { return DESIGN_TOKENS.getColor('paper-dark') || '#e8dcc8'; },
      get PLAYER() { return DESIGN_TOKENS.getColor('ink') || '#1a1714'; },
      get PLAYER_GLOW() { return 'rgba(26, 23, 20, 0.3)'; },
      get PLAYER_TIMESTOP_GLOW() { return 'rgba(212, 168, 75, 0.5)'; },
      get ENEMY() { return DESIGN_TOKENS.getColor('ink') || '#1a1714'; },
      get ENEMY_FAST() { return DESIGN_TOKENS.getColor('ribbon-red') || '#c41e3a'; },
      get ENEMY_TARGET() { return DESIGN_TOKENS.getColor('ribbon-red') || '#c41e3a'; },
      get PROJECTILE() { return DESIGN_TOKENS.getColor('carbon-blue') || '#2d4a6f'; },
      get GEM() { return DESIGN_TOKENS.getColor('carbon-blue') || '#2d4a6f'; },
      get GRID() { return 'rgba(26, 23, 20, 0.05)'; },
      get DAMAGE_NORMAL() { return DESIGN_TOKENS.getColor('ink') || '#1a1714'; },
      get DAMAGE_CRIT() { return DESIGN_TOKENS.getColor('aged-yellow') || '#d4a84b'; },
      get DAMAGE_PLAYER() { return DESIGN_TOKENS.getColor('ribbon-red') || '#c41e3a'; },
      get DAMAGE_HEAL() { return DESIGN_TOKENS.getColor('carbon-blue') || '#2d4a6f'; },
      get DAMAGE_XP() { return DESIGN_TOKENS.getColor('carbon-blue') || '#2d4a6f'; }
    }
  };

  // Accessibility: check reduced motion preference
  const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

  // === [SEC:CANVAS] CANVAS SETUP ===
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  let canvasWidth = 0;
  let canvasHeight = 0;
  let dpr = 1;

  function resizeCanvas() {
    dpr = Math.min(window.devicePixelRatio || 1, 2);
    canvasWidth = window.innerWidth;
    canvasHeight = window.innerHeight;

    canvas.width = canvasWidth * dpr;
    canvas.height = canvasHeight * dpr;
    canvas.style.width = canvasWidth + 'px';
    canvas.style.height = canvasHeight + 'px';

    ctx.scale(dpr, dpr);
  }

  window.addEventListener('resize', resizeCanvas);
  resizeCanvas();

  // Mobile keyboard: on touch devices the virtual keyboard is always open
  // during gameplay, so we statically reserve space for it rather than
  // trying to dynamically detect it (visualViewport is unreliable on iOS).
  // The keyboard-open class is added/removed by startGame/endGame.

  // === [SEC:STATE] GAME STATE ===
  let gameState = 'menu'; // menu, playing, upgrading, paused, gameOver
  let running = false;
  let accumulator = 0;
  let lastTime = 0;
  let gameTime = 0;
  let spawnTimer = CONFIG.SPAWN_INITIAL_DELAY;
  let shakeIntensity = 0;
  let shakeDecay = 0.92;
  let lastDamageSource = null; // Track what killed the player
  let mercyInvincibleUntil = 0; // Mercy invincibility after taking damage (0.75s)
  let lastTrackedWave = 0; // Track wave transitions for audio cues

  // --- [SEC:STATE:PAUSE] PAUSE STATE ---
  let itemNotificationActive = false; // Pause while item popup is shown
  const itemNotificationQueue = []; // Queue of pending item notifications
  let currentItemNotification = null; // Currently displayed notification element
  let tipModalActive = false; // Pause while tip modal is shown

  // --- Pending Items Queue (non-blocking item choices) ---
  const pendingItems = []; // Array of { choices: [{item, isUpgrade, canUpgrade, currentStacks, wouldCreateSynergy}], timestamp }
  let collectionMenuOpen = false;

  // --- [SEC:STATE:PRACTICE] PRACTICE MODE ---
  let practiceMode = false;

  // --- [SEC:STATE:WHITESPACE] WHITE SPACE (Movement Time-Stop) ---
  let inWhiteSpace = false;
  let whiteSpaceAlpha = 0; // 0-1, for smooth visual transitions
  let lastMouseX = 0;
  let lastMouseY = 0;
  let mouseIdleTimer = null;
  const MOUSE_MOVE_THRESHOLD = 2; // Pixels - ignore tiny jitters
  const MOUSE_IDLE_DELAY = 300; // ms before exiting white space (soft delay)
  const WHITE_SPACE_FADE_SPEED = 8; // How fast to fade in/out (per second)

  // --- [SEC:STATE:PLAYER] PLAYER ---
  const player = {
    x: 0,
    y: 0,
    radius: CONFIG.PLAYER_RADIUS,
    health: 100,
    maxHealth: 100,
    xp: 0,
    level: 1,
    xpToNext: CONFIG.XP_BASE
  };

  // --- [SEC:STATE:MODIFIERS] MODIFIERS (from upgrades) ---
  const mods = {
    damageMultiplier: 1,
    speedBonus: 0,
    pickupRange: 1,
    comboBonus: 0,
    armorMultiplier: 1,
    regenRate: 0,
    doubleLetterAOE: false,
    vowelHeal: false
  };

  // --- [SEC:STATE:STATS] STATS ---
  let stats = {
    wordsTyped: 0,
    enemiesKilled: 0,
    totalChars: 0,
    startTime: 0,
    combo: 0,
    maxCombo: 0,
    lastComboTime: 0,
    longestWord: ''
  };

  // --- [SEC:STATE:LITNUKE] LITERARY NUKE SYSTEM ---
  // Every 100 words triggers a screen-clearing nuke with rainbow mario mode
  let litNukeWordCount = 0;        // Words typed since last trigger
  let litNukeActive = false;       // Is rainbow mario mode active?
  let litNukeTimer = 0;            // Countdown for rainbow mode (3 seconds)
  let litNukeAnimating = false;    // Is the explosion animation playing?
  let litNukeAnimTimer = 0;        // Animation progress (0-1)
  const LIT_NUKE_WORDS_REQUIRED = 75;
  const LIT_NUKE_DURATION = 3;     // Rainbow mario mode duration in seconds
  const LIT_NUKE_ANIM_DURATION = 1.5; // Explosion animation duration

  // --- [SEC:STATE:THROTTLE] Throttle timestamps ---
  let lastItemDisplayUpdate = 0; // Throttle for item status display updates (was window._lastItemDisplayUpdate)

  // === [SEC:POOLS] OBJECT POOL ===
  class Pool {
    constructor(factory, reset, maxSize = 200) {
      this.factory = factory;
      this.reset = reset;
      this.maxSize = maxSize;
      this.pool = [];
      this.active = [];

      // Pre-allocate
      for (let i = 0; i < Math.min(50, maxSize); i++) {
        this.pool.push(factory());
      }
    }

    acquire(...args) {
      if (this.active.length >= this.maxSize) return null;

      const obj = this.pool.pop() || this.factory();
      this.reset(obj, ...args);
      this.active.push(obj);
      return obj;
    }

    release(obj) {
      const i = this.active.indexOf(obj);
      if (i !== -1) {
        // Swap with last element and pop — O(1) removal instead of O(n) splice
        const last = this.active.length - 1;
        if (i !== last) {
          this.active[i] = this.active[last];
        }
        this.active.pop();
        if (this.pool.length < this.maxSize) {
          this.pool.push(obj);
        }
      }
    }

    releaseAll() {
      while (this.active.length > 0) {
        const obj = this.active.pop();
        if (this.pool.length < this.maxSize) {
          this.pool.push(obj);
        }
      }
    }

    forEach(fn) {
      for (let i = this.active.length - 1; i >= 0; i--) {
        fn(this.active[i], i);
      }
    }

    get count() {
      return this.active.length;
    }
  }

  // --- [SEC:POOLS:ENTITIES] ENTITY POOLS ---
  const enemies = new Pool(
    () => ({
      x: 0, y: 0, vx: 0, vy: 0, health: 1, maxHealth: 1, word: '', radius: 15, type: 'basic', speed: 1,
      enemyType: 'mumble', color: '#1a1714', behaviorState: {}, stateTimer: 0,
      eliteModifiers: [], isElite: false, invisibility: 1, visualScale: 1,
      rotation: 0, trailEnabled: false, floatOffset: 0, mustKillFirst: false
    }),
    (e, x, y, word, type = 'basic') => {
      e.x = x;
      e.y = y;
      e.word = word;
      e.type = type;
      e.health = word.length;
      e.maxHealth = word.length;
      e.radius = 12 + word.length * 2;
      e.speed = CONFIG.ENEMY_BASE_SPEED + Math.random() * 20;
      const angle = Math.atan2(player.y - y, player.x - x);
      e.vx = Math.cos(angle);
      e.vy = Math.sin(angle);
      // Reset enemy system properties
      e.enemyType = 'mumble';
      e.color = '#1a1714';
      e.behaviorState = {};
      e.stateTimer = 0;
      e.eliteModifiers = [];
      e.isElite = false;
      e.invisibility = 1;
      e.visualScale = 1;
      e.rotation = 0;
      e.trailEnabled = false;
      e.floatOffset = 0;
      e.mustKillFirst = false;
    },
    CONFIG.MAX_ENEMIES
  );

  const projectiles = new Pool(
    () => ({ x: 0, y: 0, vx: 0, vy: 0, damage: 1, radius: 6, target: null, isCrit: false }),
    (p, x, y, targetX, targetY, damage, isCrit = false) => {
      p.x = x;
      p.y = y;
      p.damage = damage;
      p.isCrit = isCrit;
      p.target = null; // Reset target reference
      p.radius = 4 + damage;
      const angle = Math.atan2(targetY - y, targetX - x);
      p.vx = Math.cos(angle) * CONFIG.PROJECTILE_SPEED;
      p.vy = Math.sin(angle) * CONFIG.PROJECTILE_SPEED;
    },
    CONFIG.MAX_PROJECTILES
  );

  const gems = new Pool(
    () => ({ x: 0, y: 0, value: 1, radius: 6 }),
    (g, x, y, value) => {
      g.x = x;
      g.y = y;
      g.value = value;
      g.radius = 4 + Math.min(value, 5);
    },
    CONFIG.MAX_GEMS
  );

  const particles = new Pool(
    () => ({ x: 0, y: 0, vx: 0, vy: 0, life: 1, maxLife: 1, color: '#fff', radius: 3 }),
    (p, x, y, vx, vy, life, color) => {
      p.x = x;
      p.y = y;
      p.vx = vx;
      p.vy = vy;
      p.life = life;
      p.maxLife = life;
      p.color = color;
      p.radius = 2 + Math.random() * 3;
    },
    500
  );

  const damageNumbers = new Pool(
    () => ({ x: 0, y: 0, text: '', type: 'damage', life: 0.6, maxLife: 0.6, offsetX: 0, shake: 0 }),
    (dn, x, y, text, type, offsetX = 0) => {
      dn.x = x + offsetX;
      dn.y = y;
      dn.text = text;
      dn.type = type;
      dn.life = 0.6;
      dn.maxLife = 0.6;
      dn.offsetX = offsetX;
      dn.shake = type === 'crit' ? 3 : 0;
    },
    100
  );

  // === [SEC:WORDS] WORD SYSTEM ===
  const WORDS = {
    easy: [
      'cat', 'dog', 'run', 'hit', 'jump', 'fire', 'ice', 'gold', 'gem', 'orb',
      'axe', 'bow', 'key', 'map', 'sun', 'moon', 'star', 'wind', 'rain', 'bolt',
      'heal', 'cast', 'dash', 'fury', 'rage', 'soul', 'dark', 'glow', 'void', 'beam'
    ],
    medium: [
      'attack', 'defend', 'shield', 'sword', 'magic', 'power', 'blast', 'crash',
      'freeze', 'flame', 'storm', 'arrow', 'strike', 'smash', 'dodge', 'block',
      'charge', 'spirit', 'energy', 'mystic', 'arcane', 'shadow', 'thunder', 'vortex'
    ],
    hard: [
      'lightning', 'explosion', 'destruction', 'annihilate', 'obliterate',
      'devastate', 'earthquake', 'hurricane', 'avalanche', 'inferno',
      'apocalypse', 'cataclysm', 'armageddon', 'nightmare', 'vengeance'
    ],
    bonus: ['POWERUP', 'HEAL', 'BOMB', 'FREEZE', 'SHIELD', 'FURY'],
    stutter: ['babble', 'bobbin', 'bubble', 'cotton', 'dazzle', 'fizzle', 'giggle', 'hobbit', 'jiggle', 'mammal', 'rabbit', 'rubber', 'toffee', 'wiggle', 'zipper'],
    shout: ['ROAR', 'BOOM', 'CRASH', 'BLAST', 'FIGHT', 'RAGE', 'FURY'],
    tiny: ['a', 'I', 'go', 'no', 'up', 'do', 'be', 'we', 'me', 'so', 'ax', 'ox', 'if', 'of', 'or', 'on', 'in', 'at', 'to', 'it'],
    footnoteSentences: [
      'the cat jumped over the hat',
      'see the notes above',
      'as cited in the text',
      'the author makes this point',
      'emphasis has been added',
      'compare with the following',
      'for further reading see',
      'it follows from this',
      'note the key difference',
      'this refers to that',
      'the source is unclear',
      'translated from the original',
      'the data shows this trend',
      'as we shall see later',
      'the reader should note',
      'hence the term applies',
      'but see also this',
      'in other words then',
      'the quote reads thus',
      'from the latin root'
    ],
    palindrome: ['radar', 'level', 'civic', 'kayak', 'madam', 'refer', 'rotor', 'sagas', 'solos', 'tenet', 'deed', 'noon', 'peep', 'poop', 'toot'],
    misspelled: ['definately', 'occured', 'seperate', 'neccessary', 'accomodate', 'restaraunt', 'wierd', 'thier', 'recieve', 'untill'],
    citation: ['ibid', 'et al', 'supra', 'infra', 'source', 'cited', 'ref', 'see also', 'note', 'compare'],
    quote: ['to be or not', 'the end', 'once upon', 'happily ever', 'in conclusion', 'therefore', 'in summary']
  };

  // === [SEC:ENEMIES] ENEMY SYSTEM ===

  // --- [SEC:ENEMIES:TYPES] Enemy Type Definitions ---
  const ENEMY_TYPES = {
    mumble: {
      id: 'mumble', name: 'Mumble',
      wordPool: 'easy', baseHP: 1, baseSpeed: 1,
      color: '#1a1714', behavior: 'chase', // ink - standard enemy
      spawnWeight: 40, minWave: 1
    },
    stutter: {
      id: 'stutter', name: 'Stutter',
      wordPool: 'stutter', baseHP: 1.2, baseSpeed: 0.8,
      color: '#c41e3a', behavior: 'stutter', // ribbon-red - fast enemy
      spawnWeight: 25, minWave: 2,
      behaviorConfig: { stopDuration: [0.3, 0.8], moveDuration: [0.5, 1.5] }
    },
    whisper: {
      id: 'whisper', name: 'Whisper',
      wordPool: 'easy', baseHP: 0.8, baseSpeed: 1.1,
      color: '#a89f91', behavior: 'whisper', // muted - faded enemy
      spawnWeight: 20, minWave: 3,
      behaviorConfig: { revealDistance: 150, fadeSpeed: 3 }
    },
    shout: {
      id: 'shout', name: 'Shout',
      wordPool: 'shout', baseHP: 0.9, baseSpeed: 2.5,
      color: '#c41e3a', behavior: 'charge', // ribbon-red - fast enemy
      spawnWeight: 15, minWave: 4,
      behaviorConfig: { chargeSpeed: 3, windupTime: 0.5, chargeDuration: 1, cooldown: 2 }
    },
    footnote: {
      id: 'footnote', name: 'Footnote',
      wordPool: 'footnoteSentences', baseHP: 0.5, baseSpeed: 1.3,
      color: '#4a7c59', behavior: 'swarm', // tier-uncommon
      spawnWeight: 25, minWave: 2,
      behaviorConfig: { wobbleAmount: 50, wobbleSpeed: 5 }
    },
    slur: {
      id: 'slur', name: 'Slur',
      wordPool: 'medium', baseHP: 1.3, baseSpeed: 0.7,
      color: '#6d645a', behavior: 'chase', // muted-dark
      spawnWeight: 12, minWave: 5
    },
    jargon: {
      id: 'jargon', name: 'Jargon',
      wordPool: 'hard', baseHP: 2.5, baseSpeed: 0.4,
      color: '#3d3830', behavior: 'chase', // ink-light - tank enemy
      spawnWeight: 8, minWave: 6
    },
    palindrome: {
      id: 'palindrome', name: 'Palindrome',
      wordPool: 'palindrome', baseHP: 1.5, baseSpeed: 0.9,
      color: '#2d4a6f', behavior: 'chase', // carbon-blue
      spawnWeight: 8, minWave: 7,
      splitOnDeath: true
    },
    echo: {
      id: 'echo', name: 'Echo',
      wordPool: null, baseHP: 1, baseSpeed: 1.2,
      color: '#2d4a6f', behavior: 'chase', // carbon-blue
      spawnWeight: 6, minWave: 5
    },
    typo: {
      id: 'typo', name: 'Typo',
      wordPool: 'medium', baseHP: 1.2, baseSpeed: 0.9,
      color: '#d4a84b', behavior: 'typo', // aged-yellow
      spawnWeight: 10, minWave: 6,
      behaviorConfig: { scrambleInterval: 2.5 }
    },
    censor: {
      id: 'censor', name: 'Censor',
      wordPool: 'medium', baseHP: 1.8, baseSpeed: 0.5,
      color: '#1a1714', behavior: 'chase', // ink - darkest
      spawnWeight: 6, minWave: 8
    },
    quote: {
      id: 'quote', name: 'Quote',
      wordPool: 'quote', baseHP: 2, baseSpeed: 0.4,
      color: '#d4a84b', behavior: 'chase', // aged-yellow - special enemy
      spawnWeight: 4, minWave: 10
    },
    thesis: {
      id: 'thesis', name: 'Thesis',
      wordPool: 'hard', baseHP: 5, baseSpeed: 0.25,
      color: '#1a1714', behavior: 'chase', // ink - boss-like
      spawnWeight: 2, minWave: 12
    },
    citation_needed: {
      id: 'citation_needed', name: 'Citation Needed',
      wordPool: 'citation', baseHP: 2.5, baseSpeed: 0.5,
      color: '#2d4a6f', behavior: 'summoner', // carbon-blue
      spawnWeight: 4, minWave: 10,
      behaviorConfig: { summonInterval: 3, maxSummons: 6 }
    },
    misspelling: {
      id: 'misspelling', name: 'Misspelling',
      wordPool: 'misspelled', baseHP: 1.5, baseSpeed: 0.8,
      color: '#c41e3a', behavior: 'chase', // ribbon-red - error enemy
      spawnWeight: 8, minWave: 8
    }
  };

  // --- [SEC:ENEMIES:BEHAVIORS] AI Behaviors ---
  const ENEMY_BEHAVIORS = {
    chase: (enemy, dt, player) => {
      const angle = Math.atan2(player.y - enemy.y, player.x - enemy.x);
      enemy.vx = Math.cos(angle);
      enemy.vy = Math.sin(angle);
      enemy.x += enemy.vx * enemy.speed * dt;
      enemy.y += enemy.vy * enemy.speed * dt;
    },

    stutter: (enemy, dt, player) => {
      const config = ENEMY_TYPES[enemy.enemyType].behaviorConfig;
      enemy.stateTimer -= dt;

      if (!enemy.behaviorState.initialized) {
        enemy.behaviorState = { isMoving: true, initialized: true };
        enemy.stateTimer = config.moveDuration[0] + Math.random() * (config.moveDuration[1] - config.moveDuration[0]);
      }

      if (enemy.stateTimer <= 0) {
        enemy.behaviorState.isMoving = !enemy.behaviorState.isMoving;
        const range = enemy.behaviorState.isMoving ? config.moveDuration : config.stopDuration;
        enemy.stateTimer = range[0] + Math.random() * (range[1] - range[0]);
      }

      if (enemy.behaviorState.isMoving) {
        ENEMY_BEHAVIORS.chase(enemy, dt, player);
      }
    },

    whisper: (enemy, dt, player) => {
      const config = ENEMY_TYPES[enemy.enemyType].behaviorConfig;
      const dist = Math.hypot(enemy.x - player.x, enemy.y - player.y);
      const targetAlpha = dist < config.revealDistance ? 1 : 0.1;
      enemy.invisibility += (targetAlpha - enemy.invisibility) * config.fadeSpeed * dt;
      ENEMY_BEHAVIORS.chase(enemy, dt, player);
    },

    charge: (enemy, dt, player) => {
      const config = ENEMY_TYPES[enemy.enemyType].behaviorConfig;
      if (!enemy.behaviorState.initialized) {
        enemy.behaviorState = { phase: 'approach', chargeDir: {x:0,y:0}, initialized: true };
      }
      const state = enemy.behaviorState;

      switch (state.phase) {
        case 'approach':
          ENEMY_BEHAVIORS.chase(enemy, dt, player);
          if (Math.hypot(enemy.x - player.x, enemy.y - player.y) < 200) {
            state.phase = 'windup';
            enemy.stateTimer = config.windupTime;
          }
          break;
        case 'windup':
          enemy.stateTimer -= dt;
          const aimAngle = Math.atan2(player.y - enemy.y, player.x - enemy.x);
          state.chargeDir = { x: Math.cos(aimAngle), y: Math.sin(aimAngle) };
          if (enemy.stateTimer <= 0) { state.phase = 'charging'; enemy.stateTimer = config.chargeDuration; }
          break;
        case 'charging':
          enemy.stateTimer -= dt;
          enemy.x += state.chargeDir.x * enemy.speed * config.chargeSpeed * dt;
          enemy.y += state.chargeDir.y * enemy.speed * config.chargeSpeed * dt;
          if (enemy.stateTimer <= 0) { state.phase = 'cooldown'; enemy.stateTimer = config.cooldown; }
          break;
        case 'cooldown':
          enemy.stateTimer -= dt;
          ENEMY_BEHAVIORS.chase(enemy, dt * 0.3, player);
          if (enemy.stateTimer <= 0) { state.phase = 'approach'; }
          break;
      }
    },

    swarm: (enemy, dt, player) => {
      const config = ENEMY_TYPES[enemy.enemyType].behaviorConfig;
      if (!enemy.behaviorState.initialized) {
        enemy.behaviorState = { wobbleOffset: Math.random() * Math.PI * 2, initialized: true };
      }
      const baseAngle = Math.atan2(player.y - enemy.y, player.x - enemy.x);
      const wobble = Math.sin(gameTime * config.wobbleSpeed + enemy.behaviorState.wobbleOffset) * 0.5;
      enemy.vx = Math.cos(baseAngle + wobble);
      enemy.vy = Math.sin(baseAngle + wobble);
      enemy.x += enemy.vx * enemy.speed * dt;
      enemy.y += enemy.vy * enemy.speed * dt;
    },

    typo: (enemy, dt, player) => {
      const config = ENEMY_TYPES[enemy.enemyType].behaviorConfig;
      if (!enemy.behaviorState.initialized) {
        enemy.behaviorState = { originalWord: enemy.word, scrambleTimer: config.scrambleInterval, initialized: true };
      }
      // Don't scramble if this enemy is the current target (word is locked in)
      if (enemy !== targetEnemy) {
        enemy.behaviorState.scrambleTimer -= dt;
        if (enemy.behaviorState.scrambleTimer <= 0) {
          const chars = enemy.behaviorState.originalWord.split('');
          for (let i = chars.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [chars[i], chars[j]] = [chars[j], chars[i]];
          }
          enemy.word = chars.join('');
          enemy.behaviorState.scrambleTimer = config.scrambleInterval;
        }
      }
      ENEMY_BEHAVIORS.chase(enemy, dt, player);
    },

    summoner: (enemy, dt, player) => {
      const config = ENEMY_TYPES[enemy.enemyType].behaviorConfig;
      if (!enemy.behaviorState.initialized) {
        enemy.behaviorState = { summonTimer: config.summonInterval, summonCount: 0, initialized: true };
      }
      enemy.behaviorState.summonTimer -= dt;
      if (enemy.behaviorState.summonTimer <= 0 && enemy.behaviorState.summonCount < config.maxSummons) {
        spawnEnemyOfType(
          enemy.x + (Math.random() - 0.5) * 60,
          enemy.y + (Math.random() - 0.5) * 60,
          'mumble'
        );
        enemy.behaviorState.summonCount++;
        enemy.behaviorState.summonTimer = config.summonInterval;
      }
      ENEMY_BEHAVIORS.chase(enemy, dt * 0.5, player);
    }
  };

  // --- [SEC:ENEMIES:ELITE] Elite Modifiers ---
  const ELITE_MODIFIERS = {
    bold: {
      id: 'bold', name: 'BOLD',
      onApply: (e) => { e.maxHealth *= 2; e.health = e.maxHealth; e.radius *= 1.3; e.visualScale = 1.3; },
      visualEffect: (ctx, e) => { ctx.lineWidth = 4; ctx.strokeStyle = '#fff'; ctx.stroke(); }
    },
    italic: {
      id: 'italic', name: 'ITALIC',
      onApply: (e) => { e.speed *= 2; e.rotation = Math.PI / 8; },
      visualEffect: (ctx, e) => { /* handled by rotation in render */ }
    },
    underlined: {
      id: 'underlined', name: 'UNDERLINED',
      onApply: (e) => { e.trailEnabled = true; },
      visualEffect: (ctx, e) => {
        const r = e.radius * (e.visualScale || 1);
        ctx.strokeStyle = DESIGN_TOKENS.getColor('aged-yellow') || '#d4a84b'; ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(e.x - r, e.y + r + 5);
        ctx.lineTo(e.x + r, e.y + r + 5);
        ctx.stroke();
      }
    },
    strikethrough: {
      id: 'strikethrough', name: 'STRIKETHROUGH',
      onDeath: (e) => {
        const ghost = spawnEnemyOfType(e.x, e.y, 'mumble');
        if (ghost) {
          ghost.health = 1;
          ghost.maxHealth = 1;
          ghost.color = 'rgba(255, 100, 100, 0.5)';
          ghost.invisibility = 0.5;
        }
      },
      visualEffect: (ctx, e) => {
        const r = e.radius * (e.visualScale || 1);
        ctx.strokeStyle = '#c41e3a'; ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(e.x - r, e.y);
        ctx.lineTo(e.x + r, e.y);
        ctx.stroke();
      }
    },
    superscript: {
      id: 'superscript', name: 'SUPERSCRIPT',
      onApply: (e) => { e.visualScale = 0.7; e.radius *= 0.7; },
      onUpdate: (e, dt) => { e.floatOffset = Math.sin(gameTime * 3) * 10; },
      visualEffect: (ctx, e) => { /* handled by floatOffset */ }
    },
    subscript: {
      id: 'subscript', name: 'SUBSCRIPT',
      onApply: (e) => { e.visualScale = 0.7; e.radius *= 0.7; },
      onUpdate: (e, dt) => {
        const dist = Math.hypot(e.x - player.x, e.y - player.y);
        e.invisibility = dist > 100 ? 0.3 : 1;
      },
      visualEffect: (ctx, e) => { /* handled by invisibility */ }
    },
    highlighted: {
      id: 'highlighted', name: 'HIGHLIGHTED',
      onApply: (e) => { e.mustKillFirst = true; },
      visualEffect: (ctx, e) => {
        const r = e.radius * (e.visualScale || 1);
        ctx.fillStyle = 'rgba(255, 255, 0, 0.3)';
        ctx.fillRect(e.x - r - 5, e.y - r - 5, r * 2 + 10, r * 2 + 10);
      }
    },
    hyperlinked: {
      id: 'hyperlinked', name: 'HYPERLINKED',
      onDeath: (e) => {
        for (let i = 0; i < 2 + Math.floor(Math.random() * 2); i++) {
          spawnEnemyOfType(e.x + (Math.random()-0.5)*50, e.y + (Math.random()-0.5)*50, 'mumble');
        }
      },
      visualEffect: (ctx, e) => {
        const r = e.radius * (e.visualScale || 1);
        ctx.strokeStyle = DESIGN_TOKENS.getColor('carbon-blue') || '#2d4a6f'; ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(e.x - r, e.y + r + 3);
        ctx.lineTo(e.x + r, e.y + r + 3);
        ctx.stroke();
      }
    }
  };

  // --- [SEC:ENEMIES:SPAWN] Spawning Logic ---
  let lastKilledWord = null; // For Echo enemies

  function applyEliteModifier(enemy, modId) {
    const mod = ELITE_MODIFIERS[modId];
    if (!mod) return;
    enemy.eliteModifiers.push(modId);
    enemy.isElite = true;
    if (mod.onApply) mod.onApply(enemy);
    playEliteSpawnSound();
  }

  function updateEliteModifiers(enemy, dt) {
    for (const modId of enemy.eliteModifiers) {
      const mod = ELITE_MODIFIERS[modId];
      if (mod?.onUpdate) mod.onUpdate(enemy, dt);
    }
  }

  function handleEliteOnDeath(enemy) {
    for (const modId of enemy.eliteModifiers) {
      const mod = ELITE_MODIFIERS[modId];
      if (mod?.onDeath) mod.onDeath(enemy);
    }
  }

  function handleEnemyDeath(enemy, projectile = null) {
    // Track for Echo enemies
    lastKilledWord = enemy.word;

    // Handle elite modifiers
    handleEliteOnDeath(enemy);

    // INTEGRATE WITH ITEM SYSTEM
    callHooks('onEnemyKill', enemy, projectile);
    checkItemDrop(enemy);

    // Screen shake on kill — every word completion feels impactful
    shakeIntensity = Math.max(shakeIntensity, 4);

    // Palindrome split on death
    const typeConfig = ENEMY_TYPES[enemy.enemyType];
    if (typeConfig?.splitOnDeath && enemy.word.length >= 3) {
      const halfWord = enemy.word.substring(0, Math.ceil(enemy.word.length / 2));
      for (let i = 0; i < 2; i++) {
        const split = spawnEnemyOfType(
          enemy.x + (i === 0 ? -30 : 30),
          enemy.y + (Math.random() - 0.5) * 20,
          'mumble'
        );
        if (split) {
          split.word = halfWord;
          split.maxHealth = Math.max(1, Math.ceil(enemy.maxHealth / 3));
          split.health = split.maxHealth;
          split.radius = 12 + halfWord.length * 2;
          split.color = '#ff88ff';
        }
      }
    }
  }

  function getEnemyTypeForWave(wave) {
    const available = Object.entries(ENEMY_TYPES)
      .filter(([id, type]) => wave >= type.minWave)
      .map(([id, type]) => ({ id, weight: type.spawnWeight }));

    const totalWeight = available.reduce((sum, t) => sum + t.weight, 0);
    let roll = Math.random() * totalWeight;

    for (const type of available) {
      roll -= type.weight;
      if (roll <= 0) return type.id;
    }
    return 'mumble';
  }

  // Footnote counter for display formatting
  let footnoteCounter = 0;

  function spawnEnemyOfType(x, y, enemyType) {
    // Show mob tip on first encounter
    showMobTip(enemyType);

    const typeConfig = ENEMY_TYPES[enemyType];
    const wave = Math.floor(gameTime / 20) + 1;

    // Echo enemies copy the last killed enemy's word
    let word;
    if (enemyType === 'echo' && lastKilledWord) {
      word = lastKilledWord;
    } else {
      const pool = typeConfig.wordPool || getDifficultyForWave(wave);
      const wordList = WORDS[pool] || WORDS.easy;
      word = wordList[Math.floor(Math.random() * wordList.length)];
    }

    const enemy = enemies.acquire(x, y, word, enemyType);
    if (!enemy) return null;

    enemy.enemyType = enemyType;
    enemy.color = typeConfig.color;
    enemy.speed = CONFIG.ENEMY_BASE_SPEED * typeConfig.baseSpeed + Math.random() * 20;
    enemy.maxHealth = Math.ceil(word.length * typeConfig.baseHP);
    enemy.health = enemy.maxHealth;
    enemy.behaviorState = {};
    enemy.stateTimer = 0;
    enemy.eliteModifiers = [];

    // Assign footnote number for display
    if (enemyType === 'footnote') {
      footnoteCounter++;
      enemy.footnoteNumber = footnoteCounter;
    }
    enemy.isElite = false;
    enemy.invisibility = enemyType === 'whisper' ? 0.1 : 1;
    enemy.visualScale = 1;

    // Elite spawning (wave 3+, scaling chance)
    if (wave >= 3 && Math.random() < Math.min(0.05 + (wave - 3) * 0.02, 0.3)) {
      const modIds = Object.keys(ELITE_MODIFIERS);
      const unlocked = modIds.filter(id => {
        if (id === 'strikethrough' || id === 'superscript' || id === 'subscript') return wave >= 5;
        if (id === 'hyperlinked' || id === 'highlighted') return wave >= 7;
        return true;
      });
      const modId = unlocked[Math.floor(Math.random() * unlocked.length)];
      applyEliteModifier(enemy, modId);
    }

    return enemy;
  }

  // === [SEC:ITEMS] ITEM SYSTEM ===
  const ITEM_TIERS = {
    WHITE: {
      get color() { return DESIGN_TOKENS.getColor('tier-common') || '#6d645a'; },
      glow: 'rgba(168, 159, 145, 0.3)',
      name: 'Common',
      dropWeight: 60,
      cssClass: 'tier-white'
    },
    GREEN: {
      get color() { return DESIGN_TOKENS.getColor('tier-uncommon') || '#4a7c59'; },
      glow: 'rgba(90, 156, 106, 0.3)',
      name: 'Uncommon',
      dropWeight: 25,
      cssClass: 'tier-green'
    },
    RED: {
      get color() { return DESIGN_TOKENS.getColor('tier-rare') || '#c41e3a'; },
      glow: 'rgba(196, 30, 58, 0.3)',
      name: 'Rare',
      dropWeight: 12,
      cssClass: 'tier-red'
    },
    LEGENDARY: {
      get color() { return DESIGN_TOKENS.getColor('tier-legendary') || '#d4a84b'; },
      glow: 'rgba(212, 168, 75, 0.4)',
      name: 'Legendary',
      dropWeight: 3,
      cssClass: 'tier-legendary'
    }
  };

  // Helper to apply tier styling using CSS classes instead of inline styles
  function applyTierStyle(element, tier) {
    if (!tier || !tier.cssClass) return;
    element.classList.add(tier.cssClass, tier.cssClass.replace('tier-', 'tier-bg-'));
  }

  // Helper to create Lucide icon element for DOM (safe creation without innerHTML)
  function createIconElement(iconName) {
    const icon = document.createElement('i');
    icon.setAttribute('data-lucide', iconName);
    return icon;
  }

  // Item registry - all items defined here
  const ITEMS = {};

  // Cooldown mixin for items with canUse()/use() pattern
  // Usage: Object.assign(itemDef, withCooldown(baseSec, stepSec, minSec))
  function withCooldown(baseSec, stepSec, minSec) {
    return {
      lastUsed: 0,
      canUse() {
        const stacks = inventory[this.id] || 0;
        if (stacks === 0) return false;
        const cooldown = Math.max(minSec, baseSec - (stacks - 1) * stepSec) * 1000;
        return performance.now() - this.lastUsed >= cooldown;
      },
      markUsed() {
        this.lastUsed = performance.now();
      }
    };
  }

  // --- [SEC:ITEMS:WHITE] WHITE TIER ITEMS ---
  ITEMS.rubber_letters = {
    id: 'rubber_letters',
    name: 'Rubber Letters',
    description: 'Projectiles bounce off screen edges',
    stackEffect: '+1 wall bounce per stack',
    tier: 'WHITE',
    maxStacks: 10,
    icon: 'circle-dot',
    registerHooks() {
      registerItemHook('onProjectileUpdate', this.id, (stacks, projectile, dt) => {
        const maxBounces = stacks;
        if (!projectile.wallBounces) projectile.wallBounces = 0;
        if (projectile.wallBounces >= maxBounces) return;

        if (projectile.x <= 0 || projectile.x >= canvasWidth) {
          projectile.vx *= -1;
          projectile.x = Math.max(1, Math.min(canvasWidth - 1, projectile.x));
          projectile.wallBounces++;
          spawnParticles(projectile.x, projectile.y, 3, '#fff');
          if (hasSynergy('pinball_wizard')) {
            projectile.vx *= 1.15;
            projectile.vy *= 1.15;
            spawnParticles(projectile.x, projectile.y, 2, '#d4a84b');
          }
        }
        if (projectile.y <= 0 || projectile.y >= canvasHeight) {
          projectile.vy *= -1;
          projectile.y = Math.max(1, Math.min(canvasHeight - 1, projectile.y));
          projectile.wallBounces++;
          spawnParticles(projectile.x, projectile.y, 3, '#fff');
          if (hasSynergy('pinball_wizard')) {
            projectile.vx *= 1.15;
            projectile.vy *= 1.15;
            spawnParticles(projectile.x, projectile.y, 2, '#d4a84b');
          }
        }
      });
    }
  };

  ITEMS.vowel_vampirism = {
    id: 'vowel_vampirism',
    name: 'Vowel Vampirism',
    description: 'Heal HP when typing vowels (A, E, I, O, U)',
    stackEffect: '+1 HP per vowel per stack',
    tier: 'WHITE',
    maxStacks: 10,
    icon: 'heart-pulse',
    registerHooks() {
      registerItemHook('onKeyPress', this.id, (stacks, key, isCorrect) => {
        if (isCorrect && 'aeiouAEIOU'.includes(key)) {
          const healAmount = stacks;
          player.health = Math.min(player.health + healAmount, player.maxHealth);
          updateHealthBar();
          spawnParticles(player.x, player.y - 20, 3, '#0f0');
        }
      });
    }
  };

  ITEMS.echo_chamber = {
    id: 'echo_chamber',
    name: 'Echo Chamber',
    description: 'Chance to fire a duplicate projectile',
    stackEffect: '+15% chance per stack, diminishing after 4 (max 75%)',
    tier: 'WHITE',
    maxStacks: 6,
    icon: 'copy',
    registerHooks() {
      registerItemHook('onProjectileCreate', this.id, (stacks, projectile) => {
        const chance = Math.min(0.75, stacks <= 4 ? stacks * 0.15 : 0.60 + (stacks - 4) * 0.075);
        if (Math.random() < chance && !projectile.isEcho) {
          setTimeout(() => {
            const echo = projectiles.acquire(
              projectile.x, projectile.y,
              projectile.x + projectile.vx, projectile.y + projectile.vy,
              projectile.damage
            );
            if (echo) {
              echo.isEcho = true;
              echo.vx = projectile.vx * (0.9 + Math.random() * 0.2);
              echo.vy = projectile.vy * (0.9 + Math.random() * 0.2);
            }
          }, 50);
        }
      });
    }
  };

  ITEMS.consonant_cruelty = {
    id: 'consonant_cruelty',
    name: 'Consonant Cruelty',
    description: 'Consonants typed add +5% damage to that word',
    stackEffect: 'Bonus multiplied by stack count',
    tier: 'WHITE',
    maxStacks: 20,
    icon: 'case-upper',
    consonantCount: 0,
    registerHooks() {
      const consonants = 'bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ';
      registerItemHook('onKeyPress', this.id, (stacks, key, isCorrect) => {
        if (isCorrect && consonants.includes(key)) {
          ITEMS.consonant_cruelty.consonantCount++;
        }
      });
      registerItemHook('onWordComplete', this.id, (stacks, word, enemy, damage) => {
        const effectiveStacks = stacks <= 8 ? stacks : 8 + (stacks - 8) * 0.5;
        const bonus = 1 + (ITEMS.consonant_cruelty.consonantCount * 0.05 * effectiveStacks);
        ITEMS.consonant_cruelty.consonantCount = 0;
        return Math.ceil(damage * bonus);
      });
    }
  };

  ITEMS.spellcheck = {
    id: 'spellcheck',
    name: 'Spellcheck',
    description: 'Forgives one typo without resetting your word (30s cooldown)',
    stackEffect: '-5s cooldown per stack (min 5s)',
    tier: 'WHITE',
    maxStacks: 5,
    icon: 'check',
    ...withCooldown(30, 5, 5),
    registerHooks() {
      // Handled directly in keydown handler
    },
    use() {
      this.markUsed();
      spawnParticles(player.x, player.y, 5, '#0f0');
    }
  };

  ITEMS.margin_notes = {
    id: 'margin_notes',
    name: 'Margin Notes',
    description: 'Enemies drop pickups that auto-complete your next word',
    stackEffect: '+pickup collection radius per stack',
    tier: 'WHITE',
    maxStacks: 5,
    icon: 'file-text',
    registerHooks() {
      registerItemHook('onEnemyKill', this.id, (stacks, enemy) => {
        spawnMarginNote(enemy.x, enemy.y, stacks);
      });
    }
  };

  ITEMS.torn_page = {
    id: 'torn_page',
    name: 'Torn Page',
    description: 'Chance for words to be shortened to half length',
    stackEffect: '+15% chance per stack (30% base, max 75%)',
    tier: 'WHITE',
    maxStacks: 4,
    icon: 'scissors',
    registerHooks() {
      registerItemHook('onWordAssign', this.id, (stacks, word, enemy) => {
        const chance = 0.30 + (stacks - 1) * 0.15;
        if (Math.random() < chance) {
          const halfLength = Math.ceil(word.length / 2);
          return word.slice(0, halfLength);
        }
        return word;
      });
    }
  };

  ITEMS.papercut = {
    id: 'papercut',
    name: 'Papercut',
    description: 'Projectiles inflict bleed (2% HP/sec)',
    stackEffect: '+1s bleed duration per stack',
    tier: 'WHITE',
    maxStacks: 10,
    icon: 'droplet',
    registerHooks() {
      registerItemHook('onProjectileHit', this.id, (stacks, projectile, enemy) => {
        if (!enemy.bleedDuration) enemy.bleedDuration = 0;
        enemy.bleedDuration += 3 + stacks; // 3 + stacks seconds of bleed
        enemy.bleedDamage = 0.02; // 2% HP per second
      });
    }
  };

  ITEMS.ink_blot = {
    id: 'ink_blot',
    name: 'Ink Blot',
    description: 'Enemies leave damaging ink pools on death',
    stackEffect: '+pool damage per stack',
    tier: 'GREEN',
    maxStacks: 5,
    icon: 'droplets',
    registerHooks() {
      registerItemHook('onEnemyKill', this.id, (stacks, enemy) => {
        spawnInkPool(enemy.x, enemy.y, stacks);
      });
    }
  };

  ITEMS.footnote = {
    id: 'footnote',
    name: 'Footnote',
    description: 'Periodically fires an auto-targeting homing projectile',
    stackEffect: 'Triggers 1 word sooner per stack (every 5, min 2)',
    tier: 'WHITE',
    maxStacks: 4,
    icon: 'subscript',
    wordCount: 0,
    registerHooks() {
      registerItemHook('onWordComplete', this.id, (stacks, word, enemy) => {
        ITEMS.footnote.wordCount++;
        const interval = Math.max(2, 5 - (stacks - 1));
        if (ITEMS.footnote.wordCount >= interval) {
          ITEMS.footnote.wordCount = 0;
          fireHomingProjectile();
        }
      });
    }
  };

  // --- [SEC:ITEMS:GREEN] GREEN TIER ITEMS ---
  ITEMS.bookmark = {
    id: 'bookmark',
    name: 'Bookmark',
    description: 'Cheat death once per run, respawning with HP',
    stackEffect: '+10% respawn HP per stack (30% base)',
    tier: 'GREEN',
    maxStacks: 7,
    icon: 'bookmark',
    used: false,
    registerHooks() {
      registerItemHook('onDeath', this.id, (stacks) => {
        if (!ITEMS.bookmark.used) {
          ITEMS.bookmark.used = true;
          const respawnHP = 0.30 + (stacks - 1) * 0.10;
          return { prevent: true, respawnHP: Math.floor(player.maxHealth * respawnHP) };
        }
      });
    }
  };

  ITEMS.ricochet_rune = {
    id: 'ricochet_rune',
    name: 'Ricochet Rune',
    description: 'Projectiles bounce to nearby enemies after impact',
    stackEffect: '+1 enemy bounce per stack',
    tier: 'GREEN',
    maxStacks: 10,
    icon: 'refresh-cw',
    registerHooks() {
      registerItemHook('onProjectileHit', this.id, (stacks, projectile, enemy) => {
        if (!projectile.enemyBounces) projectile.enemyBounces = 0;
        if (projectile.enemyBounces >= stacks) return;

        const result = findNearestEnemy(enemy.x, enemy.y, {
          maxRange: 300,
          excludeSet: projectile.hitEnemies,
          filter: e => e !== enemy
        });

        if (result) {
          const nearest = result.enemy;
          const angle = Math.atan2(nearest.y - enemy.y, nearest.x - enemy.x);
          projectile.x = enemy.x;
          projectile.y = enemy.y;
          const speed = hasSynergy('pinball_wizard')
            ? CONFIG.PROJECTILE_SPEED * (1 + 0.15 * projectile.enemyBounces)
            : CONFIG.PROJECTILE_SPEED;
          projectile.vx = Math.cos(angle) * speed;
          projectile.vy = Math.sin(angle) * speed;
          projectile.enemyBounces++;
          if (!projectile.hitEnemies) projectile.hitEnemies = new Set();
          projectile.hitEnemies.add(enemy);
          spawnParticles(enemy.x, enemy.y, 5, '#0f0');
          if (hasSynergy('pinball_wizard')) {
            spawnParticles(enemy.x, enemy.y, 2, '#d4a84b');
          }
          return { preventRelease: true };
        }
      });
    }
  };

  ITEMS.chain_letter = {
    id: 'chain_letter',
    name: 'Chain Letter',
    description: 'Every 10 words, unleash chain lightning',
    stackEffect: '+1 lightning target per stack (3 base)',
    tier: 'GREEN',
    maxStacks: 5,
    icon: 'zap',
    wordCount: 0,
    registerHooks() {
      registerItemHook('onWordComplete', this.id, (stacks, word, enemy) => {
        ITEMS.chain_letter.wordCount++;
        if (ITEMS.chain_letter.wordCount >= 10) {
          ITEMS.chain_letter.wordCount = 0;
          fireChainLightning(stacks);
        }
      });
    }
  };

  ITEMS.red_pen = {
    id: 'red_pen',
    name: 'Red Pen',
    description: 'Chance for projectiles to deal 3x critical damage',
    stackEffect: '+5% crit chance per stack (10% base)',
    tier: 'GREEN',
    maxStacks: 10,
    icon: 'pen-line',
    registerHooks() {
      registerItemHook('onProjectileCreate', this.id, (stacks, projectile) => {
        const critChance = Math.min(0.40, stacks <= 6 ? 0.10 + (stacks - 1) * 0.05 : 0.30 + (stacks - 6) * 0.025);
        if (Math.random() < critChance) {
          projectile.isCrit = true;
          projectile.damage *= 3;
          projectile.radius *= 1.5;
        }
      });
      registerItemHook('onProjectileHit', this.id, (stacks, projectile, enemy) => {
        if (projectile.isCrit) {
          enemy.marked = true;
          enemy.markDuration = 5; // 5 seconds
          spawnParticles(enemy.x, enemy.y, 8, '#c41e3a');
        }
      });
    }
  };

  ITEMS.ghostwriter = {
    id: 'ghostwriter',
    name: 'Ghostwriter',
    description: 'A spectral helper auto-attacks short-word enemies',
    stackEffect: '+1 ghostwriter per stack (attacks faster)',
    tier: 'GREEN',
    maxStacks: 3,
    icon: 'ghost',
    lastAutoType: 0,
    registerHooks() {
      registerItemHook('onUpdate', this.id, (stacks, dt) => {
        const now = performance.now();
        const interval = 3000 / stacks; // Faster with more stacks
        if (now - ITEMS.ghostwriter.lastAutoType > interval) {
          // Find an easy enemy (3-4 letter word) that's not current target
          let easyEnemy = null;
          enemies.forEach(e => {
            if (e !== targetEnemy && e.word.length <= 4 && !firedAtEnemies.has(e)) {
              if (!easyEnemy || e.word.length < easyEnemy.word.length) {
                easyEnemy = e;
              }
            }
          });
          if (easyEnemy) {
            ITEMS.ghostwriter.lastAutoType = now;
            firedAtEnemies.add(easyEnemy);
            fireAtEnemy(easyEnemy, easyEnemy.word.length);
            spawnParticles(player.x, player.y - 30, 5, '#9966ff');
          }
        }
      });
    }
  };

  ITEMS.hardcover = {
    id: 'hardcover',
    name: 'Hardcover',
    description: 'Typing words builds armor that blocks damage',
    stackEffect: 'Fewer words per armor (10, 8, 6, 4)',
    tier: 'GREEN',
    maxStacks: 4,
    icon: 'shield',
    wordsTyped: 0,
    armor: 0,
    registerHooks() {
      registerItemHook('onWordComplete', this.id, (stacks, word, enemy) => {
        ITEMS.hardcover.wordsTyped++;
        const threshold = Math.max(2, 10 - (stacks - 1) * 2);
        if (ITEMS.hardcover.wordsTyped >= threshold) {
          ITEMS.hardcover.wordsTyped = 0;
          ITEMS.hardcover.armor++;
          spawnParticles(player.x, player.y, 5, '#888');
        }
      });
      registerItemHook('onDamageTaken', this.id, (stacks, damage) => {
        if (ITEMS.hardcover.armor > 0) {
          ITEMS.hardcover.armor--;
          spawnParticles(player.x, player.y, 8, '#fff');
          return 0; // Block all damage
        }
        return damage;
      });
    }
  };

  ITEMS.unabridged = {
    id: 'unabridged',
    name: 'Unabridged',
    description: 'Long words (8+ letters) explode, damaging nearby enemies',
    stackEffect: '+30 explosion radius per stack',
    tier: 'GREEN',
    maxStacks: 5,
    icon: 'book-open',
    registerHooks() {
      registerItemHook('onWordComplete', this.id, (stacks, word, enemy) => {
        if (word.length >= 8 && enemy) {
          const aoeRadius = 80 + stacks * 30;
          const aoeDamage = word.length * 2;
          enemies.forEach(e => {
            if (e !== enemy) {
              const dist = Math.hypot(e.x - enemy.x, e.y - enemy.y);
              if (dist < aoeRadius) {
                e.health -= aoeDamage;
                spawnParticles(e.x, e.y, 3, '#00ffff');
              }
            }
          });
          // Visual effect
          spawnParticles(enemy.x, enemy.y, 12, '#00ffff');
        }
      });
    }
  };

  ITEMS.invisible_ink = {
    id: 'invisible_ink',
    name: 'Invisible Ink',
    description: 'Become invisible for 2 seconds after completing a word',
    stackEffect: '-3s cooldown per stack (15s base, min 3s)',
    tier: 'GREEN',
    maxStacks: 4,
    icon: 'eye-off',
    lastUsed: 0,
    invisibleUntil: 0,
    registerHooks() {
      registerItemHook('onWordComplete', this.id, (stacks, word, enemy) => {
        const now = performance.now();
        const cooldown = Math.max(3, 15 - (stacks - 1) * 3) * 1000;
        if (now - ITEMS.invisible_ink.lastUsed >= cooldown) {
          ITEMS.invisible_ink.lastUsed = now;
          ITEMS.invisible_ink.invisibleUntil = now + 2000;
          spawnParticles(player.x, player.y, 10, '#9999ff');
        }
      });
    },
    isInvisible() {
      return performance.now() < this.invisibleUntil;
    }
  };

  ITEMS.serif_strike = {
    id: 'serif_strike',
    name: 'Serif Strike',
    description: 'Words with serif letters (i, j, f, l, t) deal bonus damage',
    stackEffect: '+25% bonus per stack (50% base)',
    tier: 'GREEN',
    maxStacks: 4,
    icon: 'type',
    registerHooks() {
      registerItemHook('onWordComplete', this.id, (stacks, word, enemy, damage) => {
        const serifLetters = 'ijfltIJFLT';
        const hasSerif = word.split('').some(c => serifLetters.includes(c));
        if (hasSerif) {
          const bonus = 0.50 + (stacks - 1) * 0.25;
          return Math.ceil(damage * (1 + bonus));
        }
        return damage;
      });
    }
  };

  ITEMS.backspace_item = {
    id: 'backspace_item',
    name: 'Backspace',
    description: 'Press BACKSPACE to instantly kill the closest enemy',
    stackEffect: '-2s cooldown per stack (10s base, min 2s)',
    tier: 'GREEN',
    maxStacks: 4,
    icon: 'delete',
    ...withCooldown(10, 2, 2),
    registerHooks() {
      // Handled in keydown
    },
    use() {
      this.markUsed();
      // Find and kill closest enemy
      const result = findNearestEnemy(player.x, player.y);
      if (result) {
        result.enemy.health = 0;
        spawnParticles(result.enemy.x, result.enemy.y, 15, '#c41e3a');
        playKillSound();
      }
    }
  };

  ITEMS.ellipsis = {
    id: 'ellipsis',
    name: 'Ellipsis...',
    description: 'Pause typing for 2s to charge massive damage on next word',
    stackEffect: '+1x damage multiplier per stack (3x base)',
    tier: 'GREEN',
    maxStacks: 5,
    icon: 'more-horizontal',
    lastKeyTime: 0,
    charged: false,
    registerHooks() {
      registerItemHook('onKeyPress', this.id, (stacks, key, isCorrect) => {
        ITEMS.ellipsis.lastKeyTime = performance.now();
        ITEMS.ellipsis.charged = false;
      });
      registerItemHook('onUpdate', this.id, (stacks, dt) => {
        const now = performance.now();
        if (now - ITEMS.ellipsis.lastKeyTime > 2000 && !ITEMS.ellipsis.charged) {
          ITEMS.ellipsis.charged = true;
        }
      });
      registerItemHook('onWordComplete', this.id, (stacks, word, enemy, damage) => {
        if (ITEMS.ellipsis.charged) {
          ITEMS.ellipsis.charged = false;
          const multiplier = 3 + (stacks - 1);
          spawnParticles(player.x, player.y, 10, '#d4a84b');
          return damage * multiplier;
        }
        return damage;
      });
    }
  };

  // --- [SEC:ITEMS:RED] RED TIER ITEMS ---
  ITEMS.damage_aura = {
    id: 'damage_aura',
    name: 'Damage Aura',
    description: 'Enemies near you take constant damage over time',
    stackEffect: '+20 radius and +5 DPS per stack',
    tier: 'RED',
    maxStacks: 5,
    icon: 'flame',
    registerHooks() {
      registerItemHook('onUpdate', this.id, (stacks, dt) => {
        const radius = 80 + stacks * 20;
        const damage = (10 + stacks * 5) * dt;
        enemies.forEach(e => {
          const dist = Math.hypot(e.x - player.x, e.y - player.y);
          if (dist < radius) {
            e.health -= damage;
            if (Math.random() < 0.05) {
              spawnParticles(e.x, e.y, 1, '#ff6600');
            }
          }
        });
      });
    }
  };

  ITEMS.hemingway = {
    id: 'hemingway',
    name: "Hemingway's Curse",
    description: 'Short words (4 letters or less) may fire twice',
    stackEffect: '+15% double-fire chance per stack (50% base)',
    tier: 'RED',
    maxStacks: 3,
    icon: 'hash',
    registerHooks() {
      registerItemHook('onWordComplete', this.id, (stacks, word, enemy) => {
        if (word.length <= 4) {
          const chance = 0.50 + (stacks - 1) * 0.15;
          if (Math.random() < chance && enemy) {
            // Fire again after short delay
            setTimeout(() => {
              if (enemies.active.includes(enemy)) {
                fireAtEnemy(enemy, word.length);
                spawnParticles(player.x, player.y, 5, '#ffcc00');
              }
            }, 100);
          }
        }
      });
    }
  };

  ITEMS.proust = {
    id: 'proust',
    name: "Proust's Blessing",
    description: 'Long words (8+ letters) fire a spread of projectiles',
    stackEffect: '+2 projectiles per stack (8 base)',
    tier: 'RED',
    maxStacks: 4,
    icon: 'scroll-text',
    registerHooks() {
      registerItemHook('onWordComplete', this.id, (stacks, word, enemy) => {
        if (word.length >= 8 && enemy) {
          const projectileCount = 8 + (stacks - 1) * 2;
          const angleSpread = Math.PI / 3; // 60 degree spread
          const baseAngle = Math.atan2(enemy.y - player.y, enemy.x - player.x);

          for (let i = 0; i < projectileCount; i++) {
            const angle = baseAngle - angleSpread/2 + (angleSpread * i / (projectileCount - 1));
            const targetX = player.x + Math.cos(angle) * 500;
            const targetY = player.y + Math.sin(angle) * 500;
            const proj = projectiles.acquire(player.x, player.y, targetX, targetY, Math.ceil(word.length / 2));
            if (proj) {
              proj.isProust = true;
            }
          }
          spawnParticles(player.x, player.y, 10, '#ff00ff');
        }
      });
    }
  };

  ITEMS.monkey_typewriter = {
    id: 'monkey_typewriter',
    name: "Monkey's Typewriter",
    description: 'Any keystroke may instantly complete the entire word',
    stackEffect: '+1% instant completion chance per stack',
    tier: 'RED',
    maxStacks: 10,
    icon: 'dice-5',
    registerHooks() {
      // Handled in keydown
    },
    checkInstantComplete(stacks) {
      const chance = stacks * 0.01;
      return Math.random() < chance;
    }
  };

  ITEMS.ctrl_z = {
    id: 'ctrl_z',
    name: 'Ctrl+Z',
    description: 'On death, rewind time to restore your previous state (once per run)',
    stackEffect: '+5s rewind time per stack (10s base)',
    tier: 'RED',
    maxStacks: 3,
    icon: 'undo-2',
    used: false,
    savedState: null,
    registerHooks() {
      // Save state periodically
      registerItemHook('onUpdate', this.id, (stacks, dt) => {
        // Save state every second
        if (!ITEMS.ctrl_z.lastSave) ITEMS.ctrl_z.lastSave = 0;
        const now = performance.now();
        if (now - ITEMS.ctrl_z.lastSave > 1000) {
          ITEMS.ctrl_z.lastSave = now;
          const rewindTime = (10 + (stacks - 1) * 5) * 1000;
          // Store state for rewinding
          ITEMS.ctrl_z.stateHistory = ITEMS.ctrl_z.stateHistory || [];
          ITEMS.ctrl_z.stateHistory.push({
            time: now,
            health: player.health,
            x: player.x,
            y: player.y,
            xp: player.xp
          });
          // Keep only states within rewind window
          ITEMS.ctrl_z.stateHistory = ITEMS.ctrl_z.stateHistory.filter(s => now - s.time < rewindTime);
        }
      });
      registerItemHook('onDeath', this.id, (stacks) => {
        if (!ITEMS.ctrl_z.used && ITEMS.ctrl_z.stateHistory && ITEMS.ctrl_z.stateHistory.length > 0) {
          ITEMS.ctrl_z.used = true;
          const oldState = ITEMS.ctrl_z.stateHistory[0];
          player.health = Math.max(oldState.health, player.maxHealth * 0.3);
          player.x = oldState.x;
          player.y = oldState.y;
          spawnParticles(player.x, player.y, 20, '#00ffff');
          playTone(600, 0.3, 'sine', 0.2);
          playTone(800, 0.3, 'sine', 0.15);
          return { prevent: true, respawnHP: player.health };
        }
      });
    }
  };

  ITEMS.critical_letter = {
    id: 'critical_letter',
    name: 'Critical Letter',
    description: 'Words may have a glowing letter - type it for instant crit',
    stackEffect: '+5% chance and +0.5x crit per stack (15%/3x base)',
    tier: 'RED',
    maxStacks: 5,
    icon: 'sparkles',
    critLetterIndex: -1,
    registerHooks() {
      registerItemHook('onWordAssign', this.id, (stacks, word, enemy) => {
        // 15% + 5% per additional stack chance to activate
        const chance = 0.15 + (stacks - 1) * 0.05;
        if (Math.random() < chance) {
          ITEMS.critical_letter.critLetterIndex = Math.floor(Math.random() * word.length);
        } else {
          ITEMS.critical_letter.critLetterIndex = -1; // No crit letter this word
        }
        return word;
      });
    },
    isCritLetter(index) {
      return index === this.critLetterIndex;
    },
    getCritMultiplier(stacks) {
      return 3 + (stacks - 1) * 0.5;
    }
  };

  ITEMS.bold_statement = {
    id: 'bold_statement',
    name: 'Bold Statement',
    description: 'Periodically fires a massive high-damage projectile',
    stackEffect: 'Triggers 1 word sooner per stack (every 10, min 5)',
    tier: 'RED',
    maxStacks: 5,
    icon: 'bold',
    wordCount: 0,
    registerHooks() {
      registerItemHook('onWordComplete', this.id, (stacks, word, enemy) => {
        ITEMS.bold_statement.wordCount++;
        const threshold = Math.max(3, 10 - (stacks - 1));
        if (ITEMS.bold_statement.wordCount >= threshold && enemy) {
          ITEMS.bold_statement.wordCount = 0;
          // Fire massive projectile
          const proj = projectiles.acquire(player.x, player.y, enemy.x, enemy.y, word.length * 10);
          if (proj) {
            proj.radius *= 3;
            proj.isBold = true;
          }
          spawnParticles(player.x, player.y, 15, '#ffffff');
          playTone(200, 0.2, 'sawtooth', 0.2);
        }
      });
    }
  };

  ITEMS.comic_sans = {
    id: 'comic_sans',
    name: 'Comic Sans',
    description: 'Each word may trigger random effects (heal, damage, XP, etc.)',
    stackEffect: '+5% trigger chance per stack (10% base)',
    tier: 'RED',
    maxStacks: 6,
    icon: 'smile',
    registerHooks() {
      registerItemHook('onWordComplete', this.id, (stacks, word, enemy) => {
        const chance = 0.10 + (stacks - 1) * 0.05;
        if (Math.random() < chance) {
          const effect = Math.floor(Math.random() * 5);
          switch (effect) {
            case 0: // Heal
              player.health = Math.min(player.health + 20, player.maxHealth);
              updateHealthBar();
              spawnParticles(player.x, player.y, 10, '#4a7c59');
              break;
            case 1: // Damage boost (temp)
              mods.damageMultiplier *= 1.5;
              setTimeout(() => { mods.damageMultiplier /= 1.5; }, 5000);
              spawnParticles(player.x, player.y, 10, '#c41e3a');
              break;
            case 2: // Speed burst (clear nearby enemies)
              enemies.forEach(e => {
                const dist = Math.hypot(e.x - player.x, e.y - player.y);
                if (dist < 150) {
                  e.health -= 50;
                  spawnParticles(e.x, e.y, 5, '#d4a84b');
                }
              });
              break;
            case 3: // XP bonus
              player.xp += 20;
              checkLevelUp();
              spawnParticles(player.x, player.y, 10, '#00ffff');
              break;
            case 4: // Screen shake fun
              shakeIntensity = 15;
              spawnParticles(player.x, player.y, 20, '#ff00ff');
              break;
          }
        }
      });
    }
  };

  ITEMS.tab_complete = {
    id: 'tab_complete',
    name: 'Tab Complete',
    description: 'After typing 3 letters, the word auto-completes',
    stackEffect: '-4s cooldown per stack (20s base, min 4s)',
    tier: 'RED',
    maxStacks: 4,
    icon: 'corner-down-right',
    ...withCooldown(20, 4, 4),
    registerHooks() {
      // Handled in keydown
    },
    use() {
      this.markUsed();
    },
    getRequiredLetters(stacks) {
      return Math.max(1, 3 - Math.floor((stacks - 1) / 2));
    }
  };

  ITEMS.recursive = {
    id: 'recursive',
    name: 'Recursive Definition',
    description: 'Chance to fire at the same enemy twice',
    stackEffect: '+15% double-fire chance per stack (25% base)',
    tier: 'RED',
    maxStacks: 4,
    icon: 'repeat',
    registerHooks() {
      registerItemHook('onWordComplete', this.id, (stacks, word, enemy) => {
        const chance = Math.min(0.65, stacks <= 2 ? 0.25 + (stacks - 1) * 0.15 : 0.40 + (stacks - 2) * 0.125);
        if (Math.random() < chance && enemy && enemies.active.includes(enemy)) {
          // Trigger word effect again
          setTimeout(() => {
            if (enemies.active.includes(enemy)) {
              fireAtEnemy(enemy, word.length);
              spawnParticles(player.x, player.y, 8, '#9900ff');
            }
          }, 150);
        }
      });
    }
  };

  // --- [SEC:ITEMS:LEGENDARY] LEGENDARY TIER ITEMS ---
  ITEMS.tower_of_babel = {
    id: 'tower_of_babel',
    name: 'Tower of Babel',
    description: '20% of words become foreign (Spanish, French, German) - deal 10x damage',
    stackEffect: 'Does not stack',
    tier: 'LEGENDARY',
    maxStacks: 1,
    icon: 'landmark',
    foreignWords: {
      // Spanish
      'hola': true, 'adios': true, 'fuego': true, 'agua': true, 'tierra': true,
      'viento': true, 'muerte': true, 'vida': true, 'amor': true, 'guerra': true,
      // French
      'bonjour': true, 'merci': true, 'feu': true, 'eau': true, 'mort': true,
      'amour': true, 'guerre': true, 'soleil': true, 'lune': true, 'nuit': true,
      // German
      'feuer': true, 'wasser': true, 'erde': true, 'luft': true, 'tod': true,
      'leben': true, 'liebe': true, 'krieg': true, 'nacht': true, 'stern': true
    },
    registerHooks() {
      registerItemHook('onWordAssign', this.id, (stacks, word, enemy) => {
        // 20% chance to replace with foreign word
        if (Math.random() < 0.2) {
          const foreignList = Object.keys(ITEMS.tower_of_babel.foreignWords);
          return foreignList[Math.floor(Math.random() * foreignList.length)];
        }
        return word;
      });
      registerItemHook('onWordComplete', this.id, (stacks, word, enemy, damage) => {
        if (ITEMS.tower_of_babel.foreignWords[word.toLowerCase()]) {
          spawnParticles(player.x, player.y, 15, '#ffd700');
          playTone(1000, 0.2, 'sine', 0.15);
          return damage * 10;
        }
        return damage;
      });
    }
  };

  ITEMS.blood_ink = {
    id: 'blood_ink',
    name: 'Blood Ink',
    description: 'Sacrifice 25% max HP permanently to gain 25% lifesteal',
    stackEffect: 'Does not stack',
    tier: 'LEGENDARY',
    maxStacks: 1,
    icon: 'droplet',
    acquired: false,
    registerHooks() {
      // Apply cost on acquire
    },
    onAcquire() {
      if (!this.acquired) {
        this.acquired = true;
        player.maxHealth = Math.floor(player.maxHealth * 0.75);
        player.health = Math.min(player.health, player.maxHealth);
        updateHealthBar();
      }
    },
    applyLifesteal(damage) {
      const stacks = inventory[this.id] || 0;
      if (stacks > 0) {
        const heal = Math.ceil(damage * 0.25);
        player.health = Math.min(player.health + heal, player.maxHealth);
        updateHealthBar();
        if (Math.random() < 0.2) {
          spawnParticles(player.x, player.y, 2, '#c41e3a');
        }
      }
    }
  };

  ITEMS.babel_toll = {
    id: 'babel_toll',
    name: "Babel's Toll",
    description: '25% of words appear reversed - type them backwards for 5x damage',
    stackEffect: 'Does not stack',
    tier: 'LEGENDARY',
    maxStacks: 1,
    icon: 'arrow-right-left',
    isBackwards: false,
    registerHooks() {
      registerItemHook('onWordAssign', this.id, (stacks, word, enemy) => {
        ITEMS.babel_toll.isBackwards = Math.random() < 0.25;
        if (ITEMS.babel_toll.isBackwards) {
          return word.split('').reverse().join('');
        }
        return word;
      });
      registerItemHook('onWordComplete', this.id, (stacks, word, enemy, damage) => {
        if (ITEMS.babel_toll.isBackwards) {
          spawnParticles(player.x, player.y, 10, '#ff00ff');
          return damage * 5;
        }
        return damage;
      });
    }
  };

  // --- [SEC:ITEMS:SYNERGIES] SYNERGIES ---
  const SYNERGIES = {};

  SYNERGIES.pinball_wizard = {
    id: 'pinball_wizard',
    name: 'PINBALL WIZARD',
    description: 'Bounces accelerate projectiles!',
    check: () => hasItem('rubber_letters') && hasItem('ricochet_rune'),
    onActivate() {
      this.active = true;
    },
    onDeactivate() {
      this.active = false;
    }
  };

  // Player inventory: { itemId: stackCount }
  let inventory = {};

  // Active synergies
  let activeSynergies = new Set();

  // Item event hooks
  const itemHooks = {
    onKeyPress: [],        // (key, isCorrect) => void
    onWordComplete: [],    // (word, enemy, damage) => newDamage
    onProjectileCreate: [], // (projectile) => void
    onProjectileHit: [],   // (projectile, enemy) => { preventRelease?: bool }
    onProjectileUpdate: [], // (projectile, dt) => void
    onEnemyKill: [],       // (enemy, projectile) => void
    onDamageTaken: [],     // (damage) => newDamage
    onDeath: [],           // () => { prevent?: bool, respawnHP?: number }
    onUpdate: [],          // (dt) => void
    onWaveStart: [],       // (waveNumber) => void
    onWordAssign: [],      // (word, enemy) => newWord
  };

  // Helper to register item hooks
  function registerItemHook(hookName, itemId, callback) {
    if (!itemHooks[hookName]) return;
    itemHooks[hookName].push({ itemId, callback });
  }

  // Helper to call all hooks of a type
  function callHooks(hookName, ...args) {
    if (!itemHooks[hookName]) return args[0];
    let result = args[0];
    for (const hook of itemHooks[hookName]) {
      const stacks = inventory[hook.itemId] || 0;
      if (stacks > 0) {
        const hookResult = hook.callback(stacks, ...args);
        if (hookResult !== undefined && hookResult !== null) result = hookResult;
      }
    }
    return result;
  }

  // Special function for onWordComplete that collects damage multipliers
  function callWordCompleteHooks(word, enemy) {
    if (!itemHooks['onWordComplete']) return 1;
    let damageMultiplier = 1;
    for (const hook of itemHooks['onWordComplete']) {
      const stacks = inventory[hook.itemId] || 0;
      if (stacks > 0) {
        const hookResult = hook.callback(stacks, word, enemy, damageMultiplier);
        // Only update if hook returns a valid positive number (guards against NaN propagation)
        if (typeof hookResult === 'number' && !isNaN(hookResult) && hookResult > 0) {
          damageMultiplier = hookResult;
        }
      }
    }
    return Math.min(damageMultiplier, 20);
  }

  // Get item stack count
  function getItemStacks(itemId) {
    return inventory[itemId] || 0;
  }

  // Check if player has item
  function hasItem(itemId) {
    return getItemStacks(itemId) > 0;
  }

  // Add item to inventory
  function addItem(itemId, skipNotification = false) {
    const item = ITEMS[itemId];
    if (!item) return false;

    const currentStacks = inventory[itemId] || 0;
    if (item.maxStacks && currentStacks >= item.maxStacks) return false;

    inventory[itemId] = currentStacks + 1;

    // Initialize item if first stack
    if (currentStacks === 0 && item.onAcquire) {
      item.onAcquire();
    }

    // Check for new synergies
    checkSynergies();

    // Play pickup sound
    playItemPickupSound();

    // Show notification (unless skipped, e.g., from item selector)
    if (!skipNotification) {
      showItemNotification(item);
    }

    // Update inventory display
    updateInventoryDisplay();

    return true;
  }

  // Remove item from inventory
  function removeItem(itemId) {
    if (!inventory[itemId]) return false;
    inventory[itemId]--;
    if (inventory[itemId] <= 0) {
      delete inventory[itemId];
    }
    checkSynergies();
    updateInventoryDisplay();
    return true;
  }

  // Show item pickup notification (using safe DOM methods)
  function showItemNotification(item) {
    console.log('showItemNotification called for:', item.name, item);
    const tier = ITEM_TIERS[item.tier];
    const stacks = inventory[item.id];
    console.log('tier:', tier, 'stacks:', stacks);

    // Show first-time item tips (only on first pickup, not stacks)
    // If showing a category tip, skip the item notification entirely
    if (stacks === 1) {
      // Detect if item is "active" (triggers on player actions) vs "passive"
      // Active items have onKeyPress or onWordComplete as their primary trigger
      const itemHooksStr = item.registerHooks ? item.registerHooks.toString() : '';
      const isActiveItem = itemHooksStr.includes('onKeyPress') || itemHooksStr.includes('onWordComplete');

      let categoryTipShown = false;
      if (isActiveItem) {
        categoryTipShown = showTip('active_item', item);
      } else {
        categoryTipShown = showTip('passive_item', item);
      }

      // If we showed a category tip, skip the item notification
      // The tip modal already shows the item and pauses the game
      if (categoryTipShown) {
        return;
      }
    } else {
      // Stacks > 1: player already has this item, don't show notification
      return;
    }

    // Add to notification queue (only reaches here on first pickup)
    itemNotificationQueue.push({ item, tier, stacks });

    // If this is the only notification, display it immediately
    if (itemNotificationQueue.length === 1) {
      displayNextItemNotification();
    }
  }

  // Display the next item notification from the queue
  function displayNextItemNotification() {
    if (itemNotificationQueue.length === 0) {
      itemNotificationActive = false;
      currentItemNotification = null;
      return;
    }

    // Pause game while notifications are shown
    itemNotificationActive = true;

    const { item, tier, stacks } = itemNotificationQueue[0];

    const notification = document.createElement('div');
    notification.className = 'item-notification';
    notification.style.borderColor = tier.color;
    notification.style.boxShadow = '0 0 30px ' + tier.glow;

    // Item icon (prominently displayed - Lucide)
    const iconDiv = document.createElement('div');
    iconDiv.className = 'item-icon';
    iconDiv.style.color = tier.color;
    iconDiv.appendChild(createIconElement(item.icon || 'help-circle'));
    notification.appendChild(iconDiv);

    // Tier badge
    const tierBadge = document.createElement('div');
    tierBadge.className = 'tier-badge';
    tierBadge.style.backgroundColor = tier.color;
    tierBadge.style.color = '#000';
    tierBadge.textContent = tier.name;
    notification.appendChild(tierBadge);

    // Item name
    const nameH3 = document.createElement('h3');
    nameH3.style.color = tier.color;
    nameH3.textContent = item.name;
    notification.appendChild(nameH3);

    // Description (what the item does)
    const descP = document.createElement('p');
    descP.className = 'description';
    descP.textContent = item.description;
    notification.appendChild(descP);

    // Stack effect (how stacking changes the item)
    if (item.stackEffect) {
      const stackEffectP = document.createElement('p');
      stackEffectP.className = 'stack-effect';
      stackEffectP.textContent = 'Stack: ' + item.stackEffect;
      notification.appendChild(stackEffectP);
    }

    // Stack count (if we have more than 1)
    if (stacks > 1) {
      const stackDiv = document.createElement('div');
      stackDiv.className = 'stack-count';
      stackDiv.textContent = 'x' + stacks + ' stacks';
      notification.appendChild(stackDiv);
    }

    // Show queue count if more items pending
    if (itemNotificationQueue.length > 1) {
      const queueHint = document.createElement('p');
      queueHint.className = 'queue-hint';
      queueHint.textContent = '+' + (itemNotificationQueue.length - 1) + ' more item' + (itemNotificationQueue.length > 2 ? 's' : '');
      queueHint.style.color = '#888';
      queueHint.style.fontSize = '12px';
      queueHint.style.marginTop = '5px';
      notification.appendChild(queueHint);
    }

    // Add "Press any key" hint
    const keyHint = document.createElement('p');
    keyHint.className = 'key-hint-text';
    keyHint.textContent = 'Press any key to continue';
    notification.appendChild(keyHint);

    document.body.appendChild(notification);
    currentItemNotification = notification;

    // Render Lucide icons
    if (typeof lucide !== 'undefined') lucide.createIcons();

    // Play sound
    playItemSound(item.tier);

    // Remove on any keypress (but tip modal takes priority if open)
    const dismissNotification = (e) => {
      // If tip modal is open, dismiss that first instead
      if (typeof isTipOpen === 'function' && isTipOpen()) {
        dismissTip();
        return;
      }

      // Remove this notification
      notification.classList.add('fade-out');
      setTimeout(() => notification.remove(), 300);
      document.removeEventListener('keydown', dismissNotification);

      // Remove from queue and show next
      itemNotificationQueue.shift();
      setTimeout(() => {
        displayNextItemNotification();
      }, 150); // Small delay between notifications
    };

    // Small delay before allowing dismissal (so you can read it)
    setTimeout(() => {
      document.addEventListener('keydown', dismissNotification);
    }, 300);
  }

  // Show synergy activation notification
  function showSynergyNotification(synergy) {
    const notification = document.createElement('div');
    notification.className = 'synergy-notification';

    const nameH2 = document.createElement('h2');
    nameH2.textContent = '\u26A1 ' + synergy.name + ' \u26A1';
    notification.appendChild(nameH2);

    const descP = document.createElement('p');
    descP.textContent = synergy.description;
    notification.appendChild(descP);

    document.body.appendChild(notification);
    playSynergySound();

    setTimeout(() => {
      notification.classList.add('fade-out');
      setTimeout(() => notification.remove(), 300);
    }, 3000);
  }

  // Item pickup sound (varies by tier)
  function playItemSound(tier) {
    if (!audioCtx) return;
    const freqs = {
      WHITE: [400, 500],
      GREEN: [500, 600, 700],
      RED: [600, 800, 1000],
      LEGENDARY: [200, 400, 600, 800, 1000, 1200, 1400]
    };
    const notes = freqs[tier] || freqs.WHITE;
    notes.forEach((f, i) => {
      setTimeout(() => playTone(f, 0.15, 'sine', 0.12), i * 60);
    });
  }

  // Synergy activation sound
  function playSynergySound() {
    if (!audioCtx) return;
    [400, 500, 600, 800, 1000, 1200].forEach((f, i) => {
      setTimeout(() => playTone(f, 0.2, 'sine', 0.15), i * 50);
    });
    setTimeout(() => playTone(1600, 0.5, 'sine', 0.2), 300);
  }

  // --- [SEC:ITEMS:PENDING] PENDING ITEMS QUEUE SYSTEM ---
  // Non-blocking item choice queue - each entry is a choice of 3 items

  // Check if adding an item would complete a synergy
  function checkWouldCreateSynergy(itemId) {
    for (const [id, synergy] of Object.entries(SYNERGIES)) {
      if (activeSynergies.has(id)) continue; // Already active
      // Temporarily add item to check
      const prevCount = inventory[itemId] || 0;
      inventory[itemId] = prevCount + 1;
      const wouldActivate = synergy.check();
      // Restore
      if (prevCount === 0) {
        delete inventory[itemId];
      } else {
        inventory[itemId] = prevCount;
      }
      if (wouldActivate) return synergy.name;
    }
    return null;
  }

  // Generate 3 random item choices (tries to get variety)
  function generateItemChoices() {
    const choices = [];
    const usedIds = new Set();

    for (let i = 0; i < 3; i++) {
      let item = null;
      let attempts = 0;

      // Try to get an item we haven't already offered
      while (attempts < 10) {
        item = getRandomItem();
        if (item && !usedIds.has(item.id)) {
          usedIds.add(item.id);
          break;
        }
        attempts++;
      }

      if (item) {
        const currentStacks = inventory[item.id] || 0;
        const isUpgrade = currentStacks > 0;
        const canUpgrade = !item.maxStacks || currentStacks < item.maxStacks;
        choices.push({
          item,
          isUpgrade,
          canUpgrade,
          currentStacks,
          wouldCreateSynergy: checkWouldCreateSynergy(item.id)
        });
      }
    }

    return choices;
  }

  // Queue an item choice for later collection (non-blocking)
  function queueItemChoice() {
    const choices = generateItemChoices();
    if (choices.length === 0) return;

    pendingItems.push({
      choices,
      timestamp: Date.now()
    });
    updatePendingWidget();

    // Show first item drop tip (tips system handles showing only once)
    showTip('item_drop');

    // Play subtle queue sound (short chirp)
    if (audioCtx) {
      playTone(500, 0.05, 'sine', 0.1);
      setTimeout(() => playTone(600, 0.05, 'sine', 0.08), 50);
    }
  }

  // Update the pending items widget visibility and count
  function updatePendingWidget() {
    const widget = document.getElementById('pendingItemsWidget');
    const countEl = document.getElementById('pendingItemsCount');
    if (!widget || !countEl) return;

    if (pendingItems.length > 0) {
      widget.classList.remove('hidden');
      widget.classList.add('has-items');
      const label = pendingItems.length === 1 ? '1 DROP' : pendingItems.length + ' DROPS';
      countEl.textContent = label;
    } else {
      widget.classList.add('hidden');
      widget.classList.remove('has-items');
    }
  }

  // Open collection menu to review and collect pending items
  function openCollectionMenu() {
    if (pendingItems.length === 0) return;
    collectionMenuOpen = true;
    gameState = 'collecting';
    exitWhiteSpace();
    renderCollectionList();
    document.getElementById('collectionMenu').classList.remove('hidden');
  }

  // Close collection menu and resume gameplay
  function closeCollectionMenu() {
    collectionMenuOpen = false;
    document.getElementById('collectionMenu').classList.add('hidden');
    if (pendingItems.length === 0 || gameState === 'collecting') {
      gameState = 'playing';
      lastTime = performance.now();
      requestAnimationFrame(gameLoop);
    }
  }

  // Render the list of pending item choices in the collection menu
  function renderCollectionList() {
    const list = document.getElementById('collectionList');
    if (!list) return;

    // Clear using safe method
    list.textContent = '';

    if (pendingItems.length === 0) {
      const emptyMsg = document.createElement('p');
      emptyMsg.textContent = 'No items pending!';
      emptyMsg.style.textAlign = 'center';
      emptyMsg.style.color = 'var(--muted)';
      list.appendChild(emptyMsg);
      return;
    }

    // Render each pending choice
    pendingItems.forEach((pending, choiceIndex) => {
      const choiceContainer = document.createElement('div');
      choiceContainer.className = 'choice-container';

      // Choice header
      const choiceHeader = document.createElement('div');
      choiceHeader.className = 'choice-header';
      choiceHeader.textContent = 'ITEM DROP ' + (choiceIndex + 1) + ' — Choose one:';
      choiceContainer.appendChild(choiceHeader);

      // Choice options grid
      const optionsGrid = document.createElement('div');
      optionsGrid.className = 'choice-options';

      pending.choices.forEach((choice, optionIndex) => {
        const item = choice.item;
        const tier = ITEM_TIERS[item.tier];

        const optionEl = document.createElement('div');
        optionEl.className = 'choice-option';
        optionEl.style.borderColor = tier.color;

        // Make the whole option clickable
        optionEl.addEventListener('click', () => selectItemChoice(choiceIndex, optionIndex));

        // Icon
        const iconDiv = document.createElement('div');
        iconDiv.className = 'choice-option-icon';
        iconDiv.style.backgroundColor = tier.color + '22';
        iconDiv.appendChild(createIconElement(item.icon || 'package'));
        optionEl.appendChild(iconDiv);

        // Info section
        const infoDiv = document.createElement('div');
        infoDiv.className = 'choice-option-info';

        // Name with badges
        const nameRow = document.createElement('div');
        nameRow.className = 'choice-option-name';
        nameRow.style.color = tier.color;

        const nameText = document.createElement('span');
        nameText.textContent = item.name;
        nameRow.appendChild(nameText);

        // Upgrade badge
        if (choice.isUpgrade) {
          const upgradeBadge = document.createElement('span');
          upgradeBadge.className = 'upgrade-badge';
          upgradeBadge.textContent = 'UPGRADE';
          if (!choice.canUpgrade) {
            upgradeBadge.classList.add('maxed');
            upgradeBadge.textContent = 'MAX';
          }
          nameRow.appendChild(upgradeBadge);
        } else {
          const newBadge = document.createElement('span');
          newBadge.className = 'new-badge';
          newBadge.textContent = 'NEW';
          nameRow.appendChild(newBadge);
        }

        infoDiv.appendChild(nameRow);

        // Description
        const descEl = document.createElement('div');
        descEl.className = 'choice-option-desc';
        descEl.textContent = item.description;
        infoDiv.appendChild(descEl);

        // Tier and stack info
        const metaRow = document.createElement('div');
        metaRow.className = 'choice-option-meta';

        const tierText = document.createElement('span');
        tierText.className = 'choice-tier';
        tierText.style.color = tier.color;
        tierText.textContent = tier.name;
        metaRow.appendChild(tierText);

        if (choice.isUpgrade && choice.currentStacks > 0) {
          const stackText = document.createElement('span');
          stackText.className = 'choice-stacks';
          stackText.textContent = 'x' + choice.currentStacks + ' → x' + (choice.currentStacks + 1);
          metaRow.appendChild(stackText);
        }

        if (choice.wouldCreateSynergy) {
          const synergyBadge = document.createElement('span');
          synergyBadge.className = 'synergy-badge';
          synergyBadge.textContent = '✨ ' + choice.wouldCreateSynergy;
          metaRow.appendChild(synergyBadge);
        }

        infoDiv.appendChild(metaRow);
        optionEl.appendChild(infoDiv);

        // Disable if maxed
        if (choice.isUpgrade && !choice.canUpgrade) {
          optionEl.classList.add('disabled');
        }

        optionsGrid.appendChild(optionEl);
      });

      choiceContainer.appendChild(optionsGrid);
      list.appendChild(choiceContainer);
    });

    // Refresh Lucide icons
    if (typeof lucide !== 'undefined') {
      lucide.createIcons({ nodes: list.querySelectorAll('[data-lucide]') });
    }
  }

  // Select one item from a choice
  function selectItemChoice(choiceIndex, optionIndex) {
    if (choiceIndex < 0 || choiceIndex >= pendingItems.length) return;

    const pending = pendingItems[choiceIndex];
    const choice = pending.choices[optionIndex];
    if (!choice) return;

    // Check if item is maxed
    if (choice.isUpgrade && !choice.canUpgrade) return;

    const item = choice.item;
    const wasFirstStack = !inventory[item.id];

    // Add item to inventory, skip the old notification
    addItem(item.id, true);

    // Show first-time category tip if applicable
    if (wasFirstStack) {
      const itemHooksStr = item.registerHooks ? item.registerHooks.toString() : '';
      const isActiveItem = itemHooksStr.includes('onKeyPress') || itemHooksStr.includes('onWordComplete');
      if (isActiveItem) {
        showTip('active_item', item);
      } else {
        showTip('passive_item', item);
      }
    }

    // Play pickup sound
    playItemSound(item.tier);

    // Remove this choice from queue
    pendingItems.splice(choiceIndex, 1);
    renderCollectionList();
    updatePendingWidget();

    // Close menu if no more items
    if (pendingItems.length === 0) {
      closeCollectionMenu();
    }
  }

  // Collect all pending items at once (auto-selects first valid option from each)
  function collectAllItems() {
    while (pendingItems.length > 0) {
      const pending = pendingItems[0];
      // Find first valid choice (not maxed)
      let selectedChoice = null;
      for (const choice of pending.choices) {
        if (!choice.isUpgrade || choice.canUpgrade) {
          selectedChoice = choice;
          break;
        }
      }

      if (selectedChoice) {
        const wasFirstStack = !inventory[selectedChoice.item.id];
        addItem(selectedChoice.item.id, true);

        // Only show tip for the last collected item to avoid spam
        if (pendingItems.length === 1 && wasFirstStack) {
          const itemHooksStr = selectedChoice.item.registerHooks ? selectedChoice.item.registerHooks.toString() : '';
          const isActiveItem = itemHooksStr.includes('onKeyPress') || itemHooksStr.includes('onWordComplete');
          if (isActiveItem) {
            showTip('active_item', selectedChoice.item);
          } else {
            showTip('passive_item', selectedChoice.item);
          }
        }
      }

      pendingItems.shift();
    }
    // Play a combined pickup sound
    if (audioCtx) {
      [400, 500, 600, 800].forEach((f, i) => {
        setTimeout(() => playTone(f, 0.1, 'sine', 0.12), i * 40);
      });
    }
    updatePendingWidget();
    closeCollectionMenu();
  }

  // --- [SEC:ITEMS:SYNERGIES:SYSTEM] SYNERGY SYSTEM ---
  // Check all synergies when inventory changes
  function checkSynergies() {
    for (const [id, synergy] of Object.entries(SYNERGIES)) {
      const wasActive = activeSynergies.has(id);
      const isActive = synergy.check();

      if (isActive && !wasActive) {
        activeSynergies.add(id);
        if (synergy.onActivate) synergy.onActivate();
        showSynergyNotification(synergy);
      } else if (!isActive && wasActive) {
        activeSynergies.delete(id);
        if (synergy.onDeactivate) synergy.onDeactivate();
      }
    }
  }

  // Check if synergy is active
  function hasSynergy(synergyId) {
    return activeSynergies.has(synergyId);
  }

  // Helper: check if player has all required items
  function hasAllItems(itemIds) {
    return itemIds.every(id => hasItem(id));
  }

  // --- [SEC:ITEMS:DROPS] ITEM DROPS ---

  // --- [SEC:ITEMS:DROPS:WEIGHTS] Drop Weights & Probability ---
  let itemDropCounter = 0;
  const ITEM_DROP_INTERVAL = 8; // Every N kills, drop an item
  const itemDrops = [];

  // Get random item by tier weights
  function getRandomItem(forceTier = null) {
    let tier = forceTier;

    if (!tier) {
      const roll = Math.random() * 100;
      let cumulative = 0;

      for (const [tierName, tierData] of Object.entries(ITEM_TIERS)) {
        cumulative += tierData.dropWeight;
        if (roll < cumulative) {
          tier = tierName;
          break;
        }
      }
    }

    const tierItems = Object.values(ITEMS).filter(item => item.tier === tier);
    if (tierItems.length === 0) return null;

    const available = tierItems.filter(item => {
      const stacks = inventory[item.id] || 0;
      return !item.maxStacks || stacks < item.maxStacks;
    });

    if (available.length === 0) return null;
    return available[Math.floor(Math.random() * available.length)];
  }

  // Spawn item drop at position
  function spawnItemDrop(x, y, item) {
    if (!item) return;
    itemDrops.push({
      x, y,
      item,
      radius: 20,
      bobOffset: Math.random() * Math.PI * 2,
      lifetime: 30
    });
  }

  // Check item pickup only (used during white space when time is frozen)
  function checkItemPickup() {
    for (let i = itemDrops.length - 1; i >= 0; i--) {
      const drop = itemDrops[i];
      const dist = Math.hypot(drop.x - player.x, drop.y - player.y);
      if (dist < player.radius + drop.radius) {
        if (addItem(drop.item.id)) {
          itemDrops.splice(i, 1);
        }
      }
    }
  }

  // Check gem pickup only (used during white space when time is frozen)
  function checkGemPickup() {
    gems.forEach(g => {
      const dist = Math.hypot(g.x - player.x, g.y - player.y);
      if (dist < CONFIG.GEM_COLLECT_RANGE) {
        player.xp += g.value;
        spawnDamageNumber(g.x, g.y, g.value, 'xp');
        gems.release(g);
        playXPSound();
        checkLevelUp();
      }
    });
  }

  // Update item drops
  function updateItemDrops(dt) {
    for (let i = itemDrops.length - 1; i >= 0; i--) {
      const drop = itemDrops[i];
      drop.lifetime -= dt;

      if (drop.lifetime <= 0) {
        itemDrops.splice(i, 1);
        continue;
      }

      const dist = Math.hypot(drop.x - player.x, drop.y - player.y);
      if (dist < player.radius + drop.radius) {
        if (addItem(drop.item.id)) {
          itemDrops.splice(i, 1);
        }
      }
    }
  }

  // Draw item drops - flat style
  function drawItemDrops() {
    for (const drop of itemDrops) {
      const tier = ITEM_TIERS[drop.item.tier];
      const bob = Math.sin(performance.now() / 300 + drop.bobOffset) * 4;

      // Simple filled circle with tier color
      ctx.fillStyle = tier.color;
      ctx.beginPath();
      ctx.arc(drop.x, drop.y + bob, drop.radius, 0, Math.PI * 2);
      ctx.fill();

      // Border
      ctx.strokeStyle = CONFIG.COLORS.PAPER;
      ctx.lineWidth = 2;
      ctx.stroke();
    }
  }

  // Check for item drop on kill
  function checkItemDrop(enemy) {
    itemDropCounter++;
    if (itemDropCounter >= ITEM_DROP_INTERVAL) {
      itemDropCounter = 0;

      // Queue a choice of 3 items for non-blocking collection
      queueItemChoice();
    }
  }

  // --- [SEC:ITEMS:NOTIFY] Notifications & Pickups ---
  // Update inventory display (using safe DOM methods)
  function updateInventoryDisplay() {
    const container = document.getElementById('inventoryDisplay');
    if (!container) return;

    container.textContent = '';

    for (const [itemId, stacks] of Object.entries(inventory)) {
      const item = ITEMS[itemId];
      if (!item) continue;

      const tier = ITEM_TIERS[item.tier];

      const el = document.createElement('div');
      el.className = 'inventory-item';
      applyTierStyle(el, tier);

      // Use Lucide icon instead of text
      const iconEl = createIconElement(item.icon || 'help-circle');
      el.appendChild(iconEl);

      if (stacks > 1) {
        const stackSpan = document.createElement('span');
        stackSpan.className = 'stack';
        stackSpan.textContent = stacks;
        el.appendChild(stackSpan);
      }

      const tooltip = document.createElement('div');
      tooltip.className = 'tooltip';

      const tooltipName = document.createElement('h4');
      tooltipName.style.color = tier.color;
      tooltipName.textContent = item.name;
      tooltip.appendChild(tooltipName);

      const tooltipDesc = document.createElement('p');
      tooltipDesc.textContent = item.description;
      tooltip.appendChild(tooltipDesc);

      el.appendChild(tooltip);
      container.appendChild(el);
    }

    // Refresh Lucide icons for the newly added elements
    if (typeof lucide !== 'undefined') {
      lucide.createIcons({ nodes: container.querySelectorAll('[data-lucide]') });
    }

    // Also update active/passive displays
    updateActiveItemsDisplay();
    updatePassiveItemsDisplay();
  }

  // Detect if running on Mac
  const isMac = navigator.platform.toUpperCase().indexOf('MAC') >= 0;

  // Active items - ones with button or status to show
  const ACTIVE_ITEMS = {
    backspace_item: { key: '⌫', keyName: 'Backspace', hasCooldown: true },
    ctrl_z: { key: isMac ? '⌘Z' : '⌃Z', keyName: isMac ? 'Cmd+Z' : 'Ctrl+Z', oneUse: true },
    bookmark: { key: 'AUTO', keyName: 'On Death', oneUse: true }
  };

  // Passive items with cooldowns
  const PASSIVE_COOLDOWN_ITEMS = ['spellcheck', 'invisible_ink', 'tab_complete'];

  // Passive items with word counters (charge-up mechanics)
  const PASSIVE_COUNTER_ITEMS = [
    { id: 'chain_letter', getCount: () => ITEMS.chain_letter.wordCount, getMax: (stacks) => 10 },
    { id: 'footnote', getCount: () => ITEMS.footnote.wordCount, getMax: (stacks) => Math.max(2, 5 - (stacks - 1)) },
    { id: 'bold_statement', getCount: () => ITEMS.bold_statement.wordCount, getMax: (stacks) => Math.max(3, 10 - (stacks - 1)) },
    { id: 'hardcover', getCount: () => ITEMS.hardcover.wordsTyped, getMax: (stacks) => Math.max(2, 10 - (stacks - 1) * 2) }
  ];

  // Item Hover Tooltip System
  const itemHoverTooltip = document.getElementById('itemHoverTooltip');
  let hoverTooltipTimeout = null;

  function showItemHoverTooltip(itemId, slotElement) {
    const item = ITEMS[itemId];
    if (!item || !itemHoverTooltip) return;

    const tier = ITEM_TIERS[item.tier];
    const stacks = inventory[itemId] || 1;

    // Clear any pending hide
    if (hoverTooltipTimeout) {
      clearTimeout(hoverTooltipTimeout);
      hoverTooltipTimeout = null;
    }

    // Build content
    itemHoverTooltip.textContent = '';

    // Name
    const nameEl = document.createElement('div');
    nameEl.className = 'item-hover-tooltip-name';
    nameEl.style.color = tier.color;
    nameEl.textContent = item.icon + ' ' + item.name;
    itemHoverTooltip.appendChild(nameEl);

    // Description
    const descEl = document.createElement('div');
    descEl.className = 'item-hover-tooltip-desc';
    descEl.textContent = item.description;
    itemHoverTooltip.appendChild(descEl);

    // Meta info (stacks, tier, etc.)
    const metaEl = document.createElement('div');
    metaEl.className = 'item-hover-tooltip-meta';
    const metaParts = [tier.name];
    if (stacks > 1) metaParts.push('x' + stacks);
    if (item.stackEffect && stacks > 1) metaParts.push(item.stackEffect);
    metaEl.textContent = metaParts.join(' \u2022 ');
    itemHoverTooltip.appendChild(metaEl);

    // Set border color
    itemHoverTooltip.style.borderColor = tier.color;

    // Position above the slot
    const rect = slotElement.getBoundingClientRect();
    const tooltipRect = itemHoverTooltip.getBoundingClientRect();

    // Calculate position
    let left = rect.left + rect.width / 2 - 120; // Center (240px / 2 = 120)
    let top = rect.top - 10; // Position above with gap

    // Keep tooltip on screen
    left = Math.max(10, Math.min(left, window.innerWidth - 250));

    // If tooltip would go off top of screen, show below instead
    if (top < 100) {
      top = rect.bottom + 10;
    } else {
      // Estimate tooltip height and position above
      top = rect.top - 90; // Approximate height
    }

    itemHoverTooltip.style.left = left + 'px';
    itemHoverTooltip.style.top = top + 'px';

    // Show
    itemHoverTooltip.classList.add('visible');
  }

  function hideItemHoverTooltip() {
    if (!itemHoverTooltip) return;

    // Small delay for smoother UX
    hoverTooltipTimeout = setTimeout(() => {
      itemHoverTooltip.classList.remove('visible');
    }, 50);
  }

  function updateActiveItemsDisplay() {
    const container = document.getElementById('activeItems');
    if (!container) return;

    container.textContent = '';

    for (const [itemId, config] of Object.entries(ACTIVE_ITEMS)) {
      if (!inventory[itemId]) continue;

      const item = ITEMS[itemId];
      const tier = ITEM_TIERS[item.tier];
      const slot = document.createElement('div');
      slot.className = 'item-slot active-slot';
      applyTierStyle(slot, tier);

      // Check if ready to use
      let isReady = true;
      let cooldownText = '';
      let usesLeft = null;

      if (itemId === 'backspace_item' && item.canUse) {
        isReady = item.canUse();
        if (!isReady) {
          const stacks = inventory[itemId] || 0;
          const cooldown = Math.max(2, 10 - (stacks - 1) * 2) * 1000;
          const elapsed = performance.now() - item.lastUsed;
          const remaining = Math.ceil((cooldown - elapsed) / 1000);
          cooldownText = remaining + 's';
        }
      }

      if (itemId === 'ctrl_z') {
        isReady = !item.used;
        usesLeft = item.used ? 0 : 1;
      }

      if (itemId === 'bookmark' && item) {
        usesLeft = item.used ? 0 : 1;
        isReady = !item.used;
      }

      slot.classList.add(isReady ? 'ready' : 'on-cooldown');

      // Icon (Lucide)
      const iconEl = createIconElement(item.icon || 'help-circle');
      slot.appendChild(iconEl);

      // Cooldown progress ring
      const ring = document.createElement('div');
      ring.className = 'cooldown-ring';
      ring.innerHTML = '<svg viewBox="0 0 44 44"><circle cx="22" cy="22" r="20"/></svg>';
      slot.appendChild(ring);

      // Stack badge
      const activeStacks = inventory[itemId] || 1;
      if (activeStacks > 1) {
        const badge = document.createElement('span');
        badge.className = 'stack-badge';
        badge.textContent = activeStacks;
        slot.appendChild(badge);
      }

      // Key hint
      const keyHint = document.createElement('div');
      keyHint.className = 'key-hint';
      keyHint.textContent = config.key;
      slot.appendChild(keyHint);

      // Cooldown overlay
      if (cooldownText) {
        const overlay = document.createElement('div');
        overlay.className = 'cooldown-overlay';
        overlay.textContent = cooldownText;
        slot.appendChild(overlay);
      }

      // Uses left indicator
      if (usesLeft !== null) {
        const uses = document.createElement('div');
        uses.className = 'uses-left';
        uses.textContent = '';
        const useIcon = createIconElement(usesLeft > 0 ? 'circle-dot' : 'circle');
        useIcon.style.width = '10px';
        useIcon.style.height = '10px';
        uses.appendChild(useIcon);
        slot.appendChild(uses);
      }

      // Mobile tap handler for active items
      if (itemId === 'backspace_item') {
        slot.addEventListener('click', (e) => {
          e.stopPropagation();
          if (gameState === 'playing' && item.canUse && item.canUse()) {
            item.use();
            updateActiveItemsDisplay();
          }
        });
        slot.addEventListener('touchstart', (e) => {
          e.stopPropagation(); // Prevent player movement
        }, { passive: true });
      }

      // Hover tooltip events
      slot.dataset.itemId = itemId;
      slot.addEventListener('mouseenter', () => showItemHoverTooltip(itemId, slot));
      slot.addEventListener('mouseleave', hideItemHoverTooltip);

      container.appendChild(slot);
    }

    // Render Lucide icons
    if (typeof lucide !== 'undefined') lucide.createIcons();
  }

  function updatePassiveItemsDisplay() {
    const container = document.getElementById('passiveItems');
    if (!container) return;

    container.textContent = '';

    for (const itemId of PASSIVE_COOLDOWN_ITEMS) {
      if (!inventory[itemId]) continue;

      const item = ITEMS[itemId];
      const tier = ITEM_TIERS[item.tier];
      const slot = document.createElement('div');
      slot.className = 'item-slot passive-slot';
      applyTierStyle(slot, tier);

      let isReady = true;
      let cooldownText = '';

      if (item.canUse) {
        isReady = item.canUse();
        if (!isReady && item.lastUsed) {
          const stacks = inventory[itemId] || 0;
          let cooldown = 0;

          if (itemId === 'spellcheck') {
            cooldown = Math.max(5, 30 - (stacks - 1) * 5) * 1000;
          } else if (itemId === 'invisible_ink') {
            cooldown = Math.max(3, 15 - (stacks - 1) * 3) * 1000;
          } else if (itemId === 'tab_complete') {
            cooldown = Math.max(4, 20 - (stacks - 1) * 4) * 1000;
          }

          const elapsed = performance.now() - item.lastUsed;
          const remaining = Math.ceil((cooldown - elapsed) / 1000);
          if (remaining > 0) cooldownText = remaining + 's';
        }
      }

      slot.classList.add(isReady ? 'ready' : 'on-cooldown');

      // Icon (Lucide)
      const iconEl = createIconElement(item.icon || 'help-circle');
      slot.appendChild(iconEl);

      // Cooldown progress ring
      const passiveRing = document.createElement('div');
      passiveRing.className = 'cooldown-ring';
      passiveRing.innerHTML = '<svg viewBox="0 0 44 44"><circle cx="22" cy="22" r="20"/></svg>';
      slot.appendChild(passiveRing);

      // Stack badge
      const passiveStacks = inventory[itemId] || 1;
      if (passiveStacks > 1) {
        const badge = document.createElement('span');
        badge.className = 'stack-badge';
        badge.textContent = passiveStacks;
        slot.appendChild(badge);
      }

      // Cooldown overlay
      if (cooldownText) {
        const overlay = document.createElement('div');
        overlay.className = 'cooldown-overlay';
        overlay.textContent = cooldownText;
        slot.appendChild(overlay);
      }

      // Hover tooltip events
      slot.dataset.itemId = itemId;
      slot.addEventListener('mouseenter', () => showItemHoverTooltip(itemId, slot));
      slot.addEventListener('mouseleave', hideItemHoverTooltip);

      container.appendChild(slot);
    }

    // Add counter-based items
    for (const config of PASSIVE_COUNTER_ITEMS) {
      if (!inventory[config.id]) continue;

      const item = ITEMS[config.id];
      const tier = ITEM_TIERS[item.tier];
      const stacks = inventory[config.id] || 1;
      const slot = document.createElement('div');
      slot.className = 'item-slot passive-slot counter-slot';
      applyTierStyle(slot, tier);

      const currentCount = config.getCount();
      const maxCount = config.getMax(stacks);
      const progress = currentCount / maxCount;

      // Add ready class when about to trigger
      if (progress >= 0.8) {
        slot.classList.add('almost-ready');
      }

      // Icon (Lucide)
      const iconEl = createIconElement(item.icon || 'help-circle');
      slot.appendChild(iconEl);

      // Counter display
      const counter = document.createElement('div');
      counter.className = 'counter-display';
      counter.textContent = currentCount + '/' + maxCount;
      slot.appendChild(counter);

      // Progress bar
      const progressBar = document.createElement('div');
      progressBar.className = 'counter-progress';
      progressBar.style.width = (progress * 100) + '%';
      slot.appendChild(progressBar);

      // Hover tooltip events
      slot.dataset.itemId = config.id;
      slot.addEventListener('mouseenter', () => showItemHoverTooltip(config.id, slot));
      slot.addEventListener('mouseleave', hideItemHoverTooltip);

      container.appendChild(slot);
    }

    // Render Lucide icons
    if (typeof lucide !== 'undefined') lucide.createIcons();
  }

  // Reset item system state
  function resetItemSystem() {
    inventory = {};
    activeSynergies = new Set();
    itemDrops.length = 0;
    itemDropCounter = 0;

    // Clear item effect arrays
    marginNotes.length = 0;
    inkPools.length = 0;

    // Reset item-specific states - WHITE tier
    if (ITEMS.bookmark) ITEMS.bookmark.used = false;
    if (ITEMS.footnote) ITEMS.footnote.wordCount = 0;
    if (ITEMS.spellcheck) ITEMS.spellcheck.lastUsed = 0;
    if (ITEMS.consonant_cruelty) ITEMS.consonant_cruelty.consonantCount = 0;

    // Reset item-specific states - GREEN tier
    if (ITEMS.ghostwriter) ITEMS.ghostwriter.lastAutoType = 0;
    if (ITEMS.hardcover) { ITEMS.hardcover.wordsTyped = 0; ITEMS.hardcover.armor = 0; }
    if (ITEMS.invisible_ink) { ITEMS.invisible_ink.lastUsed = 0; ITEMS.invisible_ink.invisibleUntil = 0; }
    if (ITEMS.backspace_item) ITEMS.backspace_item.lastUsed = 0;
    if (ITEMS.ellipsis) { ITEMS.ellipsis.lastKeyTime = 0; ITEMS.ellipsis.charged = false; }
    if (ITEMS.chain_letter) ITEMS.chain_letter.wordCount = 0;

    // Reset item-specific states - RED tier
    if (ITEMS.damage_aura) ITEMS.damage_aura.lastDamage = 0;
    if (ITEMS.hemingway) ITEMS.hemingway.wordCount = 0;
    if (ITEMS.proust) ITEMS.proust.wordCount = 0;
    if (ITEMS.monkey_typewriter) { /* No state to reset */ }
    if (ITEMS.ctrl_z) { ITEMS.ctrl_z.used = false; ITEMS.ctrl_z.stateHistory = []; ITEMS.ctrl_z.lastSave = 0; }
    if (ITEMS.critical_letter) ITEMS.critical_letter.critLetterIndex = -1;
    if (ITEMS.bold_statement) ITEMS.bold_statement.wordCount = 0;
    if (ITEMS.tab_complete) ITEMS.tab_complete.lastUsed = 0;

    // Reset item-specific states - LEGENDARY tier
    if (ITEMS.blood_ink) ITEMS.blood_ink.acquired = false;
    if (ITEMS.babel_toll) ITEMS.babel_toll.isBackwards = false;

    updateInventoryDisplay();

    // Clear and re-register hooks
    for (const hookName in itemHooks) {
      itemHooks[hookName] = [];
    }
    for (const item of Object.values(ITEMS)) {
      if (item.registerHooks) item.registerHooks();
    }
  }

  let currentWord = '';
  let typedIndex = 0;
  let targetEnemy = null;
  let firedAtEnemies = new Set(); // Track enemies with bullets headed their way
  let footnoteNeedsSpace = false; // Require space between footnote sentence words

  function getRandomWord(difficulty = 'easy') {
    const pool = WORDS[difficulty] || WORDS.easy;
    return pool[Math.floor(Math.random() * pool.length)];
  }

  function getDifficultyForWave(wave) {
    if (wave < 2) return 'easy';
    if (wave < 3) return Math.random() < 0.85 ? 'easy' : 'medium';
    if (wave < 5) return Math.random() < 0.60 ? 'easy' : 'medium';
    if (wave < 7) return Math.random() < 0.35 ? 'easy' : Math.random() < 0.85 ? 'medium' : 'hard';
    if (wave < 10) return Math.random() < 0.15 ? 'easy' : Math.random() < 0.70 ? 'medium' : 'hard';
    if (wave < 13) return Math.random() < 0.30 ? 'medium' : 'hard';
    return 'hard';
  }

  // Check if enemy will die from incoming projectiles
  function willDieFromIncomingProjectiles(enemy) {
    let totalIncomingDamage = 0;
    projectiles.forEach(p => {
      if (p.target === enemy) {
        let damage = p.damage;
        // Account for marked bonus
        if (enemy.marked) damage = Math.ceil(damage * 1.5);
        // Account for crit bonus (conservative - assume it might crit)
        if (p.isCrit) {
          const critStacks = inventory['critical_letter'] || 0;
          if (critStacks > 0) {
            damage = Math.ceil(damage * ITEMS.critical_letter.getCritMultiplier(critStacks));
          }
        }
        totalIncomingDamage += damage;
      }
    });
    return enemy.health <= totalIncomingDamage;
  }

  function assignWordToEnemy() {
    if (currentWord) {
      return; // Already have a word
    }
    footnoteNeedsSpace = false;

    // For footnotes, find the lowest wordIndex for each sentence to enforce order
    // Only consider enemies that are actually available (not in firedAtEnemies)
    const footnoteMinIndices = new Map(); // footnoteNumber -> lowest wordIndex
    enemies.forEach(e => {
      if (e.enemyType === 'footnote' && e.footnoteNumber && !firedAtEnemies.has(e) && !willDieFromIncomingProjectiles(e)) {
        const current = footnoteMinIndices.get(e.footnoteNumber);
        if (current === undefined || e.wordIndex < current) {
          footnoteMinIndices.set(e.footnoteNumber, e.wordIndex);
        }
      }
    });

    let closest = null;
    let minDist = Infinity;

    enemies.forEach(e => {
      // Skip enemies that already have bullets headed their way
      if (firedAtEnemies.has(e)) {
        return;
      }

      // Skip enemies that will die from incoming projectiles
      if (willDieFromIncomingProjectiles(e)) {
        return;
      }

      // For footnotes, only allow targeting the first remaining word in the sentence
      if (e.enemyType === 'footnote' && e.footnoteNumber) {
        const minIndex = footnoteMinIndices.get(e.footnoteNumber);
        if (e.wordIndex !== minIndex) {
          return; // Skip - must kill earlier words first
        }
      }

      const dist = Math.hypot(e.x - player.x, e.y - player.y);
      if (dist < minDist) {
        minDist = dist;
        closest = e;
      }
    });

    if (closest) {
      // Call onWordAssign hook (for Torn Page etc.)
      let word = closest.word;
      word = callHooks('onWordAssign', word, closest) || word;
      currentWord = word;
      typedIndex = 0;
      targetEnemy = closest;

      // Validate Critical Letter index after all transformations
      // (in case word was shortened by another hook after crit index was set)
      if (inventory['critical_letter'] && ITEMS.critical_letter.critLetterIndex >= word.length) {
        ITEMS.critical_letter.critLetterIndex = Math.floor(Math.random() * word.length);
      }

      updateWordDisplay();
    }
  }

  // Assign a follow-up word to an enemy that survived a hit
  function assignFollowUpWord(enemy) {
    const healthPercent = enemy.health / enemy.maxHealth;

    // Word length based on remaining health (lower health = shorter/easier word)
    let maxLength;
    if (healthPercent <= 0.2) {
      maxLength = 3; // Very low health: 2-3 letter words
    } else if (healthPercent <= 0.4) {
      maxLength = 4; // Low health: 3-4 letter words
    } else if (healthPercent <= 0.6) {
      maxLength = 5; // Medium health: 4-5 letter words
    } else {
      maxLength = 6; // Higher health: 4-6 letter words
    }

    // Get appropriate word pool
    const pool = healthPercent <= 0.3 ? WORDS.easy : WORDS.medium;

    // Filter words by length
    const candidates = pool.filter(w => w.length >= 2 && w.length <= maxLength);

    // Pick random word from candidates
    let newWord = candidates[Math.floor(Math.random() * candidates.length)] || 'hit';

    // Apply item hooks (like Torn Page)
    newWord = callHooks('onWordAssign', newWord, enemy) || newWord;

    // Update enemy and current target
    enemy.word = newWord;
    currentWord = newWord;
    typedIndex = 0;

    // Visual feedback
    spawnParticles(enemy.x, enemy.y, 3, '#d4a84b');

    updateWordDisplay();
  }

  // Handle targeting after an enemy dies - auto-targets next footnote in sentence if applicable
  function handleTargetAfterDeath(deadEnemy) {
    // Clear current targeting
    currentWord = '';
    typedIndex = 0;
    targetEnemy = null;

    // Check if dead enemy was a footnote with a sentence
    if (deadEnemy?.enemyType === 'footnote' && deadEnemy.footnoteNumber && deadEnemy.sentenceWords) {
      const footnoteNum = deadEnemy.footnoteNumber;
      const totalWords = deadEnemy.totalWords;

      // Look for next alive enemy in same sentence (may have skipped some from AOE)
      let nextEnemy = null;
      let lowestWordIndex = Infinity;

      enemies.forEach(e => {
        if (e.enemyType === 'footnote' &&
            e.footnoteNumber === footnoteNum &&
            e.wordIndex > deadEnemy.wordIndex &&
            e.wordIndex < lowestWordIndex &&
            !willDieFromIncomingProjectiles(e)) {
          nextEnemy = e;
          lowestWordIndex = e.wordIndex;
        }
      });

      if (nextEnemy) {
        // Auto-target next footnote in sentence
        currentWord = nextEnemy.word;
        typedIndex = 0;
        targetEnemy = nextEnemy;
        footnoteNeedsSpace = true; // Require space between sentence words
        updateWordDisplay();
        return; // Don't call assignWordToEnemy
      }
    }

    // Normal case: assign to nearest enemy
    updateWordDisplay();
    assignWordToEnemy();
  }

  // Safe DOM manipulation helpers
  function setElementText(id, text) {
    const el = document.getElementById(id);
    if (el) el.textContent = text;
  }

  function setElementDisplay(id, show) {
    const el = document.getElementById(id);
    if (el) {
      if (show) el.classList.remove('hidden');
      else el.classList.add('hidden');
    }
  }

  function updateWordDisplay() {
    const display = document.getElementById('wordDisplay');
    const instructions = document.getElementById('instructions');

    // Clear all enemy/elite style classes
    display.className = 'word-display';

    if (!currentWord) {
      display.textContent = '';
      instructions.classList.add('hidden');
      return;
    }

    // Apply enemy type style
    if (targetEnemy) {
      display.classList.add('enemy-' + targetEnemy.enemyType);

      // Apply elite modifier styles
      for (const modId of (targetEnemy.eliteModifiers || [])) {
        display.classList.add('elite-' + modId);
      }
    }

    // Build word display using DOM methods for safety
    display.textContent = '';

    // Check for Critical Letter item
    const critStacks = inventory['critical_letter'] || 0;
    const critIndex = critStacks > 0 ? ITEMS.critical_letter.critLetterIndex : -1;

    // Footnote enemies: show full sentence with current word highlighted
    if (targetEnemy?.enemyType === 'footnote' && targetEnemy.sentenceWords) {
      // Footnote number prefix
      const footnotePrefix = document.createElement('span');
      footnotePrefix.className = 'footnote-prefix';
      const superscripts = '⁰¹²³⁴⁵⁶⁷⁸⁹';
      const numStr = String(targetEnemy.footnoteNumber || 1);
      let superNum = '';
      for (const digit of numStr) {
        superNum += superscripts[parseInt(digit)];
      }
      footnotePrefix.textContent = superNum + ' ';
      display.appendChild(footnotePrefix);

      // Show full sentence: completed words dimmed, current word with typing progress, remaining normal
      const currentWordIndex = targetEnemy.wordIndex - 1; // 0-indexed
      for (let i = 0; i < targetEnemy.sentenceWords.length; i++) {
        if (i > 0) {
          // Space between words — highlight if player needs to type it
          if (i === currentWordIndex && footnoteNeedsSpace) {
            const spaceSpan = document.createElement('span');
            spaceSpan.textContent = '␣';
            spaceSpan.style.color = '#c41e3a';
            spaceSpan.style.animation = 'pulse 0.5s infinite alternate';
            display.appendChild(spaceSpan);
          } else {
            display.appendChild(document.createTextNode(' '));
          }
        }

        const word = targetEnemy.sentenceWords[i];

        if (i < currentWordIndex) {
          // Completed words - dimmed and struck through
          const completedSpan = document.createElement('span');
          completedSpan.className = 'footnote-completed';
          completedSpan.textContent = word;
          completedSpan.style.color = '#555';
          completedSpan.style.textDecoration = 'line-through';
          display.appendChild(completedSpan);
        } else if (i === currentWordIndex) {
          // Current word - show typing progress using shared helper
          renderWordSegment(display, word, typedIndex, { critIndex });
        } else {
          // Future words - normal but slightly dimmed
          const futureSpan = document.createElement('span');
          futureSpan.className = 'footnote-future';
          futureSpan.textContent = word;
          futureSpan.style.color = '#888';
          display.appendChild(futureSpan);
        }
      }
    } else if (targetEnemy?.enemyType === 'censor' && typedIndex < currentWord.length) {
      // Censor enemy: show censored block for next letter
      renderWordSegment(display, currentWord, typedIndex, { critIndex, censored: true });
    } else {
      // Normal word display
      renderWordSegment(display, currentWord, typedIndex, { critIndex });
    }

    if (typedIndex === 0 && stats.wordsTyped === 0) {
      instructions.classList.remove('hidden');
    } else {
      instructions.classList.add('hidden');
    }

    // Update target info bar
    updateTargetInfo();
  }

  function updateTargetInfo() {
    const targetInfo = document.getElementById('targetInfo');
    const targetType = document.getElementById('targetType');
    const targetModifiers = document.getElementById('targetModifiers');
    const targetHealthFill = document.getElementById('targetHealthFill');
    const targetHealthText = document.getElementById('targetHealthText');

    if (!targetEnemy || !currentWord) {
      targetInfo.classList.remove('visible');
      return;
    }

    targetInfo.classList.add('visible');

    // Set enemy type name and color
    const typeConfig = ENEMY_TYPES[targetEnemy.enemyType];
    targetType.textContent = typeConfig ? typeConfig.name : 'Enemy';
    targetType.style.color = targetEnemy.color || '#fff';

    // Clear and populate modifiers
    targetModifiers.textContent = '';

    if (targetEnemy.eliteModifiers && targetEnemy.eliteModifiers.length > 0) {
      targetEnemy.eliteModifiers.forEach(modId => {
        const mod = ELITE_MODIFIERS[modId];
        if (mod) {
          const badge = document.createElement('span');
          badge.className = 'target-modifier ' + modId;
          badge.textContent = mod.name;
          targetModifiers.appendChild(badge);
        }
      });
    }

    // Update health bar
    const healthPercent = Math.max(0, (targetEnemy.health / targetEnemy.maxHealth) * 100);
    targetHealthFill.style.width = healthPercent + '%';
    targetHealthText.textContent = Math.ceil(targetEnemy.health) + ' / ' + Math.ceil(targetEnemy.maxHealth);
  }

  // === [SEC:UPGRADES] UPGRADES ===
  let upgradeChoices = null; // Scoped variable (was upgradeChoices)
  const UPGRADES = [
    {
      id: 'dmg',
      name: 'Sharp Words',
      desc: '+25% damage',
      effect: () => { mods.damageMultiplier *= 1.25; }
    },
    {
      id: 'aoe',
      name: 'Double Letters',
      desc: 'Double letters deal area damage',
      effect: () => { mods.doubleLetterAOE = true; },
      unique: true
    },
    {
      id: 'heal',
      name: 'Vowel Healing',
      desc: 'Typing vowels heals 1 HP',
      effect: () => { mods.vowelHeal = true; },
      unique: true
    },
    {
      id: 'speed',
      name: 'Quick Fingers',
      desc: '+15% typing speed bonus damage',
      effect: () => { mods.speedBonus += 0.15; }
    },
    {
      id: 'magnet',
      name: 'Word Magnet',
      desc: '+50% XP pickup range',
      effect: () => { mods.pickupRange *= 1.5; }
    },
    {
      id: 'combo',
      name: 'Combo Master',
      desc: '+8% damage per combo word',
      effect: () => { mods.comboBonus += 0.08; }
    },
    {
      id: 'armor',
      name: 'Thick Skin',
      desc: '-25% damage taken',
      effect: () => { mods.armorMultiplier *= 0.75; }
    },
    {
      id: 'regen',
      name: 'Regeneration',
      desc: 'Heal 1 HP every 3 seconds',
      effect: () => { mods.regenRate += 1/3; }
    },
    {
      id: 'crit',
      name: 'Critical Words',
      desc: '20% chance for double damage',
      effect: () => { mods.critChance = (mods.critChance || 0) + 0.2; }
    },
    {
      id: 'pierce',
      name: 'Piercing Letters',
      desc: 'Projectiles hit 2 enemies',
      effect: () => { mods.pierce = (mods.pierce || 1) + 1; }
    }
  ];

  let acquiredUpgrades = [];

  function getAvailableUpgrades() {
    return UPGRADES.filter(u => {
      if (u.unique && acquiredUpgrades.includes(u.id)) return false;
      return true;
    });
  }

  function shuffle(array) {
    const arr = [...array];
    for (let i = arr.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    return arr;
  }

  function showUpgradeMenu() {
    gameState = 'upgrading';
    exitWhiteSpace(); // Exit white space when upgrade menu opens
    playLevelUpSound();

    // Show levelup tip before first upgrade selection
    showTip('levelup');

    const available = getAvailableUpgrades();
    const choices = shuffle(available).slice(0, 3);

    const container = document.getElementById('upgradeContainer');
    container.textContent = '';

    choices.forEach((u, i) => {
      const btn = document.createElement('div');
      btn.className = 'upgrade-btn';
      btn.setAttribute('data-index', i);

      const h3 = document.createElement('h3');
      h3.textContent = u.name;
      btn.appendChild(h3);

      const p = document.createElement('p');
      p.textContent = u.desc;
      btn.appendChild(p);

      btn.addEventListener('click', () => selectUpgrade(i));
      container.appendChild(btn);
    });

    document.getElementById('upgradeMenu').classList.remove('hidden');
    upgradeChoices = choices;
  }

  function selectUpgrade(index) {
    const upgrade = upgradeChoices[index];
    upgrade.effect();
    acquiredUpgrades.push(upgrade.id);

    document.getElementById('upgradeMenu').classList.add('hidden');
    gameState = 'playing';
  }

  // === [SEC:AUDIO] AUDIO SYSTEM ===
  let audioCtx = null;

  function initAudio() {
    if (!audioCtx) {
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    }
    if (audioCtx.state === 'suspended') {
      audioCtx.resume();
    }
  }

  function playTone(freq, duration, type = 'square', volume = 0.15) {
    if (!audioCtx) return;

    try {
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();

      osc.type = type;
      osc.frequency.value = freq;
      osc.connect(gain);
      gain.connect(audioCtx.destination);

      const now = audioCtx.currentTime;
      gain.gain.setValueAtTime(volume, now);
      gain.gain.exponentialRampToValueAtTime(0.001, now + duration);

      osc.start(now);
      osc.stop(now + duration);
    } catch (e) {
      // Audio failed, continue silently
    }
  }

  function playTypingSound(correct) {
    if (correct) {
      playTone(400 + typedIndex * 80, 0.06, 'square', 0.1);
    } else {
      playTone(150, 0.1, 'sawtooth', 0.15);
    }
  }

  function playKillSound() {
    playTone(300, 0.08, 'sawtooth', 0.12);
    setTimeout(() => playTone(500, 0.12, 'square', 0.1), 50);
  }

  function playXPSound() {
    playTone(800 + Math.random() * 200, 0.06, 'sine', 0.08);
  }

  function playLevelUpSound() {
    [400, 500, 600, 800, 1000].forEach((f, i) => {
      setTimeout(() => playTone(f, 0.15, 'sine', 0.15), i * 80);
    });
  }

  function playHitSound() {
    playTone(100, 0.15, 'sawtooth', 0.2);
  }

  function playItemPickupSound() {
    if (!audioCtx) return;
    playTone(1200, 0.08, 'sine', 0.12);
    setTimeout(() => playTone(1800, 0.04, 'sine', 0.06), 30);
  }

  function playEliteSpawnSound() {
    if (!audioCtx) return;
    playTone(120, 0.25, 'sawtooth', 0.15);
    setTimeout(() => playTone(150, 0.20, 'sawtooth', 0.10), 80);
    setTimeout(() => playTone(90, 0.30, 'triangle', 0.12), 160);
  }

  function playWaveTransitionSound() {
    if (!audioCtx) return;
    try {
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = 'sawtooth';
      osc.frequency.setValueAtTime(200, audioCtx.currentTime);
      osc.frequency.linearRampToValueAtTime(800, audioCtx.currentTime + 0.15);
      osc.connect(gain);
      gain.connect(audioCtx.destination);
      gain.gain.setValueAtTime(0.12, audioCtx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.25);
      osc.start(audioCtx.currentTime);
      osc.stop(audioCtx.currentTime + 0.25);
    } catch (e) {}
    setTimeout(() => playTone(1000, 0.1, 'sine', 0.15), 200);
  }

  function playComboMilestoneSound(comboLevel) {
    if (!audioCtx) return;
    const baseFreq = 400;
    const noteCount = comboLevel <= 5 ? 3 : comboLevel <= 10 ? 4 : comboLevel <= 25 ? 5 : 6;
    const interval = 40;
    for (let i = 0; i < noteCount; i++) {
      const freq = baseFreq + i * 120 * (comboLevel / 10);
      setTimeout(() => playTone(freq, 0.06, 'square', 0.10), i * interval);
    }
    setTimeout(() => playTone(baseFreq + noteCount * 200, 0.12, 'sine', 0.12), noteCount * interval);
  }

  function playWhiteSpaceEnterSound() {
    if (!audioCtx) return;
    try {
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = 'sine';
      osc.frequency.setValueAtTime(600, audioCtx.currentTime);
      osc.frequency.exponentialRampToValueAtTime(150, audioCtx.currentTime + 0.2);
      osc.connect(gain);
      gain.connect(audioCtx.destination);
      gain.gain.setValueAtTime(0.10, audioCtx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.25);
      osc.start(audioCtx.currentTime);
      osc.stop(audioCtx.currentTime + 0.25);
    } catch (e) {}
  }

  function playWhiteSpaceExitSound() {
    if (!audioCtx) return;
    try {
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = 'sine';
      osc.frequency.setValueAtTime(150, audioCtx.currentTime);
      osc.frequency.exponentialRampToValueAtTime(600, audioCtx.currentTime + 0.15);
      osc.connect(gain);
      gain.connect(audioCtx.destination);
      gain.gain.setValueAtTime(0.08, audioCtx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.20);
      osc.start(audioCtx.currentTime);
      osc.stop(audioCtx.currentTime + 0.20);
    } catch (e) {}
  }

  // === [SEC:WHITESPACE] WHITE SPACE SYSTEM ===
  let whiteSpaceEnteredAt = 0; // Track when White Space was entered (for combo timer compensation)

  function enterWhiteSpace() {
    if (inWhiteSpace) return;
    if (gameState !== 'playing') return;

    inWhiteSpace = true;
    whiteSpaceEnteredAt = performance.now();
    playWhiteSpaceEnterSound();

    // Show whitespace tip on first entry
    showTip('whitespace');

    // Show white space indicator
    const wsIndicator = document.getElementById('whiteSpaceIndicator');
    if (wsIndicator) wsIndicator.classList.remove('hidden');

    // Dim the word display
    const wordDisplay = document.getElementById('wordDisplay');
    if (wordDisplay) wordDisplay.classList.add('white-space-dim');
  }

  function exitWhiteSpace() {
    if (!inWhiteSpace) return;

    // Compensate combo timer for time spent in White Space
    // Without this, spending >3s in White Space would reset the combo on exit
    if (whiteSpaceEnteredAt > 0 && stats.combo > 0) {
      const pauseDuration = performance.now() - whiteSpaceEnteredAt;
      stats.lastComboTime += pauseDuration;
    }

    inWhiteSpace = false;
    whiteSpaceEnteredAt = 0;
    playWhiteSpaceExitSound();

    // Hide white space indicator
    const wsIndicator = document.getElementById('whiteSpaceIndicator');
    if (wsIndicator) wsIndicator.classList.add('hidden');

    // Restore word display
    const wordDisplay = document.getElementById('wordDisplay');
    if (wordDisplay) wordDisplay.classList.remove('white-space-dim');
  }

  // === [SEC:COMBAT] COMBAT SYSTEM ===

  // --- [SEC:COMBAT:HELPERS] Shared combat helpers ---

  // Unified nearest-enemy search — replaces 5 duplicate search patterns
  function findNearestEnemy(originX, originY, options = {}) {
    const { maxRange = Infinity, filter = null, excludeSet = null } = options;
    let nearest = null;
    let minDist = maxRange;

    enemies.forEach(e => {
      if (excludeSet && excludeSet.has(e)) return;
      if (filter && !filter(e)) return;
      const dist = Math.hypot(e.x - originX, e.y - originY);
      if (dist < minDist) {
        minDist = dist;
        nearest = e;
      }
    });

    return nearest ? { enemy: nearest, distance: minDist } : null;
  }

  // Renders a word segment with typed/cursor/remaining structure
  function renderWordSegment(container, word, startIndex, options = {}) {
    const { critIndex = -1, censored = false } = options;

    // Typed portion
    if (startIndex > 0) {
      const typedSpan = document.createElement('span');
      typedSpan.className = 'typed';
      typedSpan.textContent = word.slice(0, startIndex);
      container.appendChild(typedSpan);
    }

    // Cursor
    const cursor = document.createElement('span');
    cursor.className = 'cursor';
    container.appendChild(cursor);

    // Remaining letters
    const remainStart = censored ? startIndex + 1 : startIndex;

    if (censored && startIndex < word.length) {
      const censorSpan = document.createElement('span');
      censorSpan.className = 'censored-letter';
      censorSpan.textContent = '\u2588';
      container.appendChild(censorSpan);
    }

    for (let i = remainStart; i < word.length; i++) {
      if (i === critIndex) {
        const critSpan = document.createElement('span');
        critSpan.className = 'crit-letter';
        critSpan.textContent = word[i];
        container.appendChild(critSpan);
      } else {
        container.appendChild(document.createTextNode(word[i]));
      }
    }
  }

  function fireAtEnemy(enemy, wordLength, itemDamageMultiplier = 1, isCritLetter = false) {
    if (!enemy) return;

    // Calculate damage (soft power caps per balance tuning)
    let damage = wordLength * Math.min(mods.damageMultiplier, 10) * itemDamageMultiplier;

    // Combo bonus (capped at +500%)
    if (stats.combo > 0) {
      const comboMult = Math.min(stats.combo * mods.comboBonus, 5.0);
      damage *= 1 + comboMult;
    }

    // Speed bonus (based on WPM)
    const wpm = calculateWPM();
    if (wpm > 30) {
      damage *= 1 + ((wpm - 30) / 100 * mods.speedBonus);
    }

    // Crit chance (capped at 80%)
    let isCrit = false;
    const effectiveCritChance = Math.min(mods.critChance || 0, 0.80);
    if (effectiveCritChance > 0 && Math.random() < effectiveCritChance) {
      damage *= 2;
      isCrit = true;
      spawnParticles(enemy.x, enemy.y, 10, '#ff0');
    }

    const proj = projectiles.acquire(player.x, player.y, enemy.x, enemy.y, Math.ceil(damage), isCrit);
    if (proj) {
      // Store the target enemy for follow-up word system
      proj.target = enemy;

      // Critical Letter item bonus (passed as parameter instead of global flag)
      if (isCritLetter) {
        proj.isCrit = true;
        spawnParticles(player.x, player.y, 8, '#d4a84b');
      }
      callHooks('onProjectileCreate', proj);
    }

    // Update combo
    stats.combo++;
    stats.maxCombo = Math.max(stats.maxCombo, stats.combo);
    stats.lastComboTime = performance.now();
    updateComboDisplay();

    // Show combo tip when reaching 5+ combo for the first time
    if (stats.combo === 5) {
      showTip('combo');
    }

    // Combo milestone sounds
    if (stats.combo === 5 || stats.combo === 10 || stats.combo === 25 || stats.combo === 50) {
      playComboMilestoneSound(stats.combo);
    }
  }

  function spawnParticles(x, y, count, color) {
    for (let i = 0; i < count; i++) {
      const angle = (Math.PI * 2 / count) * i + Math.random() * 0.5;
      const speed = 50 + Math.random() * 100;
      particles.acquire(
        x, y,
        Math.cos(angle) * speed,
        Math.sin(angle) * speed,
        0.5 + Math.random() * 0.5,
        color
      );
    }
  }

  // --- [SEC:ITEMS:HELPERS] ITEM HELPER FUNCTIONS ---

  // Margin Notes: auto-complete word pickup
  const marginNotes = [];

  function spawnMarginNote(x, y, stacks) {
    marginNotes.push({
      x, y,
      radius: 15 + stacks * 3,
      lifetime: 10,
      bobOffset: Math.random() * Math.PI * 2
    });
  }

  function updateMarginNotes(dt) {
    for (let i = marginNotes.length - 1; i >= 0; i--) {
      const note = marginNotes[i];
      note.lifetime -= dt;

      if (note.lifetime <= 0) {
        marginNotes.splice(i, 1);
        continue;
      }
    }
    // Check for pickup (can happen during white space too)
    checkMarginNotePickup();
  }

  // Check for margin note pickup only (used during white space when time is frozen)
  function checkMarginNotePickup() {
    for (let i = marginNotes.length - 1; i >= 0; i--) {
      const note = marginNotes[i];
      const dist = Math.hypot(note.x - player.x, note.y - player.y);
      if (dist < player.radius + note.radius) {
        // Auto-complete current word
        if (currentWord && targetEnemy) {
          firedAtEnemies.add(targetEnemy);
          fireAtEnemy(targetEnemy, currentWord.length);
          stats.wordsTyped++;
          checkLitNukeTrigger(); // Check for LITERARY NUKE every 100 words
          if (currentWord.length > stats.longestWord.length) {
            stats.longestWord = currentWord;
          }
          currentWord = '';
          typedIndex = 0;
          targetEnemy = null;
          assignWordToEnemy();
          updateWordDisplay();
          spawnParticles(note.x, note.y, 8, '#ff0');
        }
        marginNotes.splice(i, 1);
      }
    }
  }

  function drawMarginNotes() {
    for (const note of marginNotes) {
      const bob = Math.sin(performance.now() / 300 + note.bobOffset) * 3;
      const alpha = Math.min(1, note.lifetime / 2);

      ctx.globalAlpha = alpha * 0.3;
      ctx.fillStyle = '#ffff00';
      ctx.beginPath();
      ctx.arc(note.x, note.y + bob, note.radius + 5, 0, Math.PI * 2);
      ctx.fill();

      ctx.globalAlpha = alpha;
      ctx.fillStyle = '#ffff00';
      ctx.font = 'bold 14px "Courier Prime", Courier, monospace';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText('AUTO', note.x, note.y + bob);
      ctx.globalAlpha = 1;
    }
  }

  // Ink Blot: damage pools
  const inkPools = [];

  function spawnInkPool(x, y, stacks) {
    inkPools.push({
      x, y,
      radius: 30 + stacks * 10,
      damage: 50 + stacks * 25,
      lifetime: 3 + stacks * 0.5
    });
  }

  function updateInkPools(dt) {
    for (let i = inkPools.length - 1; i >= 0; i--) {
      const pool = inkPools[i];
      pool.lifetime -= dt;

      if (pool.lifetime <= 0) {
        inkPools.splice(i, 1);
        continue;
      }

      // Damage enemies in pool
      enemies.forEach(e => {
        const dist = Math.hypot(e.x - pool.x, e.y - pool.y);
        if (dist < pool.radius) {
          e.health -= pool.damage * dt;
        }
      });
    }
  }

  function drawInkPools() {
    for (const pool of inkPools) {
      const alpha = Math.min(1, pool.lifetime / 1.5);
      ctx.globalAlpha = alpha * 0.6;
      ctx.fillStyle = '#1a1a3e';
      ctx.beginPath();
      ctx.arc(pool.x, pool.y, pool.radius, 0, Math.PI * 2);
      ctx.fill();

      ctx.strokeStyle = '#4a4a8e';
      ctx.lineWidth = 2;
      ctx.stroke();
      ctx.globalAlpha = 1;
    }
  }

  // Footnote: homing projectile
  function fireHomingProjectile() {
    const result = findNearestEnemy(player.x, player.y);
    if (result) {
      const nearest = result.enemy;
      const proj = projectiles.acquire(player.x, player.y, nearest.x, nearest.y, 5);
      if (proj) {
        proj.isHoming = true;
        proj.homingTarget = nearest;
        spawnParticles(player.x, player.y, 3, '#2d4a6f');
      }
    }
  }

  // Chain Letter: chain lightning from player
  function fireChainLightning(stacks) {
    const targetCount = 3 + stacks;
    const hitEnemies = new Set();
    let lastPos = { x: player.x, y: player.y };
    const damage = 15 + stacks * 5;

    for (let i = 0; i < targetCount; i++) {
      // Find nearest unhit enemy within chain range
      const result = findNearestEnemy(lastPos.x, lastPos.y, { maxRange: 300, excludeSet: hitEnemies });
      if (!result) break;

      const nearest = result.enemy;

      // Hit this enemy
      hitEnemies.add(nearest);
      nearest.health -= damage;

      // Visual: lightning particles between last pos and enemy
      const steps = 5;
      for (let j = 0; j < steps; j++) {
        const t = j / steps;
        const x = lastPos.x + (nearest.x - lastPos.x) * t + (Math.random() - 0.5) * 20;
        const y = lastPos.y + (nearest.y - lastPos.y) * t + (Math.random() - 0.5) * 20;
        spawnParticles(x, y, 1, '#d4a84b');
      }
      spawnParticles(nearest.x, nearest.y, 5, '#d4a84b');

      lastPos = { x: nearest.x, y: nearest.y };
    }

    // Sound effect
    if (hitEnemies.size > 0) {
      playTone(800, 0.1, 'sawtooth', 0.15);
      playTone(1200, 0.1, 'sawtooth', 0.1);
    }
  }

  // === [SEC:DAMAGE] DAMAGE NUMBER SYSTEM ===
  const recentDamagePositions = new Map(); // entityId -> { count, time }

  function spawnDamageNumber(x, y, value, type, entityId = null) {
    let offsetX = 0;

    // Cascade offset for rapid hits on same target
    if (entityId !== null) {
      const now = performance.now();
      const recent = recentDamagePositions.get(entityId);
      if (recent && now - recent.time < 300) {
        offsetX = (recent.count % 5) * 15;
        recent.count++;
        recent.time = now;
      } else {
        recentDamagePositions.set(entityId, { count: 1, time: now });
      }
    }

    damageNumbers.acquire(x, y - 20, String(Math.ceil(value)), type, offsetX);
  }

  function updateComboDisplay() {
    const comboEl = document.getElementById('combo');
    if (stats.combo > 1) {
      comboEl.textContent = stats.combo + 'x COMBO';
      comboEl.classList.remove('hidden');
    } else {
      comboEl.classList.add('hidden');
    }
  }

  function spawnEnemy() {
    const wave = Math.floor(gameTime / 20) + 1;
    const enemyType = getEnemyTypeForWave(wave);
    const typeConfig = ENEMY_TYPES[enemyType];

    let x, y;
    const side = Math.floor(Math.random() * 4);
    const margin = 50;
    switch (side) {
      case 0: x = Math.random() * canvasWidth; y = -margin; break;
      case 1: x = canvasWidth + margin; y = Math.random() * canvasHeight; break;
      case 2: x = Math.random() * canvasWidth; y = canvasHeight + margin; break;
      case 3: x = -margin; y = Math.random() * canvasHeight; break;
    }

    // Special handling for footnotes - spawn as a sentence split into words
    if (enemyType === 'footnote') {
      spawnFootnoteSentence(x, y);
      return;
    }

    const spawnCount = typeConfig.spawnCount
      ? typeConfig.spawnCount[0] + Math.floor(Math.random() * (typeConfig.spawnCount[1] - typeConfig.spawnCount[0] + 1))
      : 1;

    for (let i = 0; i < spawnCount; i++) {
      const ox = i > 0 ? (Math.random() - 0.5) * 80 : 0;
      const oy = i > 0 ? (Math.random() - 0.5) * 80 : 0;
      spawnEnemyOfType(x + ox, y + oy, enemyType);
    }
  }

  // Spawn a footnote sentence as multiple enemies, one word each
  function spawnFootnoteSentence(x, y) {
    const sentences = WORDS.footnoteSentences;
    const sentence = sentences[Math.floor(Math.random() * sentences.length)];
    const words = sentence.split(' ');

    // Increment footnote counter for this sentence group
    footnoteCounter++;
    const sentenceFootnoteNumber = footnoteCounter;

    // Spawn one enemy per word, storing sentence info for display
    for (let i = 0; i < words.length; i++) {
      const ox = (Math.random() - 0.5) * 100;
      const oy = (Math.random() - 0.5) * 100;

      const enemy = spawnFootnoteWord(x + ox, y + oy, words[i], sentenceFootnoteNumber, i + 1, words.length, words);
    }
  }

  // Spawn a single footnote enemy with a specific word
  function spawnFootnoteWord(x, y, word, footnoteNum, wordIndex, totalWords, sentenceWords) {
    const typeConfig = ENEMY_TYPES.footnote;

    const enemy = enemies.acquire(x, y, word, 'footnote');
    if (!enemy) return null;

    enemy.enemyType = 'footnote';
    enemy.color = typeConfig.color;
    enemy.speed = CONFIG.ENEMY_BASE_SPEED * typeConfig.baseSpeed + Math.random() * 20;
    enemy.maxHealth = Math.ceil(word.length * typeConfig.baseHP);
    enemy.health = enemy.maxHealth;
    enemy.behaviorState = {};
    enemy.stateTimer = 0;
    enemy.eliteModifiers = [];
    enemy.isElite = false;
    enemy.invisibility = 1;
    enemy.visualScale = 1;

    // Footnote display info
    enemy.footnoteNumber = footnoteNum;
    enemy.wordIndex = wordIndex;
    enemy.totalWords = totalWords;
    enemy.sentenceWords = sentenceWords; // Full sentence word array for display

    // Show mob tip on first footnote
    showMobTip('footnote');

    return enemy;
  }

  function checkLevelUp() {
    while (player.xp >= player.xpToNext) {
      player.xp -= player.xpToNext;
      player.level++;
      player.xpToNext = Math.floor(CONFIG.XP_BASE * Math.pow(CONFIG.XP_SCALE, player.level - 1));
      showUpgradeMenu();
    }
    updateXPBar();
  }

  function updateXPBar() {
    const fill = document.getElementById('xpFill');
    fill.style.width = ((player.xp / player.xpToNext) * 100) + '%';
  }

  function updateHealthBar() {
    const fill = document.getElementById('healthFill');
    fill.style.width = ((player.health / player.maxHealth) * 100) + '%';
  }

  function calculateWPM() {
    if (stats.wordsTyped === 0) return 0;
    const minutes = (performance.now() - stats.startTime) / 60000;
    if (minutes < 0.1) return 0;
    return Math.round((stats.totalChars / 5) / minutes);
  }

  // === [SEC:INPUT] INPUT HANDLING ===

  // --- [SEC:INPUT:KEYBOARD] Keyboard Events ---
  // Track last processed input to prevent mobile double-firing
  let lastProcessedInput = { char: null, time: 0 };

  document.addEventListener('keydown', (e) => {
    if (gameState !== 'playing') return;
    if (tipModalActive) return; // Don't process input while tip is shown
    if (itemNotificationActive) return; // Don't process input while item notification is shown
    if (collectionMenuOpen) return; // Don't process input while collection menu is shown
    if (e.ctrlKey || e.altKey || e.metaKey) return;

    // Get the raw key - don't use toLowerCase() for symbols
    const rawKey = e.key;

    // Only process single characters
    if (rawKey.length !== 1) return;

    // Track this input to prevent mobile double-firing
    if (typeof lastProcessedInput !== 'undefined') {
      lastProcessedInput.char = rawKey;
      lastProcessedInput.time = performance.now();
    }

    // For comparison, use case-insensitive matching
    const keyMatches = (pressed, target) => {
      if (!target) return false;
      // For letters, compare case-insensitively
      if (/^[a-zA-Z]$/.test(pressed) && /^[a-zA-Z]$/.test(target)) {
        return pressed.toLowerCase() === target.toLowerCase();
      }
      // For symbols and other chars, exact match
      return pressed === target;
    };

    // Check Critical Letter - pressing the crit letter at ANY time instantly completes the word with crit
    const critStacks = inventory['critical_letter'] || 0;
    if (critStacks > 0 && currentWord && ITEMS.critical_letter.critLetterIndex >= 0) {
      const critIndex = ITEMS.critical_letter.critLetterIndex;
      // Bounds check: invalidate if index exceeds word length (e.g., Typo enemy scrambled word)
      if (critIndex >= currentWord.length) {
        ITEMS.critical_letter.critLetterIndex = -1;
      } else {
      const critChar = currentWord[critIndex];
      if (keyMatches(rawKey, critChar)) {
        // Crit letter pressed! Instant complete with crit
        const completedWord = currentWord;
        const completedEnemy = targetEnemy;
        typedIndex = currentWord.length;
        stats.totalChars += currentWord.length;
        playTypingSound(true);
        spawnParticles(player.x, player.y, 15, '#d4a84b');
        playTone(1000, 0.2, 'sine', 0.15);

        // Fire at enemy with crit
        if (targetEnemy) {
          firedAtEnemies.add(targetEnemy);
        }

        // Call onWordComplete hooks - pass base damage multiplier of 1, get modified multiplier back
        const damageMultiplier = callWordCompleteHooks(completedWord, completedEnemy);

        fireAtEnemy(completedEnemy, completedWord.length, damageMultiplier, true);
        stats.wordsTyped++;
        checkLitNukeTrigger(); // Check for LITERARY NUKE every 100 words
        if (completedWord.length > stats.longestWord.length) {
          stats.longestWord = completedWord;
        }
        currentWord = '';
        typedIndex = 0;
        targetEnemy = null;
        assignWordToEnemy();
        updateWordDisplay();
        return; // Don't process normal typing
      }
      } // end else (critIndex in bounds)
    }

    // Footnote sentence: require space between words
    if (footnoteNeedsSpace) {
      if (rawKey === ' ') {
        footnoteNeedsSpace = false;
        playTypingSound(true);
        updateWordDisplay();
      }
      return; // Consume all keys until space is pressed
    }

    if (currentWord && keyMatches(rawKey, currentWord[typedIndex])) {
      // Correct key
      typedIndex++;
      stats.totalChars++;
      playTypingSound(true);

      // Call item hooks for key press
      callHooks('onKeyPress', rawKey.toLowerCase(), true);

      // Vowel healing
      if (mods.vowelHeal && 'aeiou'.includes(rawKey.toLowerCase())) {
        player.health = Math.min(player.health + 1, player.maxHealth);
        updateHealthBar();
        spawnDamageNumber(player.x, player.y - 30, 1, 'heal');
      }

      // Double letter AOE
      if (mods.doubleLetterAOE && typedIndex > 1 &&
          keyMatches(currentWord[typedIndex - 1], currentWord[typedIndex - 2])) {
        // Deal AOE damage to nearby enemies
        const aoeRange = 100;
        enemies.forEach(e => {
          if (e !== targetEnemy) {
            const dist = Math.hypot(e.x - targetEnemy.x, e.y - targetEnemy.y);
            if (dist < aoeRange) {
              e.health -= 1;
              spawnParticles(e.x, e.y, 3, '#ff0');
            }
          }
        });
      }

      // Check for Monkey's Typewriter instant completion
      const monkeyStacks = inventory['monkey_typewriter'] || 0;
      if (monkeyStacks > 0 && typedIndex < currentWord.length) {
        if (ITEMS.monkey_typewriter.checkInstantComplete(monkeyStacks)) {
          typedIndex = currentWord.length; // Complete the word instantly
          spawnParticles(player.x, player.y, 10, '#ffaa00');
          playTone(800, 0.15, 'sine', 0.1);
        }
      }

      // Check for Tab Complete auto-completion
      const tabStacks = inventory['tab_complete'] || 0;
      if (tabStacks > 0 && typedIndex < currentWord.length && ITEMS.tab_complete.canUse()) {
        const reqLetters = ITEMS.tab_complete.getRequiredLetters(tabStacks);
        if (typedIndex >= reqLetters) {
          ITEMS.tab_complete.use();
          typedIndex = currentWord.length; // Auto-complete the word
          spawnParticles(player.x, player.y, 8, '#00ff88');
          playTone(600, 0.15, 'triangle', 0.1);
        }
      }

      if (typedIndex >= currentWord.length) {
        // Save references before clearing
        const completedWord = currentWord;
        const completedEnemy = targetEnemy;

        // Call onWordComplete hooks - pass base damage multiplier of 1, get modified multiplier back
        const damageMultiplier = callWordCompleteHooks(completedWord, completedEnemy);

        // Calculate expected damage to predict if enemy will survive
        let predictedDamage = completedWord.length * mods.damageMultiplier * damageMultiplier;
        if (stats.combo > 0) {
          predictedDamage *= 1 + (stats.combo * mods.comboBonus);
        }
        const wpm = calculateWPM();
        if (wpm > 30) {
          predictedDamage *= 1 + ((wpm - 30) / 100 * mods.speedBonus);
        }
        // Note: crit is random, so we use non-crit damage for prediction (conservative)

        // Will enemy survive this hit?
        const willSurvive = completedEnemy && completedEnemy.health > Math.ceil(predictedDamage);

        fireAtEnemy(completedEnemy, completedWord.length, damageMultiplier);

        stats.wordsTyped++;
        checkLitNukeTrigger(); // Check for LITERARY NUKE every 100 words
        if (completedWord.length > stats.longestWord.length) {
          stats.longestWord = completedWord;
        }

        if (willSurvive) {
          // Enemy will survive - immediately assign follow-up word to SAME enemy
          // Don't add to firedAtEnemies, don't clear target

          // For footnotes, keep the same word (they're part of a sentence)
          if (completedEnemy?.enemyType === 'footnote') {
            currentWord = completedEnemy.word;
            typedIndex = 0;
            updateWordDisplay();
          } else {
            // Normal multi-hit enemy: assign scaled follow-up word
            const predictedHealth = completedEnemy.health - Math.ceil(predictedDamage);
            const healthPercent = predictedHealth / completedEnemy.maxHealth;

            // Word length based on predicted remaining health
            let maxLength;
            if (healthPercent <= 0.2) {
              maxLength = 3;
            } else if (healthPercent <= 0.4) {
              maxLength = 4;
            } else if (healthPercent <= 0.6) {
              maxLength = 5;
            } else {
              maxLength = 6;
            }

            const pool = healthPercent <= 0.3 ? WORDS.easy : WORDS.medium;
            const candidates = pool.filter(w => w.length >= 2 && w.length <= maxLength);
            let newWord = candidates[Math.floor(Math.random() * candidates.length)] || 'hit';
            newWord = callHooks('onWordAssign', newWord, completedEnemy) || newWord;

            completedEnemy.word = newWord;
            currentWord = newWord;
            typedIndex = 0;
            // targetEnemy stays the same
            updateWordDisplay();
          }
        } else {
          // Enemy will die - mark as fired at and find new target
          if (completedEnemy) {
            firedAtEnemies.add(completedEnemy);
          }
          currentWord = '';
          typedIndex = 0;
          targetEnemy = null;

          // For footnotes, immediately target the next word in the sentence
          let foundNextFootnote = false;
          if (completedEnemy?.enemyType === 'footnote' && completedEnemy.footnoteNumber && completedEnemy.sentenceWords) {
            const footnoteNum = completedEnemy.footnoteNumber;
            let nextEnemy = null;
            let lowestWordIndex = Infinity;

            enemies.forEach(e => {
              if (e.enemyType === 'footnote' &&
                  e.footnoteNumber === footnoteNum &&
                  e.wordIndex > completedEnemy.wordIndex &&
                  e.wordIndex < lowestWordIndex &&
                  !firedAtEnemies.has(e)) {
                nextEnemy = e;
                lowestWordIndex = e.wordIndex;
              }
            });

            if (nextEnemy) {
              currentWord = nextEnemy.word;
              typedIndex = 0;
              targetEnemy = nextEnemy;
              foundNextFootnote = true;
              footnoteNeedsSpace = true; // Require space before next word
            }
          }

          // If not a footnote or no more words in sentence, find nearest enemy
          if (!foundNextFootnote) {
            assignWordToEnemy();
          }
          updateWordDisplay();
        }
      } else {
        updateWordDisplay();
      }
    } else if (currentWord) {
      // Wrong key (any character) - check if Spellcheck can save us
      if (ITEMS.spellcheck && ITEMS.spellcheck.canUse()) {
        ITEMS.spellcheck.use();
        playTypingSound(true); // Play success sound instead
        // Don't penalize, just ignore the wrong key
      } else {
        playTypingSound(false);
        callHooks('onKeyPress', rawKey.toLowerCase(), false);
        // Visual feedback
        document.getElementById('wordDisplay').classList.add('shake');
        setTimeout(() => {
          document.getElementById('wordDisplay').classList.remove('shake');
        }, 100);
      }
    }
  });

  // --- [SEC:INPUT:MOUSE] Mouse Movement ---
  // Mouse input for desktop - movement triggers white space (time stop)
  canvas.addEventListener('mousemove', (e) => {
    if (gameState !== 'playing') return;

    const dx = e.clientX - lastMouseX;
    const dy = e.clientY - lastMouseY;

    // Only trigger white space if mouse moved enough (prevents jitter)
    if (Math.abs(dx) > MOUSE_MOVE_THRESHOLD || Math.abs(dy) > MOUSE_MOVE_THRESHOLD) {
      enterWhiteSpace();

      // Update player position while in white space
      player.x = e.clientX;
      player.y = e.clientY;

      // Reset idle timer - exit white space after mouse stops
      clearTimeout(mouseIdleTimer);
      mouseIdleTimer = setTimeout(exitWhiteSpace, MOUSE_IDLE_DELAY);
    }

    lastMouseX = e.clientX;
    lastMouseY = e.clientY;
  });

  // Exit white space when mouse leaves canvas
  canvas.addEventListener('mouseleave', () => {
    if (gameState === 'playing') {
      clearTimeout(mouseIdleTimer);
      exitWhiteSpace();
    }
  });

  canvas.addEventListener('click', () => {
    initAudio();
  });

  // Touch input for mobile - touch moving triggers white space
  let touchActive = false;

  canvas.addEventListener('touchstart', (e) => {
    e.preventDefault();
    initAudio();
    touchActive = true;

    if (gameState === 'playing') {
      const touch = e.touches[0];
      // Initialize position on touch start (doesn't enter white space)
      lastMouseX = touch.clientX;
      lastMouseY = touch.clientY;
      // Focus mobile input on tap to show keyboard (must be immediate for iOS)
      focusMobileInput(true);
    }
  }, { passive: false });

  canvas.addEventListener('touchmove', (e) => {
    e.preventDefault();
    if (gameState !== 'playing' || !touchActive) return;

    const touch = e.touches[0];
    const dx = touch.clientX - lastMouseX;
    const dy = touch.clientY - lastMouseY;

    // Only trigger white space if touch moved enough
    if (Math.abs(dx) > MOUSE_MOVE_THRESHOLD || Math.abs(dy) > MOUSE_MOVE_THRESHOLD) {
      enterWhiteSpace();

      player.x = touch.clientX;
      player.y = touch.clientY;

      // Reset idle timer
      clearTimeout(mouseIdleTimer);
      mouseIdleTimer = setTimeout(exitWhiteSpace, MOUSE_IDLE_DELAY);
    }

    lastMouseX = touch.clientX;
    lastMouseY = touch.clientY;
  }, { passive: false });

  canvas.addEventListener('touchend', () => {
    touchActive = false;
    clearTimeout(mouseIdleTimer);
    exitWhiteSpace();
    // Refocus mobile input after touch ends (immediate for iOS keyboard)
    if (gameState === 'playing') {
      focusMobileInput(true);
    }
  });

  // --- [SEC:INPUT:TOUCH] MOBILE KEYBOARD INPUT ---
  const mobileInput = document.getElementById('mobileInput');

  // Focus mobile input - use immediate=true when called from user gesture (tap/click)
  // iOS requires focus to happen synchronously within user gesture handler
  function focusMobileInput(immediate = false) {
    if (!mobileInput) return;

    if (immediate) {
      // Synchronous focus for user gesture handlers (required for iOS keyboard)
      mobileInput.focus();
    } else if (gameState === 'playing') {
      // Delayed focus for other cases (e.g., after blur)
      setTimeout(() => {
        mobileInput.focus();
      }, 10);
    }
  }

  // Handle input from mobile keyboard
  mobileInput.addEventListener('input', (e) => {
    if (gameState !== 'playing') return;
    if (tipModalActive || itemNotificationActive || collectionMenuOpen) return; // Don't process input while paused

    const text = e.target.value;
    if (text.length === 0) return;

    // Get the last character typed
    const char = text.slice(-1);

    // Clear the input (so it doesn't accumulate text)
    e.target.value = '';

    // Prevent double-processing if native keydown already handled this
    const now = performance.now();
    if (lastProcessedInput.char === char && now - lastProcessedInput.time < 50) {
      return; // Already processed by native keydown
    }

    // Simulate keydown event for the typed character
    const keyEvent = new KeyboardEvent('keydown', {
      key: char,
      bubbles: true,
      cancelable: true
    });
    keyEvent._fromMobileInput = true; // Mark as from mobile input
    document.dispatchEvent(keyEvent);
  });

  // Prevent mobile input from losing focus during gameplay
  mobileInput.addEventListener('blur', () => {
    if (gameState === 'playing') {
      // Refocus after a small delay (allows intentional blur for menus)
      setTimeout(() => {
        if (gameState === 'playing') {
          focusMobileInput();
        }
      }, 100);
    }
  });

  // Prevent zoom
  document.addEventListener('gesturestart', e => e.preventDefault());
  document.addEventListener('gesturechange', e => e.preventDefault());

  // === [SEC:UPDATE] UPDATE LOOP ===
  function update(dt) {
    if (gameState !== 'playing') return;

    // --- [SEC:UPDATE:PLAYER] Player Movement & State ---
    // White space freezes game time - skip all updates except player position
    // But still allow item, gem, and margin note pickup during white space
    if (inWhiteSpace) {
      checkItemPickup();
      checkGemPickup();
      checkMarginNotePickup();
      litNukeWhiteSpaceKill(); // Rainbow mario mode: kill enemies on contact!
      return;
    }

    // Pause while item notification, tip modal, or collection menu is shown
    if (itemNotificationActive || tipModalActive || collectionMenuOpen) return;

    gameTime += dt;

    // Call onUpdate hooks (for items with continuous/periodic effects)
    callHooks('onUpdate', dt);

    // Regeneration
    if (mods.regenRate > 0) {
      player.health = Math.min(player.health + mods.regenRate * dt, player.maxHealth);
      updateHealthBar();
    }

    // Combo timeout
    if (stats.combo > 0 && performance.now() - stats.lastComboTime > CONFIG.COMBO_TIMEOUT) {
      stats.combo = 0;
      updateComboDisplay();
    }

    // --- [SEC:UPDATE:ENEMIES] Enemy AI & Movement ---
    // Spawn enemies (disabled in practice mode)
    if (!practiceMode) {
      spawnTimer -= dt;
      const wave = Math.floor(gameTime / 20) + 1;
      const spawnDelay = CONFIG.SPAWN_MIN_DELAY + (CONFIG.SPAWN_INITIAL_DELAY - CONFIG.SPAWN_MIN_DELAY) / (1 + (wave - 1) * 0.5);

      // Wave transition sound
      if (wave > lastTrackedWave) {
        if (lastTrackedWave > 0) playWaveTransitionSound();
        lastTrackedWave = wave;
      }

      if (spawnTimer <= 0) {
        spawnEnemy();
        spawnTimer = spawnDelay;

        // Spawn more enemies in later waves
        if (wave > 2 && Math.random() < 0.35) spawnEnemy();
        if (wave > 4 && Math.random() < 0.35) spawnEnemy();

        // Immediately assign word if player is waiting for one
        if (!currentWord) {
          assignWordToEnemy();
        }
      }
    }

    // Update enemies
    enemies.forEach((e, i) => {
      // Execute behavior based on enemy type
      const typeConfig = ENEMY_TYPES[e.enemyType];
      const behavior = ENEMY_BEHAVIORS[typeConfig?.behavior || 'chase'];
      if (behavior) {
        behavior(e, dt, player);
      } else {
        ENEMY_BEHAVIORS.chase(e, dt, player);
      }

      // Update elite modifiers
      updateEliteModifiers(e, dt);

      // Process bleed damage (Papercut)
      if (e.bleedDuration && e.bleedDuration > 0) {
        e.bleedDuration -= dt;
        const bleedDamage = e.maxHealth * (e.bleedDamage || 0.02) * dt;
        e.health -= bleedDamage;
        if (Math.random() < 0.1) {
          spawnParticles(e.x, e.y, 1, '#c41e3a');
        }
      }

      // Process mark duration (Red Pen)
      if (e.marked && e.markDuration) {
        e.markDuration -= dt;
        if (e.markDuration <= 0) {
          e.marked = false;
        }
      }

      // Check collision with player (skip if invisible, mercy invincible, or practice mode)
      const isInvisible = ITEMS.invisible_ink && ITEMS.invisible_ink.isInvisible();
      const isMercy = performance.now() < mercyInvincibleUntil;
      const dist = Math.hypot(e.x - player.x, e.y - player.y);
      if (dist < player.radius + e.radius && !isInvisible && !isMercy && !practiceMode) {
        let damage = Math.ceil(e.maxHealth * 5 * mods.armorMultiplier);
        damage = callHooks('onDamageTaken', damage) || damage;
        if (damage > 0) {
          player.health -= damage;
          mercyInvincibleUntil = performance.now() + 750; // 0.75s mercy window
          lastDamageSource = e.type + (e.eliteModifiers?.length ? ' (' + e.eliteModifiers.join(', ') + ')' : '');
          updateHealthBar();
          shakeIntensity = 15;
          playHitSound();
          spawnParticles(player.x, player.y, 8, '#f00');
          spawnDamageNumber(player.x, player.y, damage, 'playerDamage');
        }

        // Handle targeting BEFORE releasing enemy (to preserve footnote data)
        if (e === targetEnemy) {
          handleTargetAfterDeath(e);
        }
        firedAtEnemies.delete(e);
        enemies.release(e);

        if (player.health <= 0) {
          const deathResult = callHooks('onDeath');
          if (deathResult && deathResult.prevent) {
            player.health = deathResult.respawnHP || 1;
            updateHealthBar();
          } else {
            endGame();
          }
        }
      }

      // Check if enemy died from AOE/bleed
      if (e.health <= 0) {
        stats.enemiesKilled++;
        handleEnemyDeath(e, null);
        gems.acquire(e.x, e.y, e.maxHealth);
        spawnParticles(e.x, e.y, 8, e.color || '#1a1714');
        playKillSound();

        // Handle targeting BEFORE releasing enemy (to preserve footnote data)
        if (e === targetEnemy) {
          handleTargetAfterDeath(e);
        }
        firedAtEnemies.delete(e);
        enemies.release(e);
      }
    });

    // --- [SEC:UPDATE:PROJECTILES] Projectile Physics ---
    // Update projectiles
    projectiles.forEach((p, i) => {
      // Homing projectile logic
      if (p.isHoming && p.homingTarget) {
        // Check if target still exists
        if (enemies.active.includes(p.homingTarget)) {
          const angle = Math.atan2(p.homingTarget.y - p.y, p.homingTarget.x - p.x);
          const currentAngle = Math.atan2(p.vy, p.vx);
          const turnSpeed = 5 * dt;
          let angleDiff = angle - currentAngle;
          // Normalize angle difference
          while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
          while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
          const newAngle = currentAngle + Math.sign(angleDiff) * Math.min(Math.abs(angleDiff), turnSpeed);
          const speed = Math.hypot(p.vx, p.vy);
          p.vx = Math.cos(newAngle) * speed;
          p.vy = Math.sin(newAngle) * speed;
        } else {
          p.isHoming = false; // Target dead, stop homing
        }
      }

      p.x += p.vx * dt;
      p.y += p.vy * dt;

      // Call item hooks for projectile update
      callHooks('onProjectileUpdate', p, dt);

      let hitCount = 0;
      const maxHits = mods.pierce || 1;

      // Check collision with enemies
      let preventRelease = false;
      enemies.forEach((e, enemyIndex) => {
        if (hitCount >= maxHits) return;

        const dist = Math.hypot(p.x - e.x, p.y - e.y);
        if (dist < p.radius + e.radius) {
          let damage = p.damage;
          // Marked enemy takes +50% damage
          if (e.marked) {
            damage = Math.ceil(damage * 1.5);
          }
          // Critical Letter bonus damage
          if (p.isCrit) {
            const critStacks = inventory['critical_letter'] || 0;
            if (critStacks > 0) {
              damage = Math.ceil(damage * ITEMS.critical_letter.getCritMultiplier(critStacks));
            }
          }
          e.health -= damage;
          hitCount++;
          spawnParticles(e.x, e.y, 5, e.marked ? '#c41e3a' : (p.isCrit ? '#d4a84b' : '#2d4a6f'));
          spawnDamageNumber(e.x, e.y, damage, p.isCrit ? 'crit' : 'damage', enemyIndex);

          // Blood Ink lifesteal
          if (inventory['blood_ink']) {
            ITEMS.blood_ink.applyLifesteal(damage);
          }

          // Call item hooks for projectile hit
          const hookResult = callHooks('onProjectileHit', p, e);
          if (hookResult && hookResult.preventRelease) {
            preventRelease = true;
          }

          if (e.health <= 0) {
            stats.enemiesKilled++;
            handleEnemyDeath(e, p);
            gems.acquire(e.x, e.y, e.maxHealth);
            spawnParticles(e.x, e.y, 10, e.color || '#1a1714');
            playKillSound();

            // Handle targeting BEFORE releasing enemy (to preserve footnote data)
            if (e === targetEnemy) {
              handleTargetAfterDeath(e);
            }
            firedAtEnemies.delete(e);
            enemies.release(e);
          } else if (e === p.target) {
            // Enemy survived the hit!
            // Re-target and assign follow-up if needed
            // (prediction may have been wrong due to crit or item effects)
            if (targetEnemy !== e || !currentWord) {
              targetEnemy = e;
              assignFollowUpWord(e);
            }
          }
        }
      });

      if (hitCount > 0 && hitCount >= maxHits && !preventRelease) {
        projectiles.release(p);
      }

      // Remove off-screen
      if (p.x < -50 || p.x > canvasWidth + 50 ||
          p.y < -50 || p.y > canvasHeight + 50) {
        projectiles.release(p);
      }
    });

    // --- [SEC:UPDATE:GEMS] XP Gem Collection ---
    // Update gems
    const magnetRange = CONFIG.GEM_MAGNET_RANGE * mods.pickupRange;

    gems.forEach((g, i) => {
      const dist = Math.hypot(g.x - player.x, g.y - player.y);

      if (dist < magnetRange) {
        // Magnetic pull
        const angle = Math.atan2(player.y - g.y, player.x - g.x);
        const pullSpeed = CONFIG.GEM_MAGNET_SPEED * (1 - dist / magnetRange);
        g.x += Math.cos(angle) * pullSpeed * dt;
        g.y += Math.sin(angle) * pullSpeed * dt;
      }

      if (dist < CONFIG.GEM_COLLECT_RANGE) {
        player.xp += g.value;
        spawnDamageNumber(g.x, g.y, g.value, 'xp');
        gems.release(g);
        playXPSound();
        checkLevelUp();
      }
    });

    // Update item drops
    updateItemDrops(dt);

    // Update item effects
    updateMarginNotes(dt);
    updateInkPools(dt);

    // Update LITERARY NUKE system
    updateLiteraryNuke(dt);

    // Update item status displays (throttled to every 100ms)
    if (performance.now() - lastItemDisplayUpdate > 100) {
      lastItemDisplayUpdate = performance.now();
      updateActiveItemsDisplay();
      updatePassiveItemsDisplay();
    }

    // Update particles
    particles.forEach((p, i) => {
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      p.vx *= 0.98;
      p.vy *= 0.98;
      p.life -= dt;

      if (p.life <= 0) {
        particles.release(p);
      }
    });

    // Update damage numbers
    damageNumbers.forEach((dn) => {
      dn.y -= 60 * dt; // Float up
      dn.life -= dt;
      if (dn.shake > 0) dn.shake = Math.max(0, dn.shake - dt * 15);
      if (dn.life <= 0) damageNumbers.release(dn);
    });

    // Update shake
    shakeIntensity *= shakeDecay;

    // Update stats display
    updateStatsDisplay();

    // Update target info bar (for health changes)
    updateTargetInfo();

    // Assign word if none
    if (!currentWord && enemies.count > 0) {
      assignWordToEnemy();
    }

    // Fix: Detect mismatch - have word but no target (auto-correct invalid state)
    if (currentWord && !targetEnemy) {
      currentWord = '';
      typedIndex = 0;
      updateWordDisplay();
    }
  }

  function updateStatsDisplay() {
    const wave = Math.floor(gameTime / 20) + 1;
    const wpm = calculateWPM();
    const statsEl = document.getElementById('stats');

    // Build stats using text content for safety
    statsEl.textContent = '';
    const lines = [
      'Wave: ' + wave,
      'Time: ' + Math.floor(gameTime) + 's',
      'Level: ' + player.level,
      'WPM: ' + wpm
    ];
    statsEl.textContent = lines.join('\n');
    statsEl.style.whiteSpace = 'pre-line';
  }

  // === [SEC:LITNUKE] LITERARY NUKE SYSTEM ===
  // Every 100 words: "LITERARY NUKE" appears in rainbow glory, nukes the screen, 3s rainbow mario mode

  function checkLitNukeTrigger() {
    litNukeWordCount++;
    if (litNukeWordCount >= LIT_NUKE_WORDS_REQUIRED) {
      triggerLiteraryNuke();
      litNukeWordCount = 0;
    }
  }

  function triggerLiteraryNuke() {
    litNukeAnimating = true;
    litNukeAnimTimer = 0;
    shakeIntensity = 30; // Big screen shake

    // Play epic sound
    playTone(150, 0.4, 'sawtooth', 0.3);
    setTimeout(() => playTone(200, 0.3, 'sawtooth', 0.25), 100);
    setTimeout(() => playTone(300, 0.2, 'sawtooth', 0.2), 200);
    setTimeout(() => {
      // Nuke sound
      playTone(80, 0.5, 'sawtooth', 0.4);
      playTone(60, 0.6, 'square', 0.3);
    }, 400);
  }

  function executeLiteraryNuke() {
    // Kill ALL enemies on screen
    const enemiesToKill = [...enemies.active];
    for (const e of enemiesToKill) {
      stats.enemiesKilled++;

      // Spawn XP gem
      gems.acquire(e.x, e.y, e.maxHealth);

      // Spawn glorious particles
      spawnParticles(e.x, e.y, 15, getRainbowColor(Math.random()));

      // Handle targeting
      if (e === targetEnemy) {
        handleTargetAfterDeath(e);
      }
      firedAtEnemies.delete(e);
      enemies.release(e);
    }

    // Collect ALL gems immediately
    const gemsToCollect = [...gems.active];
    for (const g of gemsToCollect) {
      player.xp += g.value;
      spawnParticles(g.x, g.y, 5, getRainbowColor(Math.random()));
      gems.release(g);
    }
    checkLevelUp();

    // Collect ALL item drops
    for (let i = itemDrops.length - 1; i >= 0; i--) {
      const drop = itemDrops[i];
      addItem(drop.item.id);
      itemDrops.splice(i, 1);
    }

    // Activate rainbow mario mode
    litNukeActive = true;
    litNukeTimer = LIT_NUKE_DURATION;

    // Play triumphant sound
    playTone(523, 0.15, 'sine', 0.2);
    setTimeout(() => playTone(659, 0.15, 'sine', 0.2), 100);
    setTimeout(() => playTone(784, 0.15, 'sine', 0.2), 200);
    setTimeout(() => playTone(1047, 0.3, 'sine', 0.25), 300);
  }

  function updateLiteraryNuke(dt) {
    // Update explosion animation
    if (litNukeAnimating) {
      litNukeAnimTimer += dt;
      shakeIntensity = Math.max(shakeIntensity, 20 * (1 - litNukeAnimTimer / LIT_NUKE_ANIM_DURATION));

      // Execute nuke at peak of animation
      if (litNukeAnimTimer >= 0.6 && !litNukeActive) {
        executeLiteraryNuke();
      }

      if (litNukeAnimTimer >= LIT_NUKE_ANIM_DURATION) {
        litNukeAnimating = false;
      }
    }

    // Update rainbow mario mode timer
    if (litNukeActive) {
      litNukeTimer -= dt;
      if (litNukeTimer <= 0) {
        litNukeActive = false;
        litNukeTimer = 0;
      }
    }
  }

  function getRainbowColor(t) {
    // Returns a rainbow color based on t (0-1)
    const hue = (t * 360) % 360;
    return `hsl(${hue}, 100%, 50%)`;
  }

  function getAnimatedRainbowColor(offset = 0) {
    // Returns a rainbow color that animates over time
    const t = (performance.now() / 500 + offset) % 1;
    return getRainbowColor(t);
  }

  function drawLiteraryNukeEffect() {
    if (!litNukeAnimating && !litNukeActive) return;

    ctx.save();

    if (litNukeAnimating) {
      const progress = litNukeAnimTimer / LIT_NUKE_ANIM_DURATION;

      // Explosion ring expanding from center
      if (progress < 0.8) {
        const ringProgress = progress / 0.8;
        const ringRadius = ringProgress * Math.max(canvasWidth, canvasHeight);
        const ringAlpha = 1 - ringProgress;

        // Multiple rainbow rings
        for (let i = 0; i < 5; i++) {
          const offset = i * 0.1;
          const r = Math.max(0, ringRadius - i * 40);
          ctx.strokeStyle = getRainbowColor((ringProgress + offset) % 1);
          ctx.lineWidth = 20 - i * 3;
          ctx.globalAlpha = ringAlpha * (1 - i * 0.15);
          ctx.beginPath();
          ctx.arc(canvasWidth / 2, canvasHeight / 2, r, 0, Math.PI * 2);
          ctx.stroke();
        }
      }

      // "LITERARY NUKE" text with rainbow animation
      const textProgress = Math.min(1, progress * 2);
      const scale = 0.5 + textProgress * 1.5;
      const textAlpha = progress < 0.7 ? 1 : 1 - (progress - 0.7) / 0.3;

      ctx.globalAlpha = textAlpha;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';

      // Draw each letter with different rainbow color
      const text = 'LITERARY NUKE';
      const fontSize = 80 * scale;
      ctx.font = `bold ${fontSize}px 'Courier Prime', monospace`;

      const totalWidth = ctx.measureText(text).width;
      let x = canvasWidth / 2 - totalWidth / 2;
      const y = canvasHeight / 2;

      for (let i = 0; i < text.length; i++) {
        const char = text[i];
        const charWidth = ctx.measureText(char).width;
        const hueOffset = i / text.length;
        const wobble = Math.sin(performance.now() / 50 + i) * 5 * scale;

        // Glow
        ctx.fillStyle = getRainbowColor((performance.now() / 200 + hueOffset) % 1);
        ctx.shadowColor = ctx.fillStyle;
        ctx.shadowBlur = 30;

        ctx.fillText(char, x + charWidth / 2, y + wobble);
        x += charWidth;
      }

      ctx.shadowBlur = 0;
    }

    // Rainbow border during active mode
    if (litNukeActive) {
      const borderWidth = 8;
      const segments = 60;

      for (let i = 0; i < segments; i++) {
        const progress = i / segments;
        ctx.strokeStyle = getRainbowColor((performance.now() / 300 + progress) % 1);
        ctx.lineWidth = borderWidth;
        ctx.globalAlpha = 0.8;

        // Top edge
        const segWidth = canvasWidth / (segments / 4);
        if (i < segments / 4) {
          ctx.beginPath();
          ctx.moveTo(i * segWidth * 4 / segments * canvasWidth, 0);
          ctx.lineTo((i + 1) * segWidth * 4 / segments * canvasWidth, 0);
          ctx.stroke();
        }
        // Right edge
        else if (i < segments / 2) {
          const j = i - segments / 4;
          ctx.beginPath();
          ctx.moveTo(canvasWidth, j * 4 / segments * canvasHeight);
          ctx.lineTo(canvasWidth, (j + 1) * 4 / segments * canvasHeight);
          ctx.stroke();
        }
        // Bottom edge
        else if (i < segments * 3 / 4) {
          const j = i - segments / 2;
          ctx.beginPath();
          ctx.moveTo(canvasWidth - j * 4 / segments * canvasWidth, canvasHeight);
          ctx.lineTo(canvasWidth - (j + 1) * 4 / segments * canvasWidth, canvasHeight);
          ctx.stroke();
        }
        // Left edge
        else {
          const j = i - segments * 3 / 4;
          ctx.beginPath();
          ctx.moveTo(0, canvasHeight - j * 4 / segments * canvasHeight);
          ctx.lineTo(0, canvasHeight - (j + 1) * 4 / segments * canvasHeight);
          ctx.stroke();
        }
      }

      // Timer display
      ctx.globalAlpha = 1;
      ctx.fillStyle = getAnimatedRainbowColor();
      ctx.font = 'bold 24px "Courier Prime", monospace';
      ctx.textAlign = 'center';
      ctx.fillText(`RAINBOW MODE: ${litNukeTimer.toFixed(1)}s`, canvasWidth / 2, 40);
    }

    // Progress bar toward next LITERARY NUKE (subtle, bottom of screen)
    if (!litNukeActive && !litNukeAnimating && litNukeWordCount > 0) {
      const progress = litNukeWordCount / LIT_NUKE_WORDS_REQUIRED;
      const barWidth = canvasWidth * 0.3;
      const barHeight = 6;
      const barX = canvasWidth / 2 - barWidth / 2;
      const barY = canvasHeight - 30;

      // Background
      ctx.fillStyle = 'rgba(26, 23, 20, 0.3)';
      ctx.fillRect(barX, barY, barWidth, barHeight);

      // Progress fill (rainbow gradient as it fills)
      if (progress > 0) {
        const gradient = ctx.createLinearGradient(barX, barY, barX + barWidth * progress, barY);
        gradient.addColorStop(0, getRainbowColor(0));
        gradient.addColorStop(0.33, getRainbowColor(0.33));
        gradient.addColorStop(0.66, getRainbowColor(0.66));
        gradient.addColorStop(1, getRainbowColor(1));
        ctx.fillStyle = gradient;
        ctx.fillRect(barX, barY, barWidth * progress, barHeight);
      }

      // Label
      ctx.globalAlpha = 0.7;
      ctx.fillStyle = '#1a1714';
      ctx.font = '10px "Courier Prime", monospace';
      ctx.textAlign = 'center';
      ctx.fillText(`${litNukeWordCount}/${LIT_NUKE_WORDS_REQUIRED}`, canvasWidth / 2, barY - 5);
    }

    ctx.restore();
  }

  // Kill enemies during white space when in rainbow mario mode
  function litNukeWhiteSpaceKill() {
    if (!litNukeActive || !inWhiteSpace) return;

    // Player can collide with and kill enemies during movement
    enemies.forEach(e => {
      const dist = Math.hypot(e.x - player.x, e.y - player.y);
      if (dist < player.radius + e.radius + 20) {
        // Instant kill with rainbow explosion
        stats.enemiesKilled++;
        gems.acquire(e.x, e.y, e.maxHealth);
        spawnParticles(e.x, e.y, 20, getAnimatedRainbowColor(e.x / canvasWidth));
        playTone(400 + Math.random() * 400, 0.1, 'sine', 0.15);

        if (e === targetEnemy) {
          handleTargetAfterDeath(e);
        }
        firedAtEnemies.delete(e);
        enemies.release(e);
      }
    });
  }

  // === [SEC:RENDER] RENDER LOOP ===
  function render(alpha) {
    // Apply screen shake (respect reduced motion)
    const shakeX = prefersReducedMotion ? 0 : (Math.random() - 0.5) * shakeIntensity;
    const shakeY = prefersReducedMotion ? 0 : (Math.random() - 0.5) * shakeIntensity;

    ctx.save();
    ctx.translate(shakeX, shakeY);

    // Underwood: No sepia filter needed - paper background is naturally warm
    ctx.filter = 'none';

    // Clear - lerp from paper to paper-dark in white space (time-stop)
    // paper: #f4f1e8 (244, 241, 232) -> paper-dark: #e8dcc8 (232, 220, 200)
    const bgR = Math.round(244 - (12 * whiteSpaceAlpha));
    const bgG = Math.round(241 - (21 * whiteSpaceAlpha));
    const bgB = Math.round(232 - (32 * whiteSpaceAlpha));
    ctx.fillStyle = `rgb(${bgR}, ${bgG}, ${bgB})`;
    ctx.fillRect(-10, -10, canvasWidth + 20, canvasHeight + 20);

    // Draw subtle ruled paper lines (horizontal only, like notebook paper)
    ctx.strokeStyle = CONFIG.COLORS.GRID;
    ctx.lineWidth = 1;
    const lineSpacing = 32;

    for (let y = lineSpacing; y < canvasHeight; y += lineSpacing) {
      ctx.beginPath();
      ctx.moveTo(0, y);
      ctx.lineTo(canvasWidth, y);
      ctx.stroke();
    }

    // Optional: margin line on left side
    ctx.strokeStyle = 'rgba(196, 30, 58, 0.08)'; // subtle ribbon-red
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(60, 0);
    ctx.lineTo(60, canvasHeight);
    ctx.stroke();

    // Draw gems (carbon-blue ink drops) - flat style
    gems.forEach(g => {
      const pulse = prefersReducedMotion ? 1 : (1 + Math.sin(performance.now() / 200 + g.x) * 0.1);
      const r = g.radius * pulse;

      // Simple filled circle - no glow
      ctx.fillStyle = CONFIG.COLORS.GEM;
      ctx.beginPath();
      ctx.arc(g.x, g.y, r, 0, Math.PI * 2);
      ctx.fill();
    });

    // Draw item drops
    drawItemDrops();

    // Draw item effects (below enemies)
    drawInkPools();
    drawMarginNotes();

    // Draw enemies (rounded rectangles - key-cap shapes)
    enemies.forEach(e => {
      const isTarget = e === targetEnemy;
      const scale = e.visualScale || 1;
      const drawRadius = e.radius * scale;
      const floatY = e.floatOffset || 0;
      const size = drawRadius * 1.8; // Convert radius to square size
      const cornerRadius = Math.min(6, size * 0.15);

      ctx.save();
      ctx.globalAlpha = e.invisibility ?? 1;

      // Time-stop effect: grayscale + offset shadow
      if (whiteSpaceAlpha > 0) {
        ctx.globalAlpha = (e.invisibility ?? 1) * (1 - 0.3 * whiteSpaceAlpha);
        ctx.filter = `grayscale(${0.3 * whiteSpaceAlpha})`;
        // Carbon-blue offset shadow during time-stop
        ctx.fillStyle = `rgba(45, 74, 111, ${0.4 * whiteSpaceAlpha})`;
        ctx.beginPath();
        ctx.roundRect(e.x - size/2 + 3, e.y + floatY - size/2 + 3, size, size, cornerRadius);
        ctx.fill();
      }

      // Glow for targeted
      if (isTarget) {
        ctx.fillStyle = 'rgba(196, 30, 58, 0.25)';
        ctx.beginPath();
        ctx.roundRect(e.x - size/2 - 6, e.y + floatY - size/2 - 6, size + 12, size + 12, cornerRadius + 4);
        ctx.fill();
      }

      // Determine enemy color - fast enemies get ribbon-red
      let enemyColor = e.color || CONFIG.COLORS.ENEMY;
      if (e.type === 'shout' || e.type === 'stutter') {
        enemyColor = CONFIG.COLORS.ENEMY_FAST;
      }
      if (isTarget) {
        enemyColor = CONFIG.COLORS.ENEMY_TARGET;
      }

      // Body - simple flat rounded rectangle
      ctx.fillStyle = enemyColor;
      ctx.beginPath();
      ctx.roundRect(e.x - size/2, e.y + floatY - size/2, size, size, cornerRadius);
      ctx.fill();

      // Elite visual effects
      for (const modId of (e.eliteModifiers || [])) {
        const mod = ELITE_MODIFIERS[modId];
        if (mod?.visualEffect) {
          const origY = e.y;
          e.y = e.y + floatY;
          mod.visualEffect(ctx, e);
          e.y = origY;
        }
      }

      // Health bar
      const barWidth = size;
      const barHeight = 4;
      const barY = e.y + floatY - size/2 - 10;

      ctx.fillStyle = 'rgba(26, 23, 20, 0.4)';
      ctx.fillRect(e.x - barWidth/2, barY, barWidth, barHeight);

      ctx.fillStyle = '#4a7c59'; // tier-uncommon green for health
      ctx.fillRect(e.x - barWidth/2, barY, (e.health / e.maxHealth) * barWidth, barHeight);

      ctx.restore();
    });

    // Draw projectiles (carbon-blue ink drops) - flat style
    projectiles.forEach(p => {
      // Simple filled circle - no glow
      ctx.fillStyle = CONFIG.COLORS.PROJECTILE;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
      ctx.fill();
    });

    // Draw particles
    particles.forEach(p => {
      const alpha = p.life / p.maxLife;
      ctx.globalAlpha = alpha;
      ctx.fillStyle = p.color;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.radius * alpha, 0, Math.PI * 2);
      ctx.fill();
    });
    ctx.globalAlpha = 1;

    // Draw damage numbers (Underwood colors with typed/stamped feel)
    const DN_COLORS = {
      damage: CONFIG.COLORS.DAMAGE_NORMAL,
      crit: CONFIG.COLORS.DAMAGE_CRIT,
      playerDamage: CONFIG.COLORS.DAMAGE_PLAYER,
      heal: CONFIG.COLORS.DAMAGE_HEAL,
      xp: CONFIG.COLORS.DAMAGE_XP
    };
    const DN_SIZES = { damage: 16, crit: 24, playerDamage: 20, heal: 16, xp: 13 };

    damageNumbers.forEach((dn) => {
      const alpha = dn.life / dn.maxLife;
      const shakeX = dn.shake > 0 ? (Math.random() - 0.5) * dn.shake * 2 : 0;

      ctx.save();
      ctx.globalAlpha = alpha;
      if (!prefersReducedMotion) ctx.rotate(-0.05); // Slight rotation for stamped feel

      // White shadow for readability on paper background
      ctx.fillStyle = 'rgba(244, 241, 232, 0.8)';
      ctx.font = `bold ${DN_SIZES[dn.type]}px 'Courier Prime', monospace`;
      ctx.textAlign = 'center';
      ctx.fillText(dn.text, dn.x + shakeX + 1, dn.y + 1);

      // Main text
      ctx.fillStyle = DN_COLORS[dn.type];
      ctx.fillText(dn.text, dn.x + shakeX, dn.y);

      ctx.restore();
    });
    ctx.globalAlpha = 1;

    // Draw player - flat style with ink color (or RAINBOW during mario mode!)
    const playerSize = player.radius * 2;
    const playerCorner = 6;

    // Rainbow mario mode: epic rainbow glow and trail
    if (litNukeActive && !prefersReducedMotion) {
      // Rainbow trail particles
      for (let i = 0; i < 3; i++) {
        const trailX = player.x + (Math.random() - 0.5) * 30;
        const trailY = player.y + (Math.random() - 0.5) * 30;
        ctx.fillStyle = getAnimatedRainbowColor(i * 0.3);
        ctx.globalAlpha = 0.5;
        ctx.beginPath();
        ctx.arc(trailX, trailY, 5 + Math.random() * 5, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.globalAlpha = 1;

      // Rainbow glow
      const glowSize = playerSize + 15 + Math.sin(performance.now() / 100) * 5;
      ctx.strokeStyle = getAnimatedRainbowColor();
      ctx.lineWidth = 5;
      ctx.shadowColor = getAnimatedRainbowColor(0.5);
      ctx.shadowBlur = 20;
      ctx.beginPath();
      ctx.roundRect(
        player.x - glowSize/2,
        player.y - glowSize/2,
        glowSize,
        glowSize,
        playerCorner + 4
      );
      ctx.stroke();
      ctx.shadowBlur = 0;
    }
    // Subtle border glow during time-stop only (when not in rainbow mode)
    else if (whiteSpaceAlpha > 0) {
      ctx.strokeStyle = `rgba(212, 168, 75, ${0.6 * whiteSpaceAlpha})`;
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.roundRect(
        player.x - playerSize/2 - 2,
        player.y - playerSize/2 - 2,
        playerSize + 4,
        playerSize + 4,
        playerCorner + 2
      );
      ctx.stroke();
    }

    // Mercy invincibility flash (blink player during i-frames)
    if (performance.now() < mercyInvincibleUntil && !prefersReducedMotion) {
      const flash = Math.sin(performance.now() / 50) * 0.5 + 0.5;
      ctx.globalAlpha = 0.3 + flash * 0.7;
    }

    // Main body - rainbow cycling during mario mode, flat ink otherwise
    if (litNukeActive) {
      ctx.fillStyle = getAnimatedRainbowColor();
      ctx.shadowColor = getAnimatedRainbowColor(0.5);
      ctx.shadowBlur = 15;
    } else {
      ctx.fillStyle = CONFIG.COLORS.INK;
    }
    ctx.beginPath();
    ctx.roundRect(
      player.x - playerSize/2,
      player.y - playerSize/2,
      playerSize,
      playerSize,
      playerCorner
    );
    ctx.fill();
    ctx.shadowBlur = 0;

    // Health arc - rainbow during mario mode
    const healthPercent = player.health / player.maxHealth;
    if (litNukeActive) {
      ctx.strokeStyle = getAnimatedRainbowColor(0.3);
    } else {
      ctx.strokeStyle = healthPercent > 0.3 ? '#4a7c59' : '#c41e3a';
    }
    ctx.lineWidth = 3;

    const healthArc = healthPercent * Math.PI * 2;
    ctx.beginPath();
    ctx.arc(
      player.x, player.y,
      playerSize/2 + 5,
      -Math.PI / 2,
      -Math.PI / 2 + healthArc
    );
    ctx.stroke();
    ctx.globalAlpha = 1; // Reset after mercy flash

    // Draw LITERARY NUKE effect (explosion, text, rainbow border)
    drawLiteraryNukeEffect();

    ctx.restore();
  }

  // === [SEC:GAMELOOP] GAME LOOP ===
  function gameLoop(currentTime) {
    if (!running) return;
    requestAnimationFrame(gameLoop);

    const frameTime = Math.min((currentTime - lastTime) / 1000, 0.25);
    lastTime = currentTime;
    accumulator += frameTime;

    // Smoothly transition white space visual effect (runs regardless of game state)
    const targetAlpha = inWhiteSpace ? 1 : 0;
    if (whiteSpaceAlpha !== targetAlpha) {
      const delta = WHITE_SPACE_FADE_SPEED * frameTime;
      if (whiteSpaceAlpha < targetAlpha) {
        whiteSpaceAlpha = Math.min(whiteSpaceAlpha + delta, 1);
      } else {
        whiteSpaceAlpha = Math.max(whiteSpaceAlpha - delta, 0);
      }
    }

    while (accumulator >= CONFIG.FIXED_DT) {
      update(CONFIG.FIXED_DT);
      accumulator -= CONFIG.FIXED_DT;
    }

    render(accumulator / CONFIG.FIXED_DT);
  }

  // === [SEC:MANAGEMENT] GAME MANAGEMENT ===
  function startGame(isDaily = false) {
    initAudio();
    lastDamageSource = null;

    // Reset player
    player.x = canvasWidth / 2;
    player.y = canvasHeight / 2;
    player.health = 100;
    player.maxHealth = 100;
    player.xp = 0;
    player.level = 1;
    player.xpToNext = CONFIG.XP_BASE;

    // Reset modifiers
    Object.assign(mods, {
      damageMultiplier: 1,
      speedBonus: 0,
      pickupRange: 1,
      comboBonus: 0,
      armorMultiplier: 1,
      regenRate: 0,
      doubleLetterAOE: false,
      vowelHeal: false,
      critChance: 0,
      pierce: 1
    });

    // Reset stats
    stats = {
      wordsTyped: 0,
      enemiesKilled: 0,
      totalChars: 0,
      startTime: performance.now(),
      combo: 0,
      maxCombo: 0,
      lastComboTime: 0,
      longestWord: '',
      isDaily: isDaily
    };

    // Reset state
    gameTime = 0;
    spawnTimer = CONFIG.SPAWN_INITIAL_DELAY;
    currentWord = '';
    typedIndex = 0;
    targetEnemy = null;
    acquiredUpgrades = [];
    shakeIntensity = 0;
    inWhiteSpace = false;
    mercyInvincibleUntil = 0;
    lastTrackedWave = 0;
    footnoteCounter = 0;
    footnoteNeedsSpace = false;
    itemNotificationQueue.length = 0; // Clear any pending notifications
    itemNotificationActive = false;
    pendingItems.length = 0; // Clear pending items queue
    collectionMenuOpen = false;

    // Reset LITERARY NUKE state
    litNukeWordCount = 0;
    litNukeActive = false;
    litNukeTimer = 0;
    litNukeAnimating = false;
    litNukeAnimTimer = 0;
    updatePendingWidget(); // Hide the widget
    document.getElementById('collectionMenu').classList.add('hidden'); // Hide collection menu
    whiteSpaceAlpha = 0;
    lastKilledWord = null; // Reset for Echo enemies
    clearTimeout(mouseIdleTimer);

    // Initialize mouse position to center
    lastMouseX = canvasWidth / 2;
    lastMouseY = canvasHeight / 2;

    // Clear pools
    enemies.releaseAll();
    projectiles.releaseAll();
    gems.releaseAll();
    particles.releaseAll();
    damageNumbers.releaseAll();
    firedAtEnemies.clear();
    recentDamagePositions.clear();

    // Reset item system
    resetItemSystem();

    // Set daily seed if applicable
    if (isDaily) {
      // Simple seeded random for daily challenge
      const seed = getDailySeed();
      let s = seed;
      window._originalMathRandom = Math.random;
      Math.random = function() {
        s = (s * 9301 + 49297) % 233280;
        return s / 233280;
      };
    }

    // Update UI
    document.getElementById('menu').classList.add('hidden');
    document.getElementById('gameOver').classList.add('hidden');
    document.getElementById('stats').classList.remove('hidden');
    document.getElementById('healthBar').classList.remove('hidden');
    document.getElementById('xpBar').classList.remove('hidden');
    document.getElementById('inventoryDisplay').classList.remove('hidden');
    document.getElementById('activeItems').classList.remove('hidden');
    document.getElementById('passiveItems').classList.remove('hidden');

    updateHealthBar();
    updateXPBar();
    updateActiveItemsDisplay();
    updatePassiveItemsDisplay();
    updateWordDisplay();
    updateComboDisplay();

    // Start
    gameState = 'playing';
    running = true;
    lastTime = performance.now();
    requestAnimationFrame(gameLoop);

    // Focus mobile input for keyboard capture
    focusMobileInput();

    // On mobile, statically reserve space for the virtual keyboard
    if (isMobileDevice) {
      document.body.classList.add('keyboard-open');
    }

    // Show movement tip on first play (with delay so player sees the game first)
    setTimeout(() => {
      if (gameState === 'playing') {
        showTip('whitespace');
      }
    }, 1500);
  }

  function endGame() {
    gameState = 'gameOver';
    running = false;
    document.body.classList.remove('keyboard-open');

    // Restore Math.random if it was overridden
    if (window._originalMathRandom) {
      Math.random = window._originalMathRandom;
      delete window._originalMathRandom;
    }

    saveGame();

    // Show final stats
    const wave = Math.floor(gameTime / 20) + 1;
    const wpm = calculateWPM();

    const finalStatsEl = document.getElementById('finalStats');
    finalStatsEl.textContent = '';

    const statsData = [
      ['Wave Reached:', wave],
      ['Time Survived:', Math.floor(gameTime) + 's'],
      ['Level:', player.level],
      ['Words Typed:', stats.wordsTyped],
      ['WPM:', wpm],
      ['Max Combo:', stats.maxCombo + 'x'],
      ['Longest Word:', stats.longestWord || 'N/A']
    ];

    if (lastDamageSource) {
      statsData.push(['Killed by:', lastDamageSource.charAt(0).toUpperCase() + lastDamageSource.slice(1)]);
    }

    statsData.forEach(([label, value]) => {
      const row = document.createElement('div');

      const labelSpan = document.createElement('span');
      labelSpan.className = 'label';
      labelSpan.textContent = label;
      row.appendChild(labelSpan);

      const valueSpan = document.createElement('span');
      valueSpan.className = 'value';
      valueSpan.textContent = value;
      row.appendChild(valueSpan);

      finalStatsEl.appendChild(row);
    });

    document.getElementById('shareResult').textContent = generateShareText();

    document.getElementById('stats').classList.add('hidden');
    document.getElementById('healthBar').classList.add('hidden');
    document.getElementById('xpBar').classList.add('hidden');
    document.getElementById('inventoryDisplay').classList.add('hidden');
    document.getElementById('activeItems').classList.add('hidden');
    document.getElementById('passiveItems').classList.add('hidden');
    document.getElementById('wordDisplay').textContent = '';
    document.getElementById('combo').classList.add('hidden');
    hideItemHoverTooltip(); // Hide any open item tooltip
    document.getElementById('gameOver').classList.remove('hidden');
  }

  function pauseGame() {
    if (gameState !== 'playing') return;
    exitWhiteSpace(); // Exit white space when pausing
    hideItemHoverTooltip(); // Hide any open item tooltip
    gameState = 'paused';
    running = false;
    document.getElementById('pauseMenu').classList.remove('hidden');
    // Show practice toggle button when in practice mode
    const practiceToggle = document.getElementById('practiceToggleBtn');
    if (practiceToggle) {
      practiceToggle.style.display = practiceMode ? 'block' : 'none';
    }
  }

  function resumeGame() {
    if (gameState !== 'paused') return;
    document.getElementById('pauseMenu').classList.add('hidden');
    // Also hide debug panel when resuming
    const debugPanel = document.getElementById('debugPanel');
    if (debugPanel) debugPanel.classList.add('hidden');
    gameState = 'playing';
    running = true;
    lastTime = performance.now();
    requestAnimationFrame(gameLoop);
  }

  function quitGame() {
    document.getElementById('pauseMenu').classList.add('hidden');
    document.getElementById('stats').classList.add('hidden');
    document.getElementById('healthBar').classList.add('hidden');
    document.getElementById('xpBar').classList.add('hidden');
    document.getElementById('activeItems').classList.add('hidden');
    document.getElementById('passiveItems').classList.add('hidden');
    document.getElementById('wordDisplay').textContent = '';
    document.getElementById('combo').classList.add('hidden');
    document.getElementById('menu').classList.remove('hidden');
    // Hide debug panel and reset practice mode
    const debugPanel = document.getElementById('debugPanel');
    if (debugPanel) debugPanel.classList.add('hidden');
    practiceMode = false;

    gameState = 'menu';
    running = false;
  }

  // === [SEC:SHARING] SHARING ===
  function generateShareText() {
    const wave = Math.floor(gameTime / 20) + 1;
    const wpm = calculateWPM();

    // Create Wordle-style grid
    const grid = [];
    for (let i = 1; i <= 10; i += 2) {
      if (wave >= i + 1) {
        grid.push(String.fromCodePoint(0x1F7E9)); // Green
      } else if (wave >= i) {
        grid.push(String.fromCodePoint(0x1F7E8)); // Yellow
      } else {
        grid.push(String.fromCodePoint(0x2B1B)); // Black
      }
    }

    const daily = stats.isDaily ? ' #Daily' : '';

    return 'Word Survivor' + daily + '\n' +
      'Wave ' + wave + ' | ' + Math.floor(gameTime) + 's | ' + wpm + ' WPM\n' +
      grid.join('') + '\n' +
      'Max Combo: ' + stats.maxCombo + 'x';
  }

  async function shareResult() {
    const text = generateShareText();
    const url = window.location.href;

    if (navigator.share) {
      try {
        await navigator.share({
          title: 'Word Survivor',
          text: text + '\n\nPlay now:',
          url: url
        });
        return;
      } catch (e) {
        // Fall through to clipboard
      }
    }

    // Fallback to clipboard
    const fullText = text + '\n\n' + url;

    if (navigator.clipboard) {
      try {
        await navigator.clipboard.writeText(fullText);
        alert('Copied to clipboard!');
        return;
      } catch (e) {
        // Fall through to prompt
      }
    }

    prompt('Copy your result:', fullText);
  }

  // === [SEC:PERSISTENCE] PERSISTENCE ===
  const STORAGE_KEY = 'word_survivor_save';

  function saveGame() {
    const existing = loadGame() || {};

    const save = {
      highScore: Math.max(player.level, existing.highScore || 0),
      highWave: Math.max(Math.floor(gameTime / 20) + 1, existing.highWave || 0),
      totalGames: (existing.totalGames || 0) + 1,
      totalWordsTyped: (existing.totalWordsTyped || 0) + stats.wordsTyped,
      bestWPM: Math.max(calculateWPM(), existing.bestWPM || 0),
      lastPlayed: new Date().toISOString()
    };

    // Daily challenge tracking
    const today = new Date().toDateString();
    if (stats.isDaily) {
      save.dailyChallengeDate = today;
      save.dailyBestWave = Math.max(
        Math.floor(gameTime / 20) + 1,
        existing.dailyChallengeDate === today ? existing.dailyBestWave || 0 : 0
      );
    } else {
      save.dailyChallengeDate = existing.dailyChallengeDate;
      save.dailyBestWave = existing.dailyBestWave;
    }

    try {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(save));
    } catch (e) {
      console.warn('Save failed:', e);
    }
  }

  function loadGame() {
    try {
      const data = localStorage.getItem(STORAGE_KEY);
      return data ? JSON.parse(data) : null;
    } catch (e) {
      return null;
    }
  }

  function getDailySeed() {
    const date = new Date();
    return date.getFullYear() * 10000 + (date.getMonth() + 1) * 100 + date.getDate();
  }

  // --- [SEC:MANAGEMENT:VISIBILITY] VISIBILITY HANDLING ---
  document.addEventListener('visibilitychange', () => {
    if (document.hidden && gameState === 'playing') {
      pauseGame();
      if (audioCtx) audioCtx.suspend();
    } else if (!document.hidden && audioCtx) {
      audioCtx.resume();
    }
  });

  // --- [SEC:MANAGEMENT:ERRORS] ERROR HANDLING ---
  window.onerror = (msg, url, line, col, error) => {
    console.error('Game error:', { msg, url, line, col });
    return true;
  };

  window.onunhandledrejection = (e) => {
    console.error('Unhandled rejection:', e.reason);
  };

  // --- [SEC:UI:BUTTONS] BUTTON HANDLERS ---
  // Focus mobile input immediately on click (required for iOS keyboard to appear)
  document.getElementById('startBtn').addEventListener('click', () => {
    focusMobileInput(true);  // Immediate focus within user gesture
    startGame(false);
  });
  document.getElementById('restartBtn').addEventListener('click', () => {
    focusMobileInput(true);
    startGame(false);
  });
  document.getElementById('resumeBtn').addEventListener('click', () => {
    focusMobileInput(true);
    resumeGame();
  });
  document.getElementById('quitBtn').addEventListener('click', quitGame);
  document.getElementById('shareBtn').addEventListener('click', shareResult);

  // Pending items widget and collection menu event listeners
  document.getElementById('pendingItemsWidget').addEventListener('click', () => {
    if (gameState === 'playing' && pendingItems.length > 0) {
      openCollectionMenu();
    }
  });
  document.getElementById('collectAllBtn').addEventListener('click', collectAllItems);
  document.getElementById('closeCollectionBtn').addEventListener('click', closeCollectionMenu);

  // === [SEC:UI] MODAL SYSTEM ===
  const modalOverlay = document.getElementById('modalOverlay');
  const howToPlayModal = document.getElementById('howToPlayModal');
  const collectionModal = document.getElementById('collectionModal');
  const howToPlayBtn = document.getElementById('howToPlayBtn');
  const collectionBtn = document.getElementById('collectionBtn');
  const closeHowToPlay = document.getElementById('closeHowToPlay');
  const closeCollection = document.getElementById('closeCollection');

  function openModal(modal) {
    modalOverlay.classList.remove('hidden');
    modal.classList.remove('hidden');
  }

  function closeAllModals() {
    modalOverlay.classList.add('hidden');
    howToPlayModal.classList.add('hidden');
    collectionModal.classList.add('hidden');
  }

  function isAnyModalOpen() {
    return !modalOverlay.classList.contains('hidden');
  }

  // Modal open handlers
  howToPlayBtn.addEventListener('click', () => openModal(howToPlayModal));
  collectionBtn.addEventListener('click', () => {
    populateItemsList();
    populateUpgradesList();
    populateEnemiesList();
    openModal(collectionModal);
  });

  // Modal close handlers
  closeHowToPlay.addEventListener('click', closeAllModals);
  closeCollection.addEventListener('click', closeAllModals);
  modalOverlay.addEventListener('click', closeAllModals);

  // Tab switching for Collection modal
  const tabBtns = document.querySelectorAll('.tab-btn');
  tabBtns.forEach(btn => {
    btn.addEventListener('click', () => {
      const tabName = btn.dataset.tab;
      // Update active tab button
      tabBtns.forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      // Show corresponding content
      document.querySelectorAll('.tab-content').forEach(content => {
        content.classList.remove('active');
      });
      document.getElementById(tabName + 'Tab').classList.add('active');
    });
  });

  // Tier filter for items
  const tierBtns = document.querySelectorAll('.tier-btn');
  tierBtns.forEach(btn => {
    btn.addEventListener('click', () => {
      const tier = btn.dataset.tier;
      tierBtns.forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      filterItemsByTier(tier);
    });
  });

  function filterItemsByTier(tier) {
    const entries = document.querySelectorAll('#itemsList .item-entry');
    entries.forEach(entry => {
      if (tier === 'all' || entry.dataset.tier === tier) {
        entry.style.display = 'flex';
      } else {
        entry.style.display = 'none';
      }
    });
  }

  // === [SEC:DEBUG] PRACTICE MODE ===
  const debugPanel = document.getElementById('debugPanel');
  const practiceBtn = document.getElementById('practiceBtn');
  const exitPracticeBtn = document.getElementById('exitPractice');

  // Tooltip elements
  const debugTooltip = document.getElementById('debugTooltip');
  const tooltipTitle = document.getElementById('tooltipTitle');
  const tooltipDesc = document.getElementById('tooltipDesc');
  const tooltipMeta = document.getElementById('tooltipMeta');

  function showTooltip(e, title, desc, meta = '') {
    tooltipTitle.textContent = title;
    tooltipDesc.textContent = desc;
    tooltipMeta.textContent = meta;
    tooltipMeta.style.display = meta ? 'block' : 'none';

    // Position tooltip near cursor
    const x = e.clientX + 15;
    const y = e.clientY + 15;

    // Keep tooltip on screen
    const maxX = window.innerWidth - 300;
    const maxY = window.innerHeight - 150;

    debugTooltip.style.left = Math.min(x, maxX) + 'px';
    debugTooltip.style.top = Math.min(y, maxY) + 'px';
    debugTooltip.classList.add('visible');
  }

  function hideTooltip() {
    debugTooltip.classList.remove('visible');
  }

  function moveTooltip(e) {
    const x = e.clientX + 15;
    const y = e.clientY + 15;
    const maxX = window.innerWidth - 300;
    const maxY = window.innerHeight - 150;
    debugTooltip.style.left = Math.min(x, maxX) + 'px';
    debugTooltip.style.top = Math.min(y, maxY) + 'px';
  }

  // Selected spawn type and elite modifier
  let selectedEliteModifier = null;

  // Categorize enemies by wave
  const ENEMY_CATEGORIES = {
    early: [], // Wave 1-2
    mid: [],   // Wave 3-6
    late: []   // Wave 7+
  };

  // Categorize items by tier
  const ITEM_CATEGORIES = {
    WHITE: [],
    GREEN: [],
    RED: [],
    LEGENDARY: []
  };

  function initPracticeMode() {
    // Only categorize if not already done
    if (ENEMY_CATEGORIES.early.length === 0) {
      // Categorize enemies by minWave
      Object.keys(ENEMY_TYPES).forEach(typeId => {
        const type = ENEMY_TYPES[typeId];
        if (type.minWave <= 2) {
          ENEMY_CATEGORIES.early.push(typeId);
        } else if (type.minWave <= 6) {
          ENEMY_CATEGORIES.mid.push(typeId);
        } else {
          ENEMY_CATEGORIES.late.push(typeId);
        }
      });

      // Categorize items by tier
      Object.keys(ITEMS).forEach(itemId => {
        const item = ITEMS[itemId];
        if (ITEM_CATEGORIES[item.tier]) {
          ITEM_CATEGORIES[item.tier].push(itemId);
        }
      });
    }

    // Populate enemy buttons by category
    populateEnemyCategory('enemiesEarly', ENEMY_CATEGORIES.early);
    populateEnemyCategory('enemiesMid', ENEMY_CATEGORIES.mid);
    populateEnemyCategory('enemiesLate', ENEMY_CATEGORIES.late);

    // Populate elite modifier buttons
    populateEliteModifiers();

    // Populate item buttons by tier
    populateItemCategory('itemsWhite', ITEM_CATEGORIES.WHITE);
    populateItemCategory('itemsGreen', ITEM_CATEGORIES.GREEN);
    populateItemCategory('itemsRed', ITEM_CATEGORIES.RED);
    populateItemCategory('itemsLegendary', ITEM_CATEGORIES.LEGENDARY);

    // Setup tab switching
    setupDebugTabs();
  }

  function populateEnemyCategory(containerId, enemyIds) {
    const container = document.getElementById(containerId);
    if (!container) return;
    container.textContent = '';

    enemyIds.forEach(typeId => {
      const type = ENEMY_TYPES[typeId];
      const btn = document.createElement('button');
      btn.className = 'debug-spawn-btn';
      btn.dataset.type = typeId;
      btn.style.borderColor = type.color;
      btn.textContent = type.name;
      btn.addEventListener('click', () => spawnPracticeEnemy(typeId));

      // Hover tooltip
      const desc = getEnemyDescription(typeId);
      const meta = `HP: ${type.baseHP}x | Speed: ${type.baseSpeed}x | Wave ${type.minWave}+`;
      btn.addEventListener('mouseenter', (e) => showTooltip(e, type.name, desc, meta));
      btn.addEventListener('mousemove', moveTooltip);
      btn.addEventListener('mouseleave', hideTooltip);

      container.appendChild(btn);
    });
  }

  function spawnPracticeEnemy(typeId) {
    // Spawn at random position around player
    const angle = Math.random() * Math.PI * 2;
    const dist = 150 + Math.random() * 100;
    const x = player.x + Math.cos(angle) * dist;
    const y = player.y + Math.sin(angle) * dist;

    const enemy = spawnEnemyOfType(x, y, typeId);
    if (enemy && selectedEliteModifier) {
      applyEliteModifier(enemy, selectedEliteModifier);
    }
    updateDebugStatus('Spawned: ' + ENEMY_TYPES[typeId].name + (selectedEliteModifier ? ' (' + ELITE_MODIFIERS[selectedEliteModifier].name + ')' : ''));
  }

  function getEnemyDescription(typeId) {
    const descriptions = {
      mumble: 'Basic enemy. Slowly chases the player.',
      stutter: 'Stops and starts erratically while approaching.',
      whisper: 'Nearly invisible until close to the player.',
      shout: 'Charges at high speed after a brief windup.',
      footnote: 'Tiny, fast enemies that spawn in groups.',
      slur: 'Slow but sturdy. Hard to read word.',
      jargon: 'Very tough enemy with difficult technical words.',
      palindrome: 'Splits into two smaller enemies on death.',
      echo: 'Copies the word of the last enemy you killed.',
      typo: 'Word scrambles periodically while alive.',
      censor: 'Some letters are blacked out. Type carefully!',
      quote: 'Long famous quotes. High HP but slow.',
      thesis: 'Boss-tier enemy. Extremely tough.',
      citation_needed: 'Summons mumble enemies over time.',
      misspelling: 'Intentionally misspelled words. Heals on your typos.'
    };
    return descriptions[typeId] || 'No description available.';
  }

  function populateEliteModifiers() {
    const container = document.getElementById('eliteModifiers');
    if (!container) return;
    container.textContent = '';

    // Add "None" option
    const noneBtn = document.createElement('button');
    noneBtn.className = 'debug-spawn-btn' + (selectedEliteModifier === null ? ' active' : '');
    noneBtn.dataset.modifier = 'none';
    noneBtn.textContent = 'None';
    noneBtn.addEventListener('click', () => selectEliteModifier(null));
    noneBtn.addEventListener('mouseenter', (e) => showTooltip(e, 'No Modifier', 'Spawn a normal enemy without elite effects.'));
    noneBtn.addEventListener('mousemove', moveTooltip);
    noneBtn.addEventListener('mouseleave', hideTooltip);
    container.appendChild(noneBtn);

    Object.keys(ELITE_MODIFIERS).forEach(modId => {
      const mod = ELITE_MODIFIERS[modId];
      const btn = document.createElement('button');
      btn.className = 'debug-spawn-btn' + (modId === selectedEliteModifier ? ' active' : '');
      btn.dataset.modifier = modId;
      btn.textContent = mod.name;
      btn.addEventListener('click', () => selectEliteModifier(modId));

      // Hover tooltip
      const desc = getEliteDescription(modId);
      btn.addEventListener('mouseenter', (e) => showTooltip(e, mod.name, desc));
      btn.addEventListener('mousemove', moveTooltip);
      btn.addEventListener('mouseleave', hideTooltip);

      container.appendChild(btn);
    });
  }

  function getEliteDescription(modId) {
    const descriptions = {
      bold: '2x HP and 30% larger. Harder to kill.',
      italic: '2x speed and tilted appearance. Fast and dangerous.',
      underlined: 'Leaves a damage trail behind it.',
      strikethrough: 'Spawns a ghost enemy when killed.',
      superscript: 'Smaller and floats up/down. Harder to hit.',
      subscript: 'Smaller and becomes invisible at range.',
      highlighted: 'Must be killed before other enemies can be targeted.',
      hyperlinked: 'Spawns 2-3 basic enemies when killed.'
    };
    return descriptions[modId] || 'Elite modifier effect.';
  }

  function populateItemCategory(containerId, itemIds) {
    const container = document.getElementById(containerId);
    if (!container) return;
    container.textContent = '';

    itemIds.forEach(itemId => {
      const item = ITEMS[itemId];
      if (!item) return;
      const tier = ITEM_TIERS[item.tier];
      const btn = document.createElement('button');
      btn.className = 'debug-spawn-btn';
      btn.dataset.item = itemId;
      btn.style.borderColor = tier.color;
      btn.textContent = (item.icon || '') + ' ' + item.name;
      btn.addEventListener('click', () => giveItem(itemId));

      // Hover tooltip
      const meta = item.stackEffect ? `Stack: ${item.stackEffect}` : '';
      btn.addEventListener('mouseenter', (e) => showTooltip(e, item.name, item.description, meta));
      btn.addEventListener('mousemove', moveTooltip);
      btn.addEventListener('mouseleave', hideTooltip);

      container.appendChild(btn);
    });
  }

  function setupDebugTabs() {
    const tabs = document.querySelectorAll('.debug-tab');
    tabs.forEach(tab => {
      tab.addEventListener('click', () => {
        // Remove active from all tabs and contents
        document.querySelectorAll('.debug-tab').forEach(t => t.classList.remove('active'));
        document.querySelectorAll('.debug-tab-content').forEach(c => c.classList.remove('active'));

        // Activate clicked tab
        tab.classList.add('active');
        const tabName = tab.dataset.tab;
        const content = document.getElementById(tabName + 'Tab');
        if (content) content.classList.add('active');
      });
    });
  }

  function selectEliteModifier(modId) {
    selectedEliteModifier = modId;
    document.querySelectorAll('#eliteModifiers .debug-spawn-btn').forEach(btn => {
      const isNone = btn.dataset.modifier === 'none';
      btn.classList.toggle('active', isNone ? modId === null : btn.dataset.modifier === modId);
    });
    updateDebugStatus('Elite modifier: ' + (modId ? ELITE_MODIFIERS[modId].name : 'None'));
  }

  function giveItem(itemId) {
    if (!ITEMS[itemId]) return;
    addItem(itemId);
    updateDebugStatus('Added: ' + ITEMS[itemId].name);
  }

  function updateDebugStatus(msg) {
    const status = document.getElementById('debugStatus');
    if (status) status.textContent = msg;
  }

  function startPracticeMode() {
    practiceMode = true;
    initPracticeMode();
    debugPanel.classList.remove('hidden');
    document.getElementById('menu').classList.add('hidden');
    startGame(false);
  }

  function exitPracticeMode() {
    practiceMode = false;
    debugPanel.classList.add('hidden');
    endGame();
  }

  function showPracticePanel() {
    debugPanel.classList.remove('hidden');
  }

  function hidePracticePanel() {
    debugPanel.classList.add('hidden');
  }

  function resumeFromPractice() {
    hidePracticePanel();
    resumeGame();
  }

  // Main menu practice button
  if (practiceBtn) practiceBtn.addEventListener('click', startPracticeMode);

  // Exit practice button
  if (exitPracticeBtn) exitPracticeBtn.addEventListener('click', exitPracticeMode);

  // Close panel button (hides panel but keeps game paused)
  const closePracticePanelBtn = document.getElementById('closePracticePanel');
  if (closePracticePanelBtn) {
    closePracticePanelBtn.addEventListener('click', hidePracticePanel);
  }

  // Resume from practice button
  const resumeFromPracticeBtn = document.getElementById('resumeFromPractice');
  if (resumeFromPracticeBtn) {
    resumeFromPracticeBtn.addEventListener('click', resumeFromPractice);
  }

  // Practice toggle button in pause menu
  const practiceToggleBtn = document.getElementById('practiceToggleBtn');
  if (practiceToggleBtn) {
    practiceToggleBtn.addEventListener('click', () => {
      if (!practiceMode) {
        // Start practice mode from pause
        practiceMode = true;
        initPracticeMode();
      }
      showPracticePanel();
      document.getElementById('pauseMenu').classList.add('hidden');
    });
  }

  // Action buttons
  document.getElementById('clearEnemies').addEventListener('click', () => {
    enemies.releaseAll();
    currentWord = '';
    typedIndex = 0;
    targetEnemy = null;
    firedAtEnemies.clear();
    updateWordDisplay();
    updateDebugStatus('Cleared all enemies');
  });

  document.getElementById('clearItems').addEventListener('click', () => {
    Object.keys(inventory).forEach(key => inventory[key] = 0);
    updateInventoryDisplay();
    updateDebugStatus('Cleared all items');
  });

  document.getElementById('levelUp').addEventListener('click', () => {
    player.level++;
    showUpgradeMenu();
    updateDebugStatus('Level up to ' + player.level);
  });

  document.getElementById('addWave').addEventListener('click', () => {
    gameTime += 30;
    updateDebugStatus('Advanced +30s (wave time)');
  });

  // Full heal button
  const healFullBtn = document.getElementById('healFull');
  if (healFullBtn) {
    healFullBtn.addEventListener('click', () => {
      player.health = player.maxHealth;
      updateHealthBar();
      spawnParticles(player.x, player.y, 10, '#4a7c59');
      updateDebugStatus('Fully healed');
    });
  }

  // Spawn wave button
  const spawnWaveBtn = document.getElementById('spawnWave');
  if (spawnWaveBtn) {
    spawnWaveBtn.addEventListener('click', () => {
      const wave = Math.floor(gameTime / 20) + 1;
      for (let i = 0; i < 10; i++) {
        const edge = Math.floor(Math.random() * 4);
        let x, y;
        switch (edge) {
          case 0: x = Math.random() * canvasWidth; y = -30; break;
          case 1: x = canvasWidth + 30; y = Math.random() * canvasHeight; break;
          case 2: x = Math.random() * canvasWidth; y = canvasHeight + 30; break;
          case 3: x = -30; y = Math.random() * canvasHeight; break;
        }
        const typeId = getEnemyTypeForWave(wave);
        spawnEnemyOfType(x, y, typeId);
      }
      updateDebugStatus('Spawned wave of 10 enemies');
    });
  }

  // Canvas click to spawn random enemy in practice mode
  canvas.addEventListener('click', (e) => {
    if (!practiceMode || gameState !== 'playing') return;

    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;

    // Spawn random enemy type based on current wave
    const wave = Math.floor(gameTime / 20) + 1;
    const typeId = getEnemyTypeForWave(wave);
    const enemy = spawnEnemyOfType(x, y, typeId);

    // Apply selected elite modifier if any
    if (enemy && selectedEliteModifier) {
      applyEliteModifier(enemy, selectedEliteModifier);
    }

    updateDebugStatus('Spawned: ' + ENEMY_TYPES[typeId].name + (selectedEliteModifier ? ' (' + ELITE_MODIFIERS[selectedEliteModifier].name + ')' : ''));
  });

  // Populate items list (uses safe DOM methods)
  function populateItemsList() {
    const itemsList = document.getElementById('itemsList');
    // Clear existing items using safe DOM method
    itemsList.textContent = '';

    // Sort items by tier order
    const tierOrder = ['WHITE', 'GREEN', 'RED', 'LEGENDARY'];
    const sortedItems = Object.values(ITEMS).sort((a, b) => {
      return tierOrder.indexOf(a.tier) - tierOrder.indexOf(b.tier);
    });

    sortedItems.forEach(item => {
      const entry = document.createElement('div');
      entry.className = 'item-entry';
      entry.dataset.tier = item.tier;

      const iconWrap = document.createElement('div');
      iconWrap.className = 'item-icon-wrap';
      iconWrap.appendChild(createIconElement(item.icon || 'help-circle'));

      const info = document.createElement('div');
      info.className = 'item-info';

      const name = document.createElement('div');
      name.className = 'item-name';
      name.textContent = item.name;

      const desc = document.createElement('div');
      desc.className = 'item-desc';
      desc.textContent = item.description;

      info.appendChild(name);
      info.appendChild(desc);
      entry.appendChild(iconWrap);
      entry.appendChild(info);
      itemsList.appendChild(entry);
    });

    // Render Lucide icons
    if (typeof lucide !== 'undefined') lucide.createIcons();
  }

  // Populate upgrades list (uses safe DOM methods)
  function populateUpgradesList() {
    const upgradesList = document.getElementById('upgradesList');
    // Clear existing items using safe DOM method
    upgradesList.textContent = '';

    const upgradeIcons = {
      'dmg': 'swords',
      'aoe': 'target',
      'heal': 'heart',
      'speed': 'zap',
      'magnet': 'magnet',
      'combo': 'flame',
      'armor': 'shield',
      'regen': 'plus',
      'crit': 'sparkles',
      'pierce': 'arrow-right'
    };

    UPGRADES.forEach(upgrade => {
      const entry = document.createElement('div');
      entry.className = 'upgrade-entry';

      const icon = document.createElement('div');
      icon.className = 'upgrade-icon';
      icon.appendChild(createIconElement(upgradeIcons[upgrade.id] || 'star'));

      const info = document.createElement('div');
      info.className = 'upgrade-info';

      const name = document.createElement('div');
      name.className = 'upgrade-name';
      name.textContent = upgrade.name;

      const desc = document.createElement('div');
      desc.className = 'upgrade-desc';
      desc.textContent = upgrade.desc;

      info.appendChild(name);
      info.appendChild(desc);
      entry.appendChild(icon);
      entry.appendChild(info);
      upgradesList.appendChild(entry);
    });

    // Render Lucide icons
    if (typeof lucide !== 'undefined') lucide.createIcons();
  }

  // Populate enemies list (uses safe DOM methods)
  function populateEnemiesList() {
    const enemiesList = document.getElementById('enemiesList');
    // Clear existing items using safe DOM method
    enemiesList.textContent = '';

    // Group enemies by wave category
    const categories = {
      early: { name: 'Early Game (Waves 1-2)', enemies: [] },
      mid: { name: 'Mid Game (Waves 3-6)', enemies: [] },
      late: { name: 'Late Game (Waves 7+)', enemies: [] }
    };

    Object.values(ENEMY_TYPES).forEach(enemy => {
      if (enemy.minWave <= 2) {
        categories.early.enemies.push(enemy);
      } else if (enemy.minWave <= 6) {
        categories.mid.enemies.push(enemy);
      } else {
        categories.late.enemies.push(enemy);
      }
    });

    // Sort each category by minWave
    Object.values(categories).forEach(cat => {
      cat.enemies.sort((a, b) => a.minWave - b.minWave);
    });

    // Render each category
    Object.entries(categories).forEach(([catId, category]) => {
      if (category.enemies.length === 0) return;

      const header = document.createElement('div');
      header.className = 'wave-category-header';
      header.textContent = category.name;
      enemiesList.appendChild(header);

      category.enemies.forEach(enemy => {
        const entry = document.createElement('div');
        entry.className = 'enemy-entry';

        const iconWrap = document.createElement('div');
        iconWrap.className = 'enemy-icon-wrap';
        iconWrap.style.background = enemy.color + '33';
        iconWrap.style.borderColor = enemy.color;
        iconWrap.style.color = enemy.color;
        iconWrap.textContent = enemy.name[0];

        const info = document.createElement('div');
        info.className = 'enemy-info';

        const name = document.createElement('div');
        name.className = 'enemy-name';
        name.textContent = enemy.name;

        const desc = document.createElement('div');
        desc.className = 'enemy-desc';
        desc.textContent = getEnemyDescription(enemy.id);

        const meta = document.createElement('div');
        meta.className = 'enemy-meta';

        const hpStat = document.createElement('span');
        hpStat.className = 'enemy-stat';
        hpStat.textContent = 'HP: ' + enemy.baseHP + 'x';

        const speedStat = document.createElement('span');
        speedStat.className = 'enemy-stat';
        speedStat.textContent = 'Speed: ' + enemy.baseSpeed + 'x';

        const waveStat = document.createElement('span');
        waveStat.className = 'enemy-stat';
        waveStat.textContent = 'Wave ' + enemy.minWave + '+';

        meta.appendChild(hpStat);
        meta.appendChild(speedStat);
        meta.appendChild(waveStat);

        info.appendChild(name);
        info.appendChild(desc);
        info.appendChild(meta);
        entry.appendChild(iconWrap);
        entry.appendChild(info);
        enemiesList.appendChild(entry);
      });
    });
  }

  // Keyboard pause and debug
  document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') {
      // First check if modal is open
      if (isAnyModalOpen()) {
        closeAllModals();
        return;
      }

      // Handle collection menu
      if (collectionMenuOpen) {
        closeCollectionMenu();
        return;
      }

      // When playing: open collection menu if items pending, otherwise pause
      if (gameState === 'playing') {
        if (pendingItems.length > 0) {
          openCollectionMenu();
        } else {
          pauseGame();
        }
        return;
      }

      // When in collecting state, close collection menu
      if (gameState === 'collecting') {
        closeCollectionMenu();
        return;
      }

      // When paused, resume
      if (gameState === 'paused') {
        resumeGame();
        return;
      }
    }
    // Backspace item - delete closest enemy
    if (e.key === 'Backspace' && gameState === 'playing') {
      if (ITEMS.backspace_item && ITEMS.backspace_item.canUse()) {
        e.preventDefault();
        ITEMS.backspace_item.use();
        updateActiveItemsDisplay();
      }
    }

    // Ctrl+Z (PC) or Cmd+Z (Mac) - manual rewind trigger (if ctrl_z item allows)
    if (e.key === 'z' && (e.ctrlKey || e.metaKey) && gameState === 'playing') {
      e.preventDefault();
      // Ctrl+Z item is passive (triggers on death), but we can show feedback
      if (inventory['ctrl_z'] && !ITEMS.ctrl_z.used) {
        // Visual feedback that the item is ready
        spawnParticles(player.x, player.y, 5, '#00ffff');
      }
    }
  });

  // First interaction for audio
  document.addEventListener('click', initAudio, { once: true });
  document.addEventListener('keydown', initAudio, { once: true });

  // === [SEC:TIPS] TIP SYSTEM ===
  // Contextual first-time tips with narrator flavor
  const TIPS_STORAGE_KEY = 'word_survivor_tips';
  const TIPS_ENABLED_KEY = 'word_survivor_tips_enabled';
  const tipOverlay = document.getElementById('tipOverlay');
  const tipModal = document.getElementById('tipModal');
  const tipsCheckbox = document.getElementById('tipsCheckbox');
  let tipsShown = [];
  let tipsEnabled = true;

  // Load tips enabled preference
  function loadTipsEnabled() {
    try {
      const data = localStorage.getItem(TIPS_ENABLED_KEY);
      // Default to true if not set
      tipsEnabled = data === null ? true : data === 'true';
      if (tipsCheckbox) tipsCheckbox.checked = tipsEnabled;
    } catch (e) {
      tipsEnabled = true;
    }
  }
  loadTipsEnabled();

  // Save tips enabled preference
  function saveTipsEnabled() {
    try {
      localStorage.setItem(TIPS_ENABLED_KEY, tipsEnabled.toString());
    } catch (e) {
      console.warn('Failed to save tips preference:', e);
    }
  }

  // Handle checkbox change
  if (tipsCheckbox) {
    tipsCheckbox.addEventListener('change', () => {
      tipsEnabled = tipsCheckbox.checked;
      saveTipsEnabled();
    });
  }

  // Load tips from localStorage
  function loadTipsShown() {
    try {
      const data = localStorage.getItem(TIPS_STORAGE_KEY);
      tipsShown = data ? JSON.parse(data) : [];
    } catch (e) {
      tipsShown = [];
    }
  }
  loadTipsShown(); // Initialize on load

  // Save tips to localStorage
  function saveTipsShown() {
    try {
      localStorage.setItem(TIPS_STORAGE_KEY, JSON.stringify(tipsShown));
    } catch (e) {
      console.warn('Failed to save tips:', e);
    }
  }

  // Tip definitions
  const TIPS = {
    whitespace: {
      id: 'whitespace',
      narratorQuote: "The space between words holds power... Step beyond the lines, and time itself bends to your will.",
      practicalTitle: "Between the Lines",
      practicalText: "Moving pauses time—reposition and collect XP/items, but you can't type while moving."
    },
    levelup: {
      id: 'levelup',
      narratorQuote: "Power courses through you now. Choose wisely—each path reshapes your destiny.",
      practicalTitle: "Pick 1 of 3 upgrades.",
      practicalText: "Options are random. Upgrades stack."
    },
    passive_item: {
      id: 'passive_item',
      narratorQuote: "A relic that binds to your essence. Its power is constant, unwavering—like the words themselves.",
      practicalTitle: "Passive items are always active.",
      practicalText: "Their effects apply automatically. Collect duplicates to stack.",
      includeItem: true
    },
    active_item: {
      id: 'active_item',
      narratorQuote: "This one awakens only in moments of triumph. Complete your words, and feel its surge.",
      practicalTitle: "Active items trigger on events.",
      practicalText: "Word complete, keypress, damage taken—each has its moment.",
      includeItem: true
    },
    combo: {
      id: 'combo',
      narratorQuote: "Your rhythm quickens. The words flow through you now—do not let the chain break.",
      practicalTitle: "Combos multiply XP.",
      practicalText: "Mistype or pause resets the chain."
    },
    item_drop: {
      id: 'item_drop',
      narratorQuote: "Spoils of battle await your claim. The words grow restless—collect when ready, not when forced.",
      practicalTitle: "Items queue for collection.",
      practicalText: "Press [ESC] or click the widget to open the collection menu. Choose one item from each drop. Upgrades stack existing items!"
    }
  };

  // Check if tip should show
  function shouldShowTip(tipId) {
    if (!tipsEnabled) return false;
    return !tipsShown.includes(tipId);
  }

  // Get tier color for item showcase
  function getTierColor(tier) {
    const colors = {
      'WHITE': '#aaa',
      'GREEN': '#2ecc71',
      'RED': '#e74c3c',
      'LEGENDARY': '#f39c12'
    };
    return colors[tier] || '#aaa';
  }

  // Show tip modal (pauses game)
  function showTip(tipId, itemData = null) {
    if (!shouldShowTip(tipId)) return false;

    const tip = TIPS[tipId];
    if (!tip) return false;

    // Pause game while tip is shown
    tipModalActive = true;

    // Mark as shown
    tipsShown.push(tipId);
    saveTipsShown();

    // Build modal content using safe DOM methods
    tipModal.textContent = '';

    // Narrator section
    const narratorSection = document.createElement('div');
    narratorSection.className = 'tip-narrator';

    const narratorIcon = document.createElement('div');
    narratorIcon.className = 'tip-narrator-icon';
    const scrollIcon = createIconElement('scroll-text');
    narratorIcon.appendChild(scrollIcon);

    const narratorQuote = document.createElement('div');
    narratorQuote.className = 'tip-narrator-quote';
    narratorQuote.textContent = '"' + tip.narratorQuote + '"';

    narratorSection.appendChild(narratorIcon);
    narratorSection.appendChild(narratorQuote);
    tipModal.appendChild(narratorSection);

    // Item showcase (if applicable)
    if (tip.includeItem && itemData) {
      const showcase = document.createElement('div');
      showcase.className = 'tip-item-showcase';

      const iconEl = document.createElement('div');
      iconEl.className = 'tip-item-icon';
      const tierColor = getTierColor(itemData.tier);
      iconEl.style.background = 'rgba(' + (itemData.tier === 'LEGENDARY' ? '243, 156, 18' : itemData.tier === 'RED' ? '231, 76, 60' : itemData.tier === 'GREEN' ? '46, 204, 113' : '170, 170, 170') + ', 0.2)';
      iconEl.style.borderColor = tierColor;
      iconEl.appendChild(createIconElement(itemData.icon || 'help-circle'));

      const infoEl = document.createElement('div');
      infoEl.className = 'tip-item-info';

      const tierEl = document.createElement('div');
      tierEl.className = 'tip-item-tier';
      tierEl.style.color = tierColor;
      tierEl.textContent = itemData.tier;

      const nameEl = document.createElement('div');
      nameEl.className = 'tip-item-name';
      nameEl.textContent = itemData.name;

      const descEl = document.createElement('div');
      descEl.className = 'tip-item-desc';
      descEl.textContent = itemData.description;

      infoEl.appendChild(tierEl);
      infoEl.appendChild(nameEl);
      infoEl.appendChild(descEl);
      showcase.appendChild(iconEl);
      showcase.appendChild(infoEl);
      tipModal.appendChild(showcase);
    }

    // Practical section
    const practicalSection = document.createElement('div');
    practicalSection.className = 'tip-practical';

    const practicalTitle = document.createElement('div');
    practicalTitle.className = 'tip-practical-title';
    practicalTitle.textContent = tip.practicalTitle;

    const practicalText = document.createElement('div');
    practicalText.className = 'tip-practical-text';
    practicalText.textContent = tip.practicalText;

    practicalSection.appendChild(practicalTitle);
    practicalSection.appendChild(practicalText);
    tipModal.appendChild(practicalSection);

    // Dismiss hint
    const dismissHint = document.createElement('p');
    dismissHint.className = 'tip-dismiss-hint';
    dismissHint.textContent = 'Press any key to continue';
    dismissHint.style.color = '#666';
    dismissHint.style.fontSize = '13px';
    dismissHint.style.marginTop = '20px';
    dismissHint.style.fontStyle = 'italic';
    tipModal.appendChild(dismissHint);

    // Show modal
    tipOverlay.classList.remove('hidden');
    tipModal.classList.remove('hidden');

    // Render Lucide icons
    if (typeof lucide !== 'undefined') lucide.createIcons();

    return true;
  }

  // Dismiss tip modal
  function dismissTip() {
    tipModalActive = false; // Resume game
    tipOverlay.classList.add('hidden');
    tipModal.classList.add('hidden');
  }

  // Check if tip modal is open
  function isTipOpen() {
    return !tipModal.classList.contains('hidden');
  }

  // Dismiss tip on overlay click
  tipOverlay.addEventListener('click', dismissTip);

  // Dismiss tip on any key press
  document.addEventListener('keydown', (e) => {
    if (isTipOpen()) {
      dismissTip();
    }
  });

  // === [SEC:MOBTIPS] MOB TIP SYSTEM ===
  // Non-blocking mini tips for enemy types (shows in corner, doesn't pause game)
  const MOB_TIPS_STORAGE_KEY = 'word_survivor_mob_tips';
  const mobTipEl = document.getElementById('mobTip');
  let mobTipsShown = [];
  let mobTipTimeout = null;

  // Load shown mob tips from localStorage
  function loadMobTipsShown() {
    try {
      const data = localStorage.getItem(MOB_TIPS_STORAGE_KEY);
      mobTipsShown = data ? JSON.parse(data) : [];
    } catch (e) {
      mobTipsShown = [];
    }
  }
  loadMobTipsShown();

  // Save shown mob tips to localStorage
  function saveMobTipsShown() {
    try {
      localStorage.setItem(MOB_TIPS_STORAGE_KEY, JSON.stringify(mobTipsShown));
    } catch (e) {
      console.warn('Failed to save mob tips:', e);
    }
  }

  // Check if mob tip should be shown
  function shouldShowMobTip(enemyType) {
    if (!tipsEnabled) return false;
    if (mobTipsShown.includes(enemyType)) return false;
    return true;
  }

  // Show mob tip for enemy type (non-blocking)
  function showMobTip(enemyType) {
    if (!shouldShowMobTip(enemyType)) return;

    const typeConfig = ENEMY_TYPES[enemyType];
    if (!typeConfig) return;

    // Mark as shown
    mobTipsShown.push(enemyType);
    saveMobTipsShown();

    // Clear any existing timeout
    if (mobTipTimeout) {
      clearTimeout(mobTipTimeout);
      mobTipTimeout = null;
    }

    // Build tip content
    mobTipEl.textContent = '';

    // Set border color to enemy color
    mobTipEl.style.borderColor = typeConfig.color;

    // Dismiss button
    const dismissBtn = document.createElement('button');
    dismissBtn.className = 'mob-tip-dismiss';
    const closeIcon = createIconElement('x');
    dismissBtn.appendChild(closeIcon);
    dismissBtn.addEventListener('click', dismissMobTip);
    mobTipEl.appendChild(dismissBtn);

    // Header with icon and name
    const header = document.createElement('div');
    header.className = 'mob-tip-header';

    const icon = document.createElement('div');
    icon.className = 'mob-tip-icon';
    icon.style.background = typeConfig.color + '33';
    icon.style.borderColor = typeConfig.color;
    icon.style.color = typeConfig.color;
    icon.textContent = typeConfig.name[0];

    const name = document.createElement('div');
    name.className = 'mob-tip-name';
    name.textContent = typeConfig.name;

    header.appendChild(icon);
    header.appendChild(name);
    mobTipEl.appendChild(header);

    // Description
    const desc = document.createElement('div');
    desc.className = 'mob-tip-description';
    desc.textContent = getEnemyDescription(enemyType);
    mobTipEl.appendChild(desc);

    // Position below inventory display to prevent overlap
    const inventoryEl = document.getElementById('inventoryDisplay');
    if (inventoryEl && !inventoryEl.classList.contains('hidden')) {
      const inventoryRect = inventoryEl.getBoundingClientRect();
      mobTipEl.style.top = (inventoryRect.bottom + 10) + 'px';
    } else {
      mobTipEl.style.top = 'calc(env(safe-area-inset-top, 10px) + 24px)';
    }

    // Show tip
    mobTipEl.classList.remove('hidden', 'fading');

    // Auto-dismiss after 5 seconds
    mobTipTimeout = setTimeout(() => {
      dismissMobTip();
    }, 5000);
  }

  // Dismiss mob tip with fade animation
  function dismissMobTip() {
    if (mobTipEl.classList.contains('hidden')) return;

    mobTipEl.classList.add('fading');

    setTimeout(() => {
      mobTipEl.classList.add('hidden');
      mobTipEl.classList.remove('fading');
    }, 300);

    if (mobTipTimeout) {
      clearTimeout(mobTipTimeout);
      mobTipTimeout = null;
    }
  }

  // --- [SEC:MANAGEMENT:SERVICEWORKER] SERVICE WORKER ---
  if ('serviceWorker' in navigator) {
    navigator.serviceWorker.register('sw.js').catch(() => {});
  }

  // --- [SEC:INPUT:MOBILE] MOBILE DETECTION ---
  const isMobileDevice = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)
    || (navigator.maxTouchPoints > 0 && window.innerWidth < 768);

  const isTestMode = window.location.search.includes('test=1');

  if (isMobileDevice && !isTestMode) {
    document.getElementById('mobileNotice').classList.remove('hidden');
  }

  console.log('Word Survivor loaded!');

  // Initialize Lucide icons on page load
  if (typeof lucide !== 'undefined') lucide.createIcons();

  // === TEST MODE EXPOSURE ===
  // When ?test=1 is in URL, expose game internals for automated testing
  if (isTestMode) {
    // Disable tips in test mode so they don't block the game loop
    tipsEnabled = false;
    window.__GAME__ = {
      // State getters
      gameState: () => gameState,
      player: () => ({ ...player }),
      enemies: () => enemies.active.map(e => ({ ...e })),
      projectiles: () => projectiles.active.map(p => ({ ...p })),
      gems: () => gems.active.map(g => ({ ...g })),
      inventory: () => ({ ...inventory }),
      stats: () => ({ ...stats }),
      mods: () => ({ ...mods }),
      currentWord: () => currentWord,
      typedIndex: () => typedIndex,
      targetEnemy: () => targetEnemy,

      // Pools
      enemyPool: enemies,
      projectilePool: projectiles,
      gemPool: gems,

      // Config
      ITEMS: ITEMS,
      ENEMY_TYPES: ENEMY_TYPES,
      ELITE_MODIFIERS: ELITE_MODIFIERS,

      // Balance state
      mercyInvincibleUntil: () => mercyInvincibleUntil,
      getDifficultyForWave,

      // Exposed functions
      startGame,
      resetGame: () => { gameState = 'menu'; showScreen('menu'); },
      spawnEnemyOfType,
      addItem,
      callHooks,
      applyEliteModifier,
      updateGame: (dt) => {
        // Manual update for testing - advances game logic by dt seconds
        if (gameState === 'playing') {
          update(dt / 1000);
        }
      },
    };
    console.log('Test mode enabled - window.__GAME__ available');
  }

  </script>
</body>
</html>
